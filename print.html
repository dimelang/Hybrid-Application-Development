<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hybrid Application Development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hybrid Application Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pendahuluan"><a class="header" href="#pendahuluan">Pendahuluan</a></h1>
<h2 id="apa-itu-react-native"><a class="header" href="#apa-itu-react-native">Apa itu React Native?</a></h2>
<p>React Native adalah <strong>framework open-source</strong> yang dikembangkan oleh <strong>Meta (Facebook)</strong> untuk membangun aplikasi mobile <strong>Android</strong> dan <strong>iOS</strong> menggunakan bahasa pemrograman <strong>JavaScript</strong> atau <strong>TypeScript</strong>.<br />
Dengan React Native, developer dapat menulis satu basis kode dan menjalankannya di berbagai platform tanpa harus menulis kode terpisah untuk Android (Java/Kotlin) dan iOS (Objective-C/Swift).</p>
<hr />
<h2 id="mengapa-react-native"><a class="header" href="#mengapa-react-native">Mengapa React Native?</a></h2>
<p>Beberapa alasan mengapa React Native populer di kalangan developer:</p>
<ol>
<li>
<p><strong>Cross-Platform</strong><br />
Satu kode bisa berjalan di Android dan iOS.</p>
</li>
<li>
<p><strong>Performance Lebih Baik dibanding Hybrid Webview</strong><br />
React Native menggunakan komponen native, bukan sekadar membungkus aplikasi web.</p>
</li>
<li>
<p><strong>Hot Reloading &amp; Fast Refresh</strong><br />
Mempercepat proses pengembangan karena perubahan kode bisa langsung dilihat tanpa build ulang penuh.</p>
</li>
<li>
<p><strong>Ekosistem &amp; Komunitas Besar</strong><br />
Banyak library, tutorial, dan komunitas aktif.</p>
</li>
<li>
<p><strong>Dukungan TypeScript</strong><br />
Menjadikan aplikasi lebih aman dan maintainable.</p>
</li>
</ol>
<hr />
<h2 id="arsitektur-dasar-react-native"><a class="header" href="#arsitektur-dasar-react-native">Arsitektur Dasar React Native</a></h2>
<p>Secara garis besar, arsitektur React Native terdiri dari:</p>
<ul>
<li><strong>JavaScript Layer</strong> → tempat kode aplikasi ditulis (JS/TS).</li>
<li><strong>Bridge</strong> → penghubung antara JavaScript dan kode native.</li>
<li><strong>Native Layer</strong> → komponen asli Android/iOS (misalnya <code>View</code>, <code>Text</code>, <code>Button</code>).</li>
</ul>
<hr />
<h2 id="perbedaan-react-native-dengan-framework-lain"><a class="header" href="#perbedaan-react-native-dengan-framework-lain">Perbedaan React Native dengan Framework Lain</a></h2>
<ul>
<li><strong>Flutter</strong> → menggunakan bahasa Dart dan rendering engine sendiri.</li>
<li><strong>Ionic / Cordova</strong> → berbasis WebView.</li>
<li><strong>React Native</strong> → menggunakan komponen asli (native component) sehingga performa lebih dekat ke aplikasi native.</li>
</ul>
<hr />
<h2 id="kebutuhan-backend-untuk-aplikasi-mobile"><a class="header" href="#kebutuhan-backend-untuk-aplikasi-mobile">Kebutuhan Backend untuk Aplikasi Mobile</a></h2>
<p>Aplikasi mobile modern biasanya membutuhkan backend untuk menangani:</p>
<ol>
<li><strong>Autentikasi pengguna</strong>
Login, register, refresh token, otorisasi.</li>
<li><strong>Penyimpanan data</strong>
Menyimpan data pengguna, transaksi, preferensi, dsb.</li>
<li><strong>Sinkronisasi antar perangkat</strong>
Contoh: data TODO yang sama muncul di Android atau iOS.</li>
<li><strong>Pengolahan data di server</strong>
Validasi, filtering, aggregasi, perhitungan, dan business logic lainnya.</li>
<li><strong>Integrasi dengan layanan eksternal</strong>
Pembayaran, notifikasi, cloud storage, dan sebagainya.</li>
</ol>
<p>Untuk memenuhi kebutuhan ini, kita memerlukan backend API yang cepat, fleksibel, dan mudah dipelajari.</p>
<p>Express.js adalah framework backend Node.js yang ringan, cepat, dan sangat populer. Beberapa alasan Express sering dipilih sebagai backend aplikasi React Native:</p>
<ol>
<li><strong>Bahasa yang sama</strong>
Backend dan frontend sama-sama menggunakan JavaScript/TypeScript → lebih mudah dipelajari.</li>
<li><strong>Ringan dan fleksibel</strong>
Tidak terlalu opiniated sehingga cocok untuk aplikasi kecil hingga besar.</li>
<li><strong>Ekosistem luas</strong>
Banyak library untuk autentikasi, database, upload file, logging, dsb.</li>
<li><strong>Mudah diintegrasikan dengan mobile apps</strong>
API yang dibangun dengan Express sangat mudah dipanggil dari React Native menggunakan fetch atau axios.</li>
<li><strong>Digunakan di industri</strong>
Banyak perusahaan menggunakan stack React Native + Express.js + MongoDB/PostgreSQL.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-script-intro"><a class="header" href="#type-script-intro">Pengenalan TypeScript</a></h1>
<h2 id="apa-itu-typescript"><a class="header" href="#apa-itu-typescript">Apa itu TypeScript?</a></h2>
<p>TypeScript adalah superset dari JavaScript yang artinya seluruh kode JavaScript valid bisa dijalankan di TypeScript, tapi TypeScript menambahkan fitur baru, yang paling penting adalah static typing.</p>
<p>Dengan TypeScript, kita bisa menentukan tipe data untuk variabel, fungsi, maupun objek, sehingga kesalahan bisa dicegah sejak proses pengembangan (compile time), bukan saat aplikasi sudah berjalan (runtime).</p>
<h2 id="mengapa-typescript-dibutuhkan"><a class="header" href="#mengapa-typescript-dibutuhkan">Mengapa TypeScript Dibutuhkan?</a></h2>
<p>JavaScript sangat fleksibel (loosely typed), tapi justru karena itu sering menimbulkan bug yang sulit dilacak. Misalnya:</p>
<pre><code class="language-js">let age = 25;
age = "dua puluh lima"; // JavaScript tidak error
</code></pre>
<p>Kalau kode di atas berjalan di aplikasi besar, bisa menimbulkan error tidak terduga.
Dengan TypeScript:</p>
<pre><code class="language-ts">let age: number = 25;
age = "dua puluh lima"; // ❌ Error saat compile
</code></pre>
<p>Dengan demikian, menggunakan typescript, kesalahan dapat terdeteksi lebih awal.</p>
<h3 id="keunggulan-yang-dimiliki-oleh-typescript"><a class="header" href="#keunggulan-yang-dimiliki-oleh-typescript">Keunggulan yang dimiliki oleh TypeScript:</a></h3>
<ol>
<li><strong>Type safety</strong>, kode lebih aman karena ada pemeriksaan tipe.</li>
<li><strong>Autocompletion</strong>, beberap editor bisa memberi saran kode yang lebih akurat.</li>
<li><strong>Lebih mudah dipelihara</strong>, terutama di proyek besar dengan banyak developer.</li>
<li><strong>Mendukung fitur modern JavaScript</strong>, TypeScript selalu up-to-date dengan ECMAScript terbaru.</li>
<li><strong>Kompatibel dengan JavaScript</strong>, kode JS bisa langsung dipakai di TS.</li>
</ol>
<h2 id="instalasi"><a class="header" href="#instalasi">Instalasi</a></h2>
<p>Sebelum menggunakan TypeScript, pastikan di komputer teman-teman sudah menginstal <a href="https://nodejs.org/en/download">Node.js</a>. Untuk memastikan <strong>Node.js</strong> sudah berhasil diinstal, silahkan jalankan perintah berikut di dalam terminal/CMD.</p>
<pre><code>node -v
</code></pre>
<p>Hasilnya adalah versi dari <strong>Node.js</strong> yang diinstal. Selanjutnya, lakukan instalasi TypeScript melalui <em>npm</em>. Jalankan perintah berikut untuk menginstal TypeScript secara <em>global</em>.</p>
<pre><code>npm install -g typescript
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membuat-dan-menjalankan-program-typescript"><a class="header" href="#membuat-dan-menjalankan-program-typescript">Membuat dan Menjalankan Program TypeScript</a></h1>
<p>Sekarang mari buat file TypeScript pertama kita. TypeScript dapat ditulis dalam file <code>.ts</code> yang nantinya akan dikompilasi ke JavaScript lalu jalankan menggunakan <strong>Node.js</strong>.</p>
<h2 id="langkah-langkah"><a class="header" href="#langkah-langkah">Langkah-langkah</a></h2>
<ol>
<li>
<p>Buat file <code>hello.ts</code></p>
<pre><code class="language-ts">let word: string = "World";
console.log(`Hello, ${word}!`);
</code></pre>
</li>
<li>
<p>Kompilasi file <code>hello.ts</code> ke JavaScript menggunakan perintah berikut di terminal/CMD.</p>
<pre><code class="language-bash">tsc hello.ts
</code></pre>
<p>Nantinya, akan tercipta sebuah file baru yaitu <code>hello.js</code></p>
</li>
<li>
<p>Jalankan dengan Node.js menggunakan perintah termnial/CMD berikut</p>
<pre><code>node hello.js
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar"><a class="header" href="#konsep-typescript-1-tipe-data-dasar">Konsep TypeScript 1: Tipe Data Dasar</a></h1>
<p>Di JavaScript, kita bebas memberikan nilai apapun ke sebuah variabel. Ini tentunya sangat fleksibel, tapi berpotensi menyebabkan bug. Seperti yang telah dijelaskan <a href="./typescript.html">di awal</a>. TypeScript hadir dengan sistem tipe yang ketat: kita bisa mendefinisikan sejak awal bahwa variabel hanya boleh menyimpan data dengan tipe tertentu. Dengan cara ini, kesalahan dapat dideteksi lebih awal, bahkan sebelum program dijalankan. TypeScript memiliki beberapa tipe data dasar, yaitu</p>
<ol>
<li>
<p><strong>String</strong></p>
<p>Digunakan untuk menyimpan data string yang menggunakan <code>"</code> atau <code>'</code></p>
<pre><code class="language-ts">let word: string = "World";
let greeting: string = `Hello, ${word}!`;
</code></pre>
</li>
</ol>
<hr />
<ol start="2">
<li>
<p><strong>Number</strong></p>
<p>Digunakan untuk menyimpan data numerik seperti (integer, float/pecahan, heksadesimal, oktal)</p>
<pre><code class="language-ts">let age: number = 25;
let pi: number = 3.14;
let hex: number = 0xff;   // 255
let binary: number = 0b1010; // 10
let octal: number = 0o744; // 484
</code></pre>
</li>
</ol>
<hr />
<ol start="3">
<li><strong>Boolean</strong>
Digunakan untuk menyimpan data yang bernilai <code>true</code> atau <code>false</code>
<pre><code class="language-ts">let isActive: boolean = true;
let isAdmin: boolean = false;
</code></pre>
</li>
</ol>
<hr />
<ol start="4">
<li>
<p><strong>Null dan Undefined</strong></p>
<p><code>null</code> merupakan nilai kosong yang diberikan secara eksplisit. Akan dikonversi menjadi 0 dalam operasi aritmatika.
<code>undefined</code> merupakan nilai default ketika suatu variable belum diberi nilai. Akan menghasilkan NaN (Not a Number) dalam operasi aritmatika.</p>
<pre><code class="language-ts">let emptyValue: null = null;
let notAssigned: undefined = undefined;
</code></pre>
</li>
</ol>
<hr />
<p>Selain tipe data dasar di atas, TypeScript juga memiliki beberapa tipe data khusus seperti</p>
<ol>
<li>
<p><strong>Any</strong></p>
<p>Tipe data yang menonaktifkan pemeriksaan tipe sehingga memperbolehkan variable atau fungsi menerima dan menampung nilai dari tipe data apapun. Tapi ini menghilangkan manfaat TypeScript, jadi gunakan hanya jika perlu.</p>
<pre><code class="language-ts">let randomValue: any = 10;
randomValue = "Hello"; // tidak error
randomValue = true;    // tidak error
</code></pre>
</li>
<li>
<p><strong>Unknown</strong></p>
<p>Tipe data yang merepresentasikan nilai yang tipenya tidak diketahui atau tidak pasti pada saat kompilasi. Mirip <code>any</code>, tapi lebih aman. Kita harus cek tipe sebelum digunakan.</p>
<pre><code class="language-ts">let input: unknown = "Hello";
if (typeof input === "string") {
    console.log(input.toUpperCase()); // HELLO
}

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar-lanjutan"><a class="header" href="#konsep-typescript-1-tipe-data-dasar-lanjutan">Konsep TypeScript 1: Tipe Data Dasar Lanjutan</a></h1>
<ol>
<li>
<p><strong>Array</strong></p>
<p>TypeScript juga memiliki beberapa struktur data yang juga terdapat dalam JavaScript. Array digunakan untuk menyimpan sekumpulan nilai dengan urutan tertentu. Bedanya, di TypeScript kita bisa menentukan tipe data yang boleh ada di dalam array. Hal ini membuat array kita lebih konsisten, karena semua elemennya punya tipe yang sama.“</p>
<pre><code class="language-ts">let numbers: number[] = [1, 2, 3, 4];
let names: string[] = ["Ani", "Budi", "Citra"];
</code></pre>
<p>Atau dengan generics</p>
<pre><code class="language-ts">let scores: Array&lt;number&gt; = [90, 80, 100];
</code></pre>
</li>
<li>
<p><strong>Tuple</strong></p>
<p>Jenis struktur data seperti array yang memiliki panjang tetap dan tipe data yang ditentukan untuk setiap posisinya. Ini berbeda dari array biasa karena tuple menjamin jumlah elemen dan urutan tipenya. Tuple cocok digunakan untuk merepresentasikan kumpulan nilai yang terstruktur, seperti koordinat (x, y) atau nilai RGB (merah, hijau, biru), di mana setiap posisi memiliki arti yang jelas</p>
<pre><code class="language-ts">let person: [string, number] = ["Alice", 25]; // Di sini, elemen pertama wajib diisi dengan string dan elemen kedua adalah numerik
console.log(person[0]); // Alice
console.log(person[1]); // 25
</code></pre>
</li>
<li>
<p><strong>Enum</strong></p>
<p>Sekumpulan nilai konstan yang lebih mudah dibaca. Pada TypeScript <code>Enum</code> disediakan dalam bentuk numeric dan string atau bahkan keduanya. Untuk mendefiniskan <code>Enum</code> kita menggunakan keyword <code>enum</code>.</p>
<pre><code class="language-ts">enum NameOfEnum {
   member: constantValue // constantValue is optional
}
</code></pre>
<p><strong>Numeric Enums</strong>
Artinya adalah kita melakukan inisiasi pada member dengan tipe data Number.</p>
<pre><code class="language-ts">enum Direction {
    Up=1,
    Down,
    Left,
    Right
}

let move_up: Direction = Direction.Up;
let move_down: Direction = Direction.Down;
let move_left: Direction = Direction.Left;
let move_right: Direction = Direction.Right;

console.log(move_up); // 1
console.log(move_down); // 2
console.log(move_left); // 3
console.log(move_right); // 4
</code></pre>
<p>Enum pada TypeScript menganut sistem Auto Incerement dari setelah member yand diberi inisiasi</p>
<p><strong>String Enums</strong>
Pada dasarnya sama dengan Numeric Enums hanya saja perbedaanya adalah ketika kita assign pada member tipenya adalah String. Dan satu hal lagi tidak ada konsep Auto Increment pada String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up="UP",
    Down="DOWN",
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
<p><strong>Heterogeneous Enums</strong>
Enum jenis ini adalah gabungan dari Numeric Enums dan String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up=0,
    Down=1,
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
</li>
<li>
<p><strong>Union</strong>
Fitur yang memungkinkan sebuah variabel memiliki salah satu dari beberapa tipe data yang berbeda atau lebih sederhananya bisa menyimpan lebih dari satu tipe.</p>
<pre><code class="language-ts">let id: string | number;
id = "ABC123"; // ✅
id = 101;      // ✅
id = true;     // ❌ Error

</code></pre>
</li>
<li>
<p><strong>Literal</strong>
Variable yang membatasi nilai hanya ke konstanta tertentu.</p>
<pre><code class="language-ts">let direction: "up" | "down";
direction = "up";   // ✅
direction = "down"; // ✅
direction = "left"; // ❌ Error

</code></pre>
</li>
</ol>
<p>Sebenarnya, TypeScript memiliki mekanisme untuk menentukan tipe data dari suatu variable berdasarkan nilainya (type inference).</p>
<pre><code class="language-ts">let city = "Semarang"; // otomatis string
city = 123; // ❌ Error
</code></pre>
<p>Jika deklarasi tanpa nilai</p>
<pre><code class="language-ts">let data; // otomatis any
data = "Hello";
data = 123;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-2-function--parameter"><a class="header" href="#konsep-typescript-2-function--parameter">Konsep TypeScript 2: Function &amp; Parameter</a></h1>
<p>Dalam JavaScript, function bisa menerima argumen apa saja dan mengembalikan apapun. Ini tentunya sangat fleksibel, tapi rawan error. Dengan TypeScript, kita bisa menentukan tipe parameter dan tipe return value, sehingga function lebih jelas dan aman.</p>
<p>Contoh JavaScript:</p>
<pre><code class="language-js">function add(a, b) {
  return a + b;
}

console.log(add(10, "20")); // "1020" → salah paham jadi string
</code></pre>
<p>Contoh TypeScript</p>
<pre><code class="language-ts">function add(a: number, b: number): number {
  return a + b;
}

console.log(add(10, 20)); // 30
console.log(add(10, "20")); // ❌ Error

</code></pre>
<pre><code class="language-ts">function full_name(first_name: string, last_name: string): string {
  return first_name + last_name;
}

console.log(full_name("Georgy", "Adelson")); // Georgy Adelson
console.log(full_name("Georgy", 62)); // ❌ Error

</code></pre>
<p>Jika function tidak mengembalikan nilai, gunakan <code>void</code> sebagai return type</p>
<pre><code class="language-ts">function logMessage(message: string): void {
  console.log(message);
}
</code></pre>
<h2 id="optional-parameter-"><a class="header" href="#optional-parameter-">Optional Parameter (?)</a></h2>
<p>Parameter dalam TypeScript dapat dibuat opsional dengan tanda <code>?</code>, sehingga boleh tidak diisi.</p>
<pre><code class="language-ts">function sayHello(name?: string): string {
    return name ? `Hello, ${name}` : "Hello, stranger!";
}

console.log(sayHello("Georgy")); // Hello, Georgy
console.log(sayHello());        // Hello, stranger!
</code></pre>
<h2 id="deafult-parameter"><a class="header" href="#deafult-parameter">Deafult Parameter</a></h2>
<p>Kita juga dapat memberi nilai default pada parameter.</p>
<pre><code class="language-ts">function greetUser(name: string = "Guest"): string {
  return `Welcome, ${name}!`;
}

console.log(greetUser());       // Welcome, Guest!
console.log(greetUser("Georgy"));  // Welcome, Ani!
</code></pre>
<h2 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h2>
<p>Jika jumlah parameter tidak menentu, kita dapat menggunakan <code>...</code></p>
<pre><code class="language-ts">function sumAll(...numbers: number[]): number {
  return numbers.reduce((acc, curr) =&gt; acc + curr, 0);
}

console.log(sumAll(1, 2, 3, 4, 5)); // 15
</code></pre>
<h2 id="function-expression"><a class="header" href="#function-expression">Function Expression</a></h2>
<p>Selain deklarasi biasa, kita juga bisa menuliskan function sebagai ekspresi</p>
<pre><code class="language-ts">const multiply = function (a: number, b: number): number {
  return a * b;
};
</code></pre>
<h2 id="arrow-function-"><a class="header" href="#arrow-function-">Arrow Function (=&gt;)</a></h2>
<p>Arrow function disediakan untuk meringkas penulisa sebuah function sederhana</p>
<pre><code class="language-ts">const divide = (a: number, b: number): number =&gt; a / b;

console.log(divide(10, 2)); // 5
</code></pre>
<h2 id="overloading-function"><a class="header" href="#overloading-function">Overloading Function</a></h2>
<p>TypeScript mendukung overloading yaitu function dengan bentuk parameter berbeda tapi memiliki nama yang sama</p>
<pre><code class="language-ts">function combine(a: string, b: string): string;
function combine(a: number, b: number): number;
function combine(a: any, b: any): any {
  return a + b;
}

console.log(combine(10, 20));     // 30
console.log(combine("Hello, ", "World")); // Hello, World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-3-object--interface"><a class="header" href="#konsep-typescript-3-object--interface">Konsep TypeScript 3: Object &amp; Interface</a></h1>
<h2 id="objek"><a class="header" href="#objek">Objek</a></h2>
<p>Dalam JavaScript, objek adalah kumpulan properti yang menyimpan berbagai data. Pada TypeScript, kita bisa menentukan tipe properti dalam sebuah objek sehingga lebih jelas struktur datanya.</p>
<p>Contoh sederhana:</p>
<pre><code class="language-ts">let user: { name: string; age: number; isAdmin: boolean } = {
  name: "Max",
  age: 25,
  isAdmin: true
};

console.log(user.name); // Max
</code></pre>
<p>Pastikan ketika memberikan nilai untuk setiap properti sudah sesuai dengan tipe data yang didefinisikan.</p>
<p>Selain pada function, operator optional <code>?</code> juga dapat digunakan pada objek.</p>
<pre><code class="language-ts">let product: { id: number; name: string; description?: string } = {
  id: 101,
  name: "Laptop"
};

console.log(product.description); // undefined
</code></pre>
<h4 id="readonly-property"><a class="header" href="#readonly-property">Readonly Property</a></h4>
<p>Dalam TypeScript, properti dapat dibuat tidak bisa diubah. Caranya adalah menambahkan syntax <code>readonly</code> sebelum nama properti.</p>
<pre><code class="language-ts">let car: { readonly band: string; year: number } = {
  brand: "Dream Theater",
  year: 1985
};

car.year = 1968;     // ✅ Bisa diubah
car.brand = "Led Zeppelin"; // ❌ Error
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Interface adalah cara mendefinisikan bentuk dari sebuah objek dengan lebih rapi dan bisa digunakan berulang kali. Kalau tadi kita mendefinisikan tipe objek langsung di variabel, sekarang kita bisa memisahkan definisinya agar lebih mudah dibaca.</p>
<p>Contoh interface sederhana</p>
<pre><code class="language-ts">interface User {
  name: string;
  age: number;
  isAdmin: boolean;
}

let admin: User = {
  name: "Ani",
  age: 30,
  isAdmin: true
};
</code></pre>
<p>Fitur opsional <code>?</code> dan <code>readonly</code> juga dapat diterapkan pada interface.</p>
<pre><code class="language-ts">interface Product {
  readonly id: number;
  name: string;
  description?: string;
}

let item: Product = {
  id: 123,
  name: "Smartphone"
};

item.name = "Tablet";   // ✅
item.id = 456;          // ❌ Error
</code></pre>
<p>Selain menggunakan properti dengan nilai tunggal, properti pada interface juga bisa mendefinisikan bentuk function.</p>
<pre><code class="language-ts">interface Person {
  name: string;
  greet(): void;
}

let user1: Person = {
  name: "John",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

user1.greet(); // Hello, my name is John
</code></pre>
<p>Interface juga bisa mewarisi (extend) sifat ke interface lainnya.</p>
<pre><code class="language-ts">interface Animal {
  name: string;
  sound(): void;
}

interface Dog extends Animal {
  breed: string;
}

let myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
  sound() {
    console.log("Woof woof!");
  }
};

myDog.sound(); // Woof woof!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-4-union--intersection"><a class="header" href="#konsep-typescript-4-union--intersection">Konsep TypeScript 4: Union &amp; Intersection</a></h1>
<p>Dalam pemrograman nyata, kadang sebuah variabel bisa menampung lebih dari satu tipe data. Misalnya, ID user bisa berupa number atau string.</p>
<h2 id="union-types-"><a class="header" href="#union-types-">Union Types (<code>|</code>)</a></h2>
<p>Union <code>|</code> berarti salah satu dari beberapa tipe.
Contoh sederhana</p>
<pre><code class="language-ts">let userId: number | string;

userId = 101;       // ✅ number
userId = "A102";    // ✅ string
userId = true;      // ❌ Error: Type 'boolean' is not assignable
</code></pre>
<p>Selain digunakan dalam variable, union (<code>|</code>) juga dapat digunakan pada function
contoh union pada function</p>
<pre><code class="language-ts">function printId(id: number | string) {
  console.log("User ID:", id);
}

printId(123);     // ✅
printId("ABC");   // ✅
</code></pre>
<p>Union sangat berguna ketika kita berhadapan dengan data yang fleksibel tapi masih terkontrol. Namun, ketika menggunakan union, kita harus hati-hati. TypeScript memaksa kita untuk memastikan operasi yang dilakukan valid untuk semua tipe dalam union.</p>
<h3 id="narrowing-mempersempit-union"><a class="header" href="#narrowing-mempersempit-union">Narrowing (Mempersempit Union)</a></h3>
<p>Ketika menggunakan union, kita sering perlu memeriksa tipe data sebelum mengaksesnya. Proses ini disebut type narrowing.</p>
<p>Contoh narrowing sederhana:</p>
<pre><code class="language-ts">function formatId(id: number | string) {
  if (typeof id === "string") {
    return id.toUpperCase(); // ✅ aman karena pasti string
  } else {
    return id.toFixed(2);    // ✅ aman karena pasti number
  }
}

console.log(formatId(123));     // "123.00"
console.log(formatId("abc"));   // "ABC"
</code></pre>
<h2 id="intersection-"><a class="header" href="#intersection-">Intersection (<code>&amp;</code>)</a></h2>
<p>Fitur yang memungkinkan kita untuk menggabungkan beberapa tipe data menjadi satu tipe baru yang memiliki semua properti dan anggota dari setiap tipe yang digabungkan. Fitur ini sangat berguna untuk membuat tipe yang kompleks dari tipe-tipe yang lebih sederhana, di mana objek yang menggunakan tipe interseksi ini harus memenuhi semua persyaratan dari setiap tipe yang termasuk di dalamnya.
Contoh sederhana:</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Employee {
  company: string;
}

interface Worker = Person &amp; Employee;

let staff: Worker = {
  name: "Max",
  company: "Microsoft"
};
</code></pre>
<p><code>Worker</code> adalah seseorang yang sekaligus seorang karyawan, sehingga harus punya properti dari <code>Person</code> dan <code>Employee</code></p>
<p>Selain pada interface, kita juga dapat menggunakan intersection pada tipe data dasar.</p>
<pre><code class="language-ts">type A = { x: number };
type B = { y: string };

type AB = A &amp; B;

let obj: AB = { x: 10, y: "hello" }; // ✅ harus punya keduanya
</code></pre>
<pre><code class="language-ts">type C = { id: number };
type D = { id: string };

type CD = C &amp; D; // ❌ Tidak mungkin, karena 'id' tidak bisa number sekaligus string
</code></pre>
<h2 id="menggabungkan-union--intersection"><a class="header" href="#menggabungkan-union--intersection">Menggabungkan Union &amp; Intersection</a></h2>
<p>Terkadang, kita perlu mengombinasikan union dan intersection untuk membentuk tipe yang lebih kompleks. Teknik ini sering digunakan dalam aplikasi nyata, misalnya ketika mendesain model data yang fleksibel.</p>
<pre><code class="language-ts">interface Admin {
  role: "admin";
  accessLevel: number;
}

interface User {
  role: "user";
  email: string;
}

interface Account = (Admin | User) &amp; { id: number };

let acc1: Account = {
  id: 1,
  role: "admin",
  accessLevel: 5
};

let acc2: Account = {
  id: 2,
  role: "user",
  email: "test@mail.com"
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-5-generics"><a class="header" href="#konsep-typescript-5-generics">Konsep TypeScript 5: Generics</a></h1>
<p>Sebelumnya kita sudah membahas Union &amp; Intersection yang memberi fleksibilitas pada tipe. Terkadang terdapat sebuah kondisi yang membuat kita untuk membuat fungsi atau class yang bisa bekerja dengan banyak tipe tanpa kehilangan informasi tipe aslinya. Walaupun TypeScript memiliki operator <code>any</code>, namun hal ini akan membuat kebingungan karena kehilangan identitas. Di sinilah Generics sangat berguna. Generics memungkinkan kita menulis kode yang dapat digunakan kembali untuk berbagai tipe, tapi tetap memberikan jaminan tipe yang kuat.</p>
<h2 id="generics-pada-function"><a class="header" href="#generics-pada-function">Generics pada Function</a></h2>
<p>Dengan generics, kita bisa membuat fungsi yang menerima parameter dengan tipe yang bisa berubah-ubah.</p>
<p>Tanpa generics:</p>
<pre><code class="language-ts">function identity(arg: any): any {
  return arg;
}

let a = identity(5);      // a: any
let b = identity("Hello"); // b: any
</code></pre>
<p>Masalah: hasilnya selalu any, sehingga kita kehilangan informasi tipe.</p>
<p>Dengan generics:</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  return arg;
}

let num = identity&lt;number&gt;(10);   // num: number
let str = identity("Halo");       // str: string (infer otomatis)
</code></pre>
<p>Dengan generics, kita mendefinisikan tipe sebagai parameter <code>&lt;T&gt;</code>. Hasilnya, TypeScript tahu bahwa input dan output punya tipe yang sama.</p>
<h2 id="penamaan-parameter-generics"><a class="header" href="#penamaan-parameter-generics">Penamaan Parameter Generics</a></h2>
<p>Kalau diperhatikan, kenapa kita sering melihat <T>, <K>, <V> di kode TypeScript?
Sebenarnya itu hanyalah nama variabel tipe, sama seperti kita memberi nama variabel biasa.
Namun, ada konvensi umum agar lebih mudah dibaca.</p>
<div class="table-wrapper"><table><thead><tr><th>Nama</th><th>Makna Umum</th><th>Contoh Penggunaan</th></tr></thead><tbody>
<tr><td><code>T</code></td><td>Type (umum)</td><td><code>identity&lt;T&gt;(arg: T): T</code></td></tr>
<tr><td><code>U</code>,<code>S</code></td><td>Type tambahan / second</td><td><code>pair&lt;T, U&gt;(a: T, b: U)</code></td></tr>
<tr><td><code>K</code></td><td>Key dari sebuah object</td><td><code>getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K)</code></td></tr>
<tr><td><code>V</code></td><td>Value dari sebuah object</td><td><code>Record&lt;K, V&gt; (objek dengan key K dan value V)</code></td></tr>
</tbody></table>
</div>
<p>Kita bisa pakai nama lain (<code>&lt;MyType&gt;</code>, <code>&lt;Foo&gt;</code>), tapi <code>&lt;T&gt;</code>, <code>&lt;K&gt;</code>, <code>&lt;V&gt;</code> sudah jadi kebiasaan.</p>
<p>Contoh:</p>
<pre><code class="language-ts">function pair&lt;K, V&gt;(key: K, value: V): [K, V] {
  return [key, value];
}

let result = pair("id", 101); 
// result: [string, number]
</code></pre>
<p><strong>Generics pada function expression/arrow function:</strong></p>
<pre><code class="language-ts">const getFirstElement = &lt;T&gt;(arr: T[]): T =&gt; {
  return arr[0];
};

let numbers = [1, 2, 3];
let first = getFirstElement(numbers); // first: number

let names = ["Ani", "Budi", "Cici"];
let firstName = getFirstElement(names); // firstName: string
</code></pre>
<p><strong>Generics dengan multi parameter:</strong></p>
<pre><code class="language-ts">function merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {
  return { ...obj1, ...obj2 };
}

let person = merge({ name: "Max" }, { age: 25 });
console.log(person); // { name: "Max", age: 25 }
</code></pre>
<p>**Constraint pada Generics</p>
<p>Kadang kita ingin membatasi tipe generics agar hanya tipe tertentu yang bisa digunakan.
Gunakan <code>extends</code>.</p>
<pre><code class="language-ts">function getLength&lt;T extends { length: number }&gt;(arg: T): number {
  return arg.length;
}

console.log(getLength("Hello"));    // ✅ string punya length
console.log(getLength([1, 2, 3]));  // ✅ array punya length
// console.log(getLength(123));     // ❌ number tidak punya length
</code></pre>
<h2 id="interface-dengan-generics"><a class="header" href="#interface-dengan-generics">Interface dengan Generics</a></h2>
<p>Generics juga bisa digunakan dalam interface.</p>
<pre><code class="language-ts">interface Repository&lt;T&gt; {
  data: T[];
  add(item: T): void;
  getAll(): T[];
}

class MemoryRepository&lt;T&gt; implements Repository&lt;T&gt; {
  data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

let userRepo = new MemoryRepository&lt;string&gt;();
userRepo.add("Jordan");
userRepo.add("Ani");
console.log(userRepo.getAll()); // ["Jordan", "Ani"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class--oop-dasar"><a class="header" href="#class--oop-dasar">Class &amp; OOP Dasar</a></h1>
<p>JavaScript sudah mengenalkan konsep class sejak ES6. Di TypeScript, class mendapatkan kekuatan tambahan berupa static typing, access modifier, dan interface/class inheritance. Dengan class, kita bisa membuat blueprint untuk objek, sehingga kode lebih terstruktur dan mudah dikelola.</p>
<h3 id="membuat-class-dasar"><a class="header" href="#membuat-class-dasar">Membuat Class Dasar</a></h3>
<p>Class adalah cetak biru (blueprint) untuk membuat objek.</p>
<pre><code class="language-ts">class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Halo, nama saya ${this.name} dan saya berusia ${this.age} tahun.`);
  }
}

let user = new Person("Ryo", 35);
user.greet();
// Output: Halo, nama saya Ryo dan saya berusia 35 tahun.
</code></pre>
<p>Contoh di atas, kita membuat class Person dengan properti name dan age. Constructor digunakan untuk menginisialisasi properti, dan method greet menampilkan data. Dengan ini, kita bisa membuat banyak objek Person tanpa menulis ulang struktur yang sama.</p>
<h3 id="access-modifier"><a class="header" href="#access-modifier">Access Modifier</a></h3>
<p>TypeScript menambahkan access modifier untuk mengatur visibilitas properti dan method.</p>
<pre><code class="language-ts">class Car {
  public brand: string;       // Bisa diakses dari mana saja
  private engineNumber: string; // Hanya bisa diakses dari dalam class
  protected year: number;     // Bisa diakses oleh class ini &amp; turunannya

  constructor(brand: string, engineNumber: string, year: number) {
    this.brand = brand;
    this.engineNumber = engineNumber;
    this.year = year;
  }

  getInfo() {
    return `${this.brand} (${this.year})`;
  }
}

let car = new Car("Toyota", "EN12345", 2020);
console.log(car.brand);          // ✅ Toyota
// console.log(car.engineNumber); // ❌ Error: private
</code></pre>
<ul>
<li><code>public</code>: default, bisa diakses dari mana saja.</li>
<li><code>private</code>: hanya bisa diakses di dalam class itu sendiri.</li>
<li><code>protected</code>: bisa diakses dari class dan subclass (turunan).</li>
</ul>
<h3 id="getter--setter"><a class="header" href="#getter--setter">Getter &amp; Setter</a></h3>
<p>Kita bisa membuat method khusus untuk mengambil dan mengubah nilai dengan kontrol lebih.</p>
<pre><code class="language-ts">class Account {
  private _balance: number = 0;

  get balance(): number {
    return this._balance;
  }

  set balance(amount: number) {
    if (amount &lt; 0) throw new Error("Balance tidak boleh negatif");
    this._balance = amount;
  }
}

let acc = new Account();
acc.balance = 1000;        // Setter
console.log(acc.balance);  // Getter -&gt; 1000
</code></pre>
<p>Getter &amp; Setter memberi kontrol penuh atas cara data diakses dan dimodifikasi.
Misalnya, kita bisa menolak nilai negatif untuk <code>balance</code>.</p>
<h3 id="inheritance-pewarisan"><a class="header" href="#inheritance-pewarisan">Inheritance (Pewarisan)</a></h3>
<p>Class bisa mewarisi dari class lain dengan <code>extends</code>.</p>
<pre><code class="language-ts">class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move() {
    console.log(`${this.name} bergerak.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} menggonggong.`);
  }
}

let dog = new Dog("Buddy");
dog.move();  // Buddy bergerak.
dog.bark();  // Buddy menggonggong.
</code></pre>
<p>Dengan inheritance, kita bisa membuat class baru yang mewarisi properti dan method dari class lain.
Ini memungkinkan reuse kode dan membuat struktur hierarki yang lebih natural.</p>
<h3 id="method-overriding"><a class="header" href="#method-overriding">Method Overriding</a></h3>
<p>Subclass bisa menimpa (override) method dari superclass.</p>
<pre><code class="language-ts">class Bird extends Animal {
  move() {
    console.log(`${this.name} terbang.`);
  }
}

let bird = new Bird("Garuda");
bird.move(); // Garuda terbang.
</code></pre>
<h3 id="abstract-class"><a class="header" href="#abstract-class">Abstract Class</a></h3>
<p>Abstract class tidak bisa dibuat instance langsung. Biasanya digunakan sebagai blueprint untuk class lain. Abstract class seperti kontrak: class turunan wajib mengimplementasikan method yang abstrak.</p>
<pre><code class="language-ts">abstract class Shape {
  abstract area(): number;
}

class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super();
  }

  area(): number {
    return this.width * this.height;
  }
}

let rect = new Rectangle(10, 5);
console.log(rect.area()); // 50
</code></pre>
<h3 id="static-member"><a class="header" href="#static-member">Static Member</a></h3>
<p>Kita bisa membuat properti dan method yang dimiliki oleh class itu sendiri, bukan oleh objeknya.</p>
<pre><code class="language-ts">class MathUtil {
  static PI: number = 3.14159;

  static circleArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtil.PI);               // 3.14159
console.log(MathUtil.circleArea(10));   // 314.159
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module--importexport"><a class="header" href="#module--importexport">Module &amp; Import/Export</a></h1>
<p>Di JavaScript (sejak ES6) dan TypeScript, modul digunakan untuk membagi kode ke dalam file-file terpisah sehingga kode lebih mudah dibaca &amp; dikelola dan bisa dipakai ulang di file lain.</p>
<h3 id="export"><a class="header" href="#export">Export</a></h3>
<p>Sebuah file TypeScript dianggap sebagai modul ketika memiliki <code>export</code> atau <code>import</code>.</p>
<p>Contoh:</p>
<p><code>mathUtils.ts</code></p>
<pre><code class="language-ts">// export variabel
export const PI = 3.14159;

// export fungsi
export function add(a: number, b: number): number {
  return a + b;
}

// export class
export class Calculator {
  multiply(x: number, y: number): number {
    return x * y;
  }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Kita bisa mengimpor apa yang diekspor dari file lain.</p>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { PI, add, Calculator } from "./mathUtils";

console.log(PI); // 3.14159
console.log(add(10, 5)); // 15

const calc = new Calculator();
console.log(calc.multiply(4, 3)); // 12
</code></pre>
<p>Dengan kurung kurawal <code>{}</code> kita bisa mengambil item-item spesifik dari modul. TypeScript memastikan hanya yang diekspor yang bisa diimpor.</p>
<h3 id="export-default"><a class="header" href="#export-default">Export Default</a></h3>
<p>Kadang sebuah modul hanya punya satu hal utama. Untuk kasus ini kita bisa pakai default export.
Contoh:</p>
<p>logger.ts</p>
<pre><code class="language-ts">export default function log(message: string): void {
  console.log("[LOG]:", message);
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import log from "./logger";

log("Halo dari default export!");
</code></pre>
<h3 id="alias-import--export"><a class="header" href="#alias-import--export">Alias Import &amp; Export</a></h3>
<p>Kita bisa mengganti nama saat export atau import menggunakan <code>as</code>. Alias sering dipakai untuk menghindari konflik nama atau membuat kode lebih singkat.</p>
<p><code>shapes.ts</code></p>
<pre><code class="language-ts">export function areaRectangle(w: number, h: number): number {
  return w * h;
}

export function areaCircle(r: number): number {
  return Math.PI * r * r;
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { areaRectangle as rect, areaCircle as circle } from "./shapes";

console.log(rect(10, 5)); // 50
console.log(circle(7));   // 153.938...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment"><a class="header" href="#setup-environment">Setup Environment</a></h1>
<p>Sebelum mulai membuat aplikasi React Native, kita perlu menyiapkan <strong>environment</strong> terlebih dahulu.<br />
Ada dua cara utama untuk menjalankan React Native:</p>
<ol>
<li><a href="./react-native-cli.html"><strong>React Native CLI</strong></a> → lebih fleksibel, cocok untuk aplikasi production dengan native module.</li>
<li><a href="./expo-go.html"><strong>Expo Go</strong></a> → lebih mudah, cocok untuk belajar dan prototyping.</li>
</ol>
<h2 id="1-prasyarat"><a class="header" href="#1-prasyarat">1. Prasyarat</a></h2>
<h3 id="nodejs--package-manager"><a class="header" href="#nodejs--package-manager">Node.js &amp; Package Manager</a></h3>
<p>React Native membutuhkan <strong>Node.js</strong>. Disarankan menggunakan versi <strong>LTS</strong>.<br />
Unduh di <a href="https://nodejs.org/">nodejs.org</a>.</p>
<p>Cek instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<p>Opsional: gunakan Yarn atau pnpm sebagai pengganti npm.</p>
<pre><code class="language-bash">npm install -g yarn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli"><a class="header" href="#react-native-cli">React Native CLI</a></h1>
<p>Untuk menggunakan <strong>React Native CLI</strong>, kita perlu menyiapkan lingkungan pengembangan (development environment).</p>
<p>Karena React Native berjalan di Android dan iOS, maka langkah setup dibedakan berdasarkan sistem operasi target:</p>
<ul>
<li><a href="./react-native-cli-android.html">Setup Android</a></li>
<li><a href="./react-native-cli-ios.html">Setup iOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--android"><a class="header" href="#setup-environment-react-native-cli--android">Setup Environment React Native CLI – Android</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<ol>
<li>Install Node.js dan Java
<ul>
<li>Unduh <strong>Node.js</strong> (versi LTS) dari <a href="https://nodejs.org/">nodejs.org</a>.</li>
<li>Install <strong>Java JDK</strong> (disarankan versi 11 atau lebih baru).</li>
</ul>
</li>
</ol>
<p>Cek instalasi java:</p>
<pre><code class="language-bash">node -v
java -version
</code></pre>
<ol start="2">
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Konfigurasi ANDROID_HOME environment variable</p>
<ul>
<li>Buka <strong>Window Control Panel</strong></li>
<li>Klik <strong>User Accounts</strong>, lalu pilih <strong>Change my environment variables</strong></li>
<li>Klik <strong>New…</strong> untuk membuat user variable baru. Masukkan Variable name <strong>ANDROID_HOME</strong> dan Variable value <strong>Lokasi SDK Android</strong></li>
</ul>
<p><img src="./assets/env%20variable%20windows.png" alt="Ilustrasi menambahkan environment variable" title="Ilustrasi menambahkan environment variable" /></p>
<p>Untuk menemukan lokasi SDK dapat dilakukan melalui <strong>Android Studio</strong>. Pilih <strong>Settings</strong> → <strong>Languages &amp; Frameworks</strong> → <strong>Android SDK</strong></p>
</li>
<li>
<p>Menjalankan Emulator Android</p>
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>
<p>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>
<p>Install JDK menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install --cask zulu@17
brew info --cask zulu@17
open /opt/homebrew/Caskroom/zulu@17/&lt;version number&gt;
</code></pre>
<p>Setelah Finder terbuka, Klik double untuk menginstal Azul Zulu JDK 17.pkg.</p>
<p>Tambahkan atau update JAVA_HOME environment variable di ~/.zshrc (or in ~/.bash_profile).</p>
<p>JDK umunya berada di /Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home. Lalu jalankan command berikut pada terminal</p>
<pre><code class="language-bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
</code></pre>
</li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
</li>
</ol>
<ul>
<li>
<p>Unduh <a href="developer.android.com/studio">Android Studio</a></p>
</li>
<li>
<p>Saat instalasi, pastikan mencentang:</p>
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>
<p>Setelah instalasi, buka Android Studio → SDK Manager → install:</p>
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install <a href="https://nodejs.org/en/download"><strong>Node</strong></a></li>
<li>Install <a href="https://openjdk.org/"><strong>JDK</strong></a></li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Android/Sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--ios"><a class="header" href="#setup-environment-react-native-cli--ios">Setup Environment React Native CLI – iOS</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>Install <a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12"><strong>Xcode</strong></a></li>
<li>Install Xcode Command Line Tools
Buka Xcode lalu pilih <strong>Settings… (atau Preferences…)</strong> pada menu Xcode.
Pilih panel <strong>Locations</strong> lalu pilih versi Command line tools terbaru
<img src="./assets/install%20command%20line%20tools.png" alt="Ilustrasi install command line tool Xcode" title="Ilustrasi install command line tool Xcode" /></li>
</ul>
</li>
<li>
<p>Install iOS simulator</p>
<ul>
<li>Buka Xcode → Settings… → tab Platforms.</li>
<li>Pilih “+” dan pilih opsi iOS…</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native--expo"><a class="header" href="#setup-environment-react-native--expo">Setup Environment React Native – Expo</a></h1>
<p>Expo adalah framework dan platform untuk React Native yang memudahkan pengembangan aplikasi mobile tanpa perlu konfigurasi native (Android Studio / Xcode).<br />
Dengan Expo, kita bisa langsung membuat aplikasi, menjalankan di perangkat fisik dengan <strong>Expo Go</strong>, atau di emulator.</p>
<hr />
<h2 id="1-install-nodejs"><a class="header" href="#1-install-nodejs">1. Install Node.js</a></h2>
<p>Unduh <strong>Node.js LTS</strong> dari <a href="https://nodejs.org/">nodejs.org</a>.<br />
Verifikasi instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<h2 id="2-install-expo-go"><a class="header" href="#2-install-expo-go">2. Install Expo Go</a></h2>
<p>Unduh aplikasi Expo Go di <a href="https://apps.apple.com/us/app/expo-go/id982107779">App Store</a> atau <a href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www">Google Play</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli-1"><a class="header" href="#react-native-cli-1">React Native CLI</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan React Native CLI.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx @react-native-community/cli@latest init MyFirstApp
</code></pre>
<p>Jika sebelumnya sudah pernah menginstal react-native-cli secara global, jalankan command terminal berikut unutk mencegah kesalahan</p>
<pre><code class="language-bash">npm uninstall -g react-native-cli @react-native-community/cli
</code></pre>
</li>
<li>
<p>Start Metro
<a href="https://metrobundler.dev/">Metro</a> merupakan tool build berbasis JavaScript. Jalankan terminal command berikut untuk menjalankan Metro</p>
<pre><code class="language-bash">npm start
</code></pre>
</li>
<li>
<p>Jalankan Aplikasi
Buka terminal baru lalu jalankan terminal command berikut untuk menjalankan aplikasi React Native</p>
<pre><code class="language-bash">npm run android
</code></pre>
<p>atau</p>
<pre><code class="language-bash">npm run ios // hanya pada macOS
</code></pre>
<p>Aplikasi akan berjalan di emulator</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expo"><a class="header" href="#expo">Expo</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan Framework Expo.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx create-expo-app --template blank-typescript
</code></pre>
<p><code>blank-typescript</code> merupakan salah satu opsi <a href="https://docs.expo.dev/more/create-expo/#--template">template</a> yang tersedia. Opsi ini akan memberikan template kosong (tanpa navigasi dengan basisnya adalah typescript)</p>
</li>
<li>
<p>Menjalankan Aplikasi
Jalankan terminal command berikut pada directory project.</p>
<pre><code class="language-bash">npx expo start
</code></pre>
<p>Buka aplikasi Expo Go melalui perangkat mobile lalu scan qrcode yang muncul pada terminal.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struktur-proyek-react-native"><a class="header" href="#struktur-proyek-react-native">Struktur Proyek React Native</a></h1>
<p>Setelah membuat project baru, struktur folder akan sedikit berbeda tergantung apakah kita menggunakan React Native CLI atau Expo. Dengan memahami struktur proyek, kita bisa tahu mana bagian yang sering kita edit dan mana yang biasanya tidak perlu disentuh.</p>
<ol>
<li>
<p>Struktur Proyek (React Native CLI)</p>
<p>Contoh hasil dari <code>npx @react-native-community/cli@latest init MyFirstApp</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── android/            # kode native untuk Android (Java/Kotlin)
├── ios/                # kode native untuk iOS (Objective-C/Swift)
├── node_modules/       # dependency project (otomatis dibuat oleh npm/yarn)
├── App.js              # file utama aplikasi (entry point React)
├── index.js            # entry point aplikasi ke native (registrasi root component)
├── package.json        # daftar dependency &amp; script project
└── metro.config.js     # konfigurasi Metro bundler
</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (tempat kita menulis kode React Native).</li>
<li><code>index.js</code>: menghubungkan komponen React Native (<code>App</code>) ke aplikasi native (Android/iOS).</li>
<li><code>android/</code>: kode native untuk Android (bisa edit langsung kalau perlu modul custom).</li>
<li><code>ios/</code>: kode native untuk iOS.</li>
<li><code>package.json</code>: daftar library &amp; script seperti <code>npm start</code>, <code>npm run android</code>.</li>
<li><code>metro.config.js</code>: konfigurasi Metro bundler.</li>
</ul>
</li>
<li>
<p>Struktur Proyek (Expo)</p>
<p>Contoh hasil dari <code>npx create-expo-app@latest</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── node_modules/       # dependency project
├── App.js              # file utama aplikasi
├── package.json        # daftar dependency &amp; script project
└── app.json            # konfigurasi Expo (nama app, icon, splash screen, dsb.)

</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (entry point React).</li>
<li><code>app.json</code>: konfigurasi Expo (nama app, ikon, orientasi layar, dll).</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komponen-react-native"><a class="header" href="#komponen-react-native">Komponen React Native</a></h1>
<p>Ketika kita membuat sebuah aplikasi, sebenarnya kita sedang menyusun potongan-potongan kecil yang bersama-sama membentuk satu kesatuan tampilan. Potongan kecil ini dalam React Native disebut komponen. Bisa dibilang, komponen adalah “building blocks” dari aplikasi mobile.</p>
<p>Hal menarik lainnya, React Native tidak hanya menyediakan komponen bawaan, tapi kita juga dapat membuat komponen buatan sendiri (custom component). Ini membuat kode kita lebih terstruktur, lebih mudah digunakan ulang, dan tentu saja lebih rapi.</p>
<p>Dalam <strong>React Native</strong>, <code>App.tsx</code> merupakan file utama yang pertama kali dijalankan ketika aplikasi dibuka. Kalau di web, mirip seperti <code>index.html</code> + <code>index.js</code>.</p>
<h3 id="struktur-dasar-apptsx-react-native-cli"><a class="header" href="#struktur-dasar-apptsx-react-native-cli">Struktur dasar <code>App.tsx</code> (React Native CLI)</a></h3>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={styles.container}&gt;
      &lt;NewAppScreen
        templateFileName="App.tsx"
        safeAreaInsets={safeAreaInsets}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default App;
</code></pre>
<p>Template default React Native CLI memang terlihat cukup kompleks bagi yang pertama kali belajar. Silahkan ubah kode di atas menjadi:</p>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={[styles.container,{ paddingTop: safeAreaInsets.top, paddingBottom: safeAreaInsets.bottom }]}&gt;
      &lt;View style={styles.center}&gt;
        &lt;Text style={styles.title}&gt;Hello React Native 🚀&lt;/Text&gt;
        &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya dengan CLI&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
  },
  center: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#666',
    marginTop: 8,
  },
});

export default App;
</code></pre>
<h3 id="struktur-dasar-apptsx-expo"><a class="header" href="#struktur-dasar-apptsx-expo">Struktur dasar <code>App.tsx</code> (Expo)</a></h3>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Open up App.tsx to start working on your app!&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
</code></pre>
<p>Coba ubah bagian <code>&lt;Text&gt;</code> menjadi berikut:</p>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Hello React Native dengan Expo 🚀&lt;/Text&gt;
      &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#555',
    marginTop: 8,
  },
});
</code></pre>
<p>Amati perbedaan sebelum dan sesudah dimodifikasi.</p>
<p>React Native menyediakan sekumpulan komponen bawaan (built-in components) yang digunakan untuk membangun UI aplikasi. Komponen ini mirip dengan elemen HTML di web, tetapi disesuaikan dengan dunia mobile.</p>
<p>Selain komponen bawaan dari React Native, kita juga dapat menggunakan third-party yang sudah terkenal seperti <a href="https://reactnativepaper.com/">React Native Paper</a>, <a href="https://gluestack.io/">GlueStack</a>, <a href="https://reactnativeelements.com/">React Native Elements</a>, <a href="https://akveo.github.io/react-native-ui-kitten/">UI Kitten</a>, dan <a href="https://tamagui.dev/">Tamagui</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>Komponen ini umumnya digunakan sebagai container untuk menampung komponen lain (mirip dengan <code>&lt;div&gt;</code> di HTML). View memiliki sifat fleksibel dan bisa digunakan untuk berbagai kebutuhan seperti layout, styling, hingga wrapper komponen.</p>
<h3 id="view-sebagai-container-pusat"><a class="header" href="#view-sebagai-container-pusat">View sebagai container pusat</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';


&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;Text&gt;Ini berada di dalam View&lt;/Text&gt;
&lt;/View&gt;

</code></pre>
<h3 id="view-dengan-background"><a class="header" href="#view-dengan-background">View dengan Background</a></h3>
<pre><code class="language-ts">import { View } from 'react-native';

&lt;View style={{ flex: 1, backgroundColor: '#87cefa' }} /&gt;
</code></pre>
<h3 id="view-untuk-layout-vertikal"><a class="header" href="#view-untuk-layout-vertikal">View untuk Layout Vertikal</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, padding: 20 }}&gt;
  &lt;Text style={{ marginBottom: 10 }}&gt;Atas&lt;/Text&gt;
  &lt;Text&gt;Tengah&lt;/Text&gt;
  &lt;Text&gt;Bawah&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-untuk-layout-horizontal-row"><a class="header" href="#view-untuk-layout-horizontal-row">View untuk Layout Horizontal (Row)</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View
  style={{
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 50,
  }}
&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-dengan-nested-view"><a class="header" href="#view-dengan-nested-view">View dengan Nested View</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, padding: 20 }}&gt;
  &lt;Text style={{ marginBottom: 10 }}&gt;Header&lt;/Text&gt;

  &lt;View style={{ flex: 1, backgroundColor: '#f0f0f0', padding: 10 }}&gt;
    &lt;Text&gt;Konten utama di dalam nested View&lt;/Text&gt;
  &lt;/View&gt;

  &lt;Text style={{ marginTop: 10 }}&gt;Footer&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-sebagai-card"><a class="header" href="#view-sebagai-card">View Sebagai Card</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;View
    style={{
      width: 200,
      padding: 20,
      borderRadius: 10,
      backgroundColor: '#fff',
      elevation: 3, // Android shadow
      shadowColor: '#000', // iOS shadow
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    }}
  &gt;
    &lt;Text style={{ fontSize: 18, fontWeight: 'bold' }}&gt;Card Title&lt;/Text&gt;
    &lt;Text&gt;Ini isi card dengan styling View&lt;/Text&gt;
  &lt;/View&gt;
&lt;/View&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p><code>Text</code> digunakan untuk menampilkan tulisan di layar. Hampir semua teks di aplikasi React Native harus dibungkus dengan komponen ini.</p>
<h3 id="text-sederhana"><a class="header" href="#text-sederhana">Text Sederhana</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;Text&gt;Hello React Native!&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="text-dengan-styling"><a class="header" href="#text-dengan-styling">Text dengan Styling</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text style={{ fontSize: 24, fontWeight: 'bold', color: 'blue' }}&gt;
  Teks dengan styling
&lt;/Text&gt;
</code></pre>
<h3 id="multiline-text"><a class="header" href="#multiline-text">Multiline Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text&gt;
  Baris pertama{"\n"}
  Baris kedua{"\n"}
  Baris ketiga
&lt;/Text&gt;
</code></pre>
<h3 id="nested-text"><a class="header" href="#nested-text">Nested Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text&gt;
  Ini &lt;Text style={{ fontWeight: 'bold' }}&gt;teks tebal&lt;/Text&gt; di dalam kalimat.
&lt;/Text&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>Komponen <strong><code>Image</code></strong> digunakan untuk menampilkan gambar di aplikasi React Native.<br />
Gambar dapat berasal dari <strong>lokal</strong> (disimpan di dalam project) maupun dari <strong>URL</strong>.</p>
<hr />
<h2 id="1-menampilkan-image-dari-lokal"><a class="header" href="#1-menampilkan-image-dari-lokal">1. Menampilkan Image dari Lokal</a></h2>
<p>Simpan file gambar, misalnya <code>logo.png</code>, di dalam folder <code>assets/</code>.</p>
<pre><code class="language-ts">import { Image, View } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Image
    source={require('./assets/logo.png')}
    style={{ width: 100, height: 100 }}
    /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="menampilkan-image-dari-url"><a class="header" href="#menampilkan-image-dari-url">Menampilkan Image dari URL</a></h3>
<pre><code class="language-ts">import { Image, View } from 'react-native';

&lt;Image
    source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
    style={{ width: 100, height: 100 }}
/&gt;
</code></pre>
<h3 id="mengatur-ukuran-dan-styling"><a class="header" href="#mengatur-ukuran-dan-styling">Mengatur Ukuran dan Styling</a></h3>
<pre><code class="language-ts">&lt;Image
  source={require('./assets/logo.png')}
  style={{
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 2,
    borderColor: 'blue',
  }}
/&gt;
</code></pre>
<h3 id="resizemode"><a class="header" href="#resizemode">ResizeMode</a></h3>
<p><code>Image</code> memiliki properti resizeMode untuk mengatur cara gambar ditampilkan:</p>
<ul>
<li><code>cover</code> (default) → gambar memenuhi container dengan cropping jika perlu.</li>
<li><code>contain</code> → gambar menyesuaikan agar seluruh gambar terlihat.</li>
<li><code>stretch</code> → gambar diregangkan agar sesuai dengan ukuran container.</li>
<li><code>repeat</code> → gambar diulang-ulang.</li>
<li><code>center</code> → gambar ditampilkan sesuai ukuran asli di tengah.</li>
</ul>
<pre><code class="language-ts">&lt;Image
  source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
  style={{ width: 200, height: 100 }}
  resizeMode="contain"
/&gt;
</code></pre>
<h3 id="background-image-dengan-imagebackground"><a class="header" href="#background-image-dengan-imagebackground">Background Image dengan <code>ImageBackground</code></a></h3>
<pre><code class="language-ts">import { ImageBackground, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ImageBackground
      source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
      style={styles.background}
    &gt;
      &lt;Text style={styles.text}&gt;Teks di atas gambar&lt;/Text&gt;
    &lt;/ImageBackground&gt;
  );
}

const styles = StyleSheet.create({
  background: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textinput"><a class="header" href="#textinput">TextInput</a></h1>
<p>Komponen <strong><code>TextInput</code></strong> digunakan untuk menerima input teks dari pengguna, mirip dengan <code>&lt;input type="text"&gt;</code> di HTML.<br />
<code>TextInput</code> adalah bagian penting dalam membangun form, pencarian, login, dan interaksi berbasis teks lainnya.</p>
<hr />
<h3 id="textinput-dasar"><a class="header" href="#textinput-dasar">TextInput Dasar</a></h3>
<pre><code class="language-ts">import { TextInput, View, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik sesuatu..."
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    width: 200,
    borderRadius: 5,
  },
});
</code></pre>
<h3 id="mengatur-keyboard"><a class="header" href="#mengatur-keyboard">Mengatur Keyboard</a></h3>
<p><code>TextInput</code> bisa menyesuaikan jenis keyboard dengan properti <code>keyboardType</code>.</p>
<p>Beberapa nilai yang sering digunakan:</p>
<ul>
<li><code>default</code> → keyboard standar.</li>
<li><code>numeric</code> → angka.</li>
<li><code>email-address</code> → untuk email.</li>
<li><code>phone-pad</code> → untuk nomor telepon.</li>
</ul>
<pre><code class="language-ts">&lt;TextInput
  style={styles.input}
  placeholder="Masukkan email"
  keyboardType="email-address"
/&gt;
</code></pre>
<h3 id="textinput-dengan-password-secure-text-entry"><a class="header" href="#textinput-dengan-password-secure-text-entry">TextInput dengan Password (Secure Text Entry)</a></h3>
<pre><code class="language-ts">&lt;TextInput
  style={styles.input}
  placeholder="Masukkan password"
  secureTextEntry={true}
/&gt;
</code></pre>
<h3 id="multiline-input"><a class="header" href="#multiline-input">Multiline Input</a></h3>
<pre><code class="language-ts">&lt;TextInput
  style={[styles.input, { height: 100 }]}
  placeholder="Tulis komentar..."
  multiline
  numberOfLines={4}
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<p>Komponen <strong><code>Button</code></strong> digunakan untuk menangani aksi sederhana dari pengguna, misalnya mengirim form atau menavigasi ke halaman lain.<br />
<code>Button</code> bawaan React Native cukup mudah digunakan, tapi terbatas dalam hal kustomisasi tampilan.</p>
<hr />
<h3 id="button-dasar"><a class="header" href="#button-dasar">Button Dasar</a></h3>
<pre><code class="language-ts">import { Button, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Button
        title="Klik Saya"
        onPress={() =&gt; alert('Tombol ditekan!')}
      /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<ul>
<li><code>title</code> → teks yang ditampilkan pada tombol.</li>
<li><code>onPress</code> → fungsi yang dijalankan ketika tombol ditekan.</li>
</ul>
<h3 id="mengubah-warna-button"><a class="header" href="#mengubah-warna-button">Mengubah Warna Button</a></h3>
<pre><code class="language-ts">&lt;Button
  title="Tombol Hijau"
  onPress={() =&gt; console.log('Hijau')}
  color="green"
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="touchable"><a class="header" href="#touchable">Touchable</a></h1>
<p>Komponen <code>Touchable</code> di React Native digunakan untuk membuat area yang bisa ditekan (pressable area).
Berbeda dengan <a href="component-button.html"><code>Button</code></a> bawaan yang terbatas dalam kustomisasi, <code>Touchable</code> memberikan fleksibilitas penuh untuk membuat tombol dengan gaya dan isi sesuai kebutuhan (misalnya teks, ikon, atau gambar).</p>
<p>React Native menyediakan beberapa varian Touchable seperti:</p>
<ul>
<li><code>TouchableOpacity</code></li>
<li><code>TouchableHighlight</code></li>
<li><code>TouchableWithoutFeedback</code></li>
</ul>
<h2 id="touchableopacity"><a class="header" href="#touchableopacity">TouchableOpacity</a></h2>
<pre><code class="language-javascript">import { Text, View, TouchableOpacity, Alert } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;TouchableOpacity
        onPress={() =&gt; Alert.alert('Tombol ditekan!')}
        style={{
          backgroundColor: '#4CAF50',
          paddingVertical: 12,
          paddingHorizontal: 20,
          borderRadius: 8,
        }}
      &gt;
        &lt;Text style={{ color: 'white', fontSize: 16 }}&gt;Klik Saya&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<ul>
<li><code>onPress</code>: fungsi yang dijalankan ketika tombol ditekan.</li>
<li><code>style</code> → bisa bebas dikustomisasi, tidak seperti Button.</li>
<li><code>Text</code> atau komponen lain bisa dimasukkan sebagai isi tombol.</li>
</ul>
<h2 id="touchablehighlight"><a class="header" href="#touchablehighlight">TouchableHighlight</a></h2>
<p>Memberikan efek highlight saat tombol ditekan.</p>
<pre><code class="language-javascript">import { Text, View, TouchableHighlight } from 'react-native';
export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;TouchableHighlight onPress={() =&gt; console.log('Highlight!')}
        underlayColor="#DDDDDD"
        style={{
            backgroundColor: '#2196F3',
            padding: 12,
            borderRadius: 8,
        }}
      &gt;
        &lt;Text style={{ color: 'white', textAlign: 'center' }}&gt;Tombol Highlight&lt;/Text&gt;
      &lt;/TouchableHighlight&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h2 id="touchablewithoutfeedback"><a class="header" href="#touchablewithoutfeedback">TouchableWithoutFeedback</a></h2>
<p>Tidak memberikan efek visual, cocok jika ingin mendapatkan kontrol penuh terhadap tampilan.</p>
<pre><code class="language-javascript">import { Text, View, TouchableWithoutFeedback } from 'react-native';
export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
        &lt;TouchableWithoutFeedback onPress={() =&gt; console.log('Tanpa efek')}&gt;
            &lt;View style={{ backgroundColor: '#FF5722', padding: 12, borderRadius: 8 }}&gt;
                &lt;Text style={{ color: 'white' }}&gt;Tanpa Efek&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt; 
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrollview"><a class="header" href="#scrollview">ScrollView</a></h1>
<p>Komponen <strong><code>ScrollView</code></strong> digunakan untuk membuat area yang dapat digulir (scroll), baik secara <strong>vertikal</strong> maupun <strong>horizontal</strong>.<br />
Berbeda dengan <code>FlatList</code> (yang lebih efisien untuk data besar), <code>ScrollView</code> cocok digunakan ketika jumlah elemen <strong>relatif sedikit</strong>.</p>
<hr />
<h3 id="scrollview-vertikal-dasar"><a class="header" href="#scrollview-vertikal-dasar">ScrollView Vertikal Dasar</a></h3>
<pre><code class="language-ts">import { ScrollView, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ScrollView style={styles.container}&gt;
      {Array.from({ length: 20 }, (_, i) =&gt; (
        &lt;Text key={i} style={styles.item}&gt;
          Item {i + 1}
        &lt;/Text&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginTop: 40,
    padding: 10,
  },
  item: {
    fontSize: 18,
    marginVertical: 10,
  },
});
</code></pre>
<h3 id="scrollview-horizontal"><a class="header" href="#scrollview-horizontal">ScrollView Horizontal</a></h3>
<pre><code class="language-ts">&lt;ScrollView horizontal style={{ marginTop: 40 }}&gt;
  {Array.from({ length: 10 }, (_, i) =&gt; (
    &lt;Text key={i} style={{ fontSize: 18, marginHorizontal: 20 }}&gt;
      Item {i + 1}
    &lt;/Text&gt;
  ))}
&lt;/ScrollView&gt;
</code></pre>
<h3 id="menambahkan-konten-yang-kompleks"><a class="header" href="#menambahkan-konten-yang-kompleks">Menambahkan Konten yang Kompleks</a></h3>
<pre><code class="language-ts">import { ScrollView, View, Text, Image, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ScrollView contentContainerStyle={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Galeri Gambar&lt;/Text&gt;
      {Array.from({ length: 5 }, (_, i) =&gt; (
        &lt;Image
          key={i}
          source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
          style={styles.image}
        /&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  image: {
    width: 100,
    height: 100,
    marginVertical: 10,
  },
});
</code></pre>
<h3 id="properti-penting-scrollview"><a class="header" href="#properti-penting-scrollview">Properti Penting ScrollView</a></h3>
<ul>
<li><code>horizontal</code> → menggulir secara horizontal.</li>
<li><code>contentContainerStyle</code> → styling untuk isi konten.</li>
<li><code>showsVerticalScrollIndicator</code> &amp; <code>showsHorizontalScrollIndicator</code> → menampilkan/menyembunyikan scrollbar.</li>
<li><code>refreshControl</code> → menambahkan fitur pull-to-refresh.</li>
</ul>
<pre><code class="language-ts">&lt;ScrollView showsVerticalScrollIndicator={false}&gt;
  {/* konten */}
&lt;/ScrollView&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatlist"><a class="header" href="#flatlist">FlatList</a></h1>
<p>Komponen <strong><code>FlatList</code></strong> digunakan untuk menampilkan daftar data dalam jumlah banyak secara <strong>efisien</strong>.<br />
Berbeda dengan <code>ScrollView</code> (yang merender semua item sekaligus), <code>FlatList</code> hanya merender item yang terlihat di layar, sehingga lebih hemat memori dan performa.</p>
<hr />
<h3 id="flatlist-dasar"><a class="header" href="#flatlist-dasar">FlatList Dasar</a></h3>
<pre><code class="language-ts">import { FlatList, Text, StyleSheet, View } from 'react-native';

const DATA = Array.from({ length: 20 }, (_, i) =&gt; ({
  id: i.toString(),
  title: `Item ${i + 1}`,
}));

export default function App() {
  return (
    &lt;FlatList
      data={DATA}
      keyExtractor={(item) =&gt; item.id}
      renderItem={({ item }) =&gt; (
        &lt;View style={styles.item}&gt;
          &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  item: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  text: {
    fontSize: 18,
  },
});
</code></pre>
<h3 id="flatlist-horizontal"><a class="header" href="#flatlist-horizontal">FlatList Horizontal</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  horizontal
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={{ margin: 10, padding: 20, backgroundColor: '#eee' }}&gt;
      &lt;Text&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
/&gt;
</code></pre>
<h3 id="menambahkan-header--footer"><a class="header" href="#menambahkan-header--footer">Menambahkan Header &amp; Footer</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
  ListHeaderComponent={&lt;Text style={styles.header}&gt;Daftar Item&lt;/Text&gt;}
  ListFooterComponent={&lt;Text style={styles.footer}&gt;Akhir List&lt;/Text&gt;}
/&gt;
</code></pre>
<h3 id="menambahkan-separator"><a class="header" href="#menambahkan-separator">Menambahkan Separator</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
  ItemSeparatorComponent={() =&gt; &lt;View style={{ height: 1, backgroundColor: '#ccc' }} /&gt;}
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress"><a class="header" href="#progress">Progress</a></h1>
<p>Komponen Progress Bar digunakan untuk menampilkan kemajuan proses (misalnya loading data, upload file, atau download). React Native tidak menyediakan progress bar bawaan di semua platform, tapi kita dapat menggunakan <code>ProgressBar</code> dari <code>react-native-progress</code>.</p>
<h2 id="instalasi-1"><a class="header" href="#instalasi-1">Instalasi</a></h2>
<p>Untuk menggunakan Progress, kita perlu meng-install library third party</p>
<pre><code class="language-bash">npm install react-native-progress
</code></pre>
<h2 id="contoh"><a class="header" href="#contoh">Contoh</a></h2>
<pre><code class="language-javascript">import { StatusBar } from 'expo-status-bar';
import { useEffect, useState } from 'react';
import { StyleSheet, Text, View } from 'react-native';
import * as Progress from 'react-native-progress';

export default function App() {
  const [progress, setProgress] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setProgress((prev) =&gt; (prev &gt;= 1 ? 0 : prev + Math.random() * (0.5 - 0.01) + 0.01))
    }, 1000);
    return () =&gt; clearInterval(interval);
  }, []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Progress.Bar progress={progress} width={200} /&gt; // bar progress
      &lt;Progress.Circle progress={progress} size={80} showsText={true} /&gt;  // circle progress
      &lt;Progress.Bar indeterminate={true} width={200} /&gt;  // intermediate progress (durasi tidak diketahui)
      &lt;Progress.Bar
        progress={progress}
        width={250}
        color="green"
        unfilledColor="#ddd"
        borderWidth={2}
        borderColor="black"
      /&gt;  // custom style progress
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 15
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modal-dialog"><a class="header" href="#modal-dialog">Modal Dialog</a></h1>
<p>Komponen <code>Modal</code> di React Native digunakan untuk menampilkan konten sementara yang muncul di atas layar utama. Biasanya dipakai untuk popup, konfirmasi, form input, atau pesan penting.</p>
<h2 id="modal-dasar"><a class="header" href="#modal-dasar">Modal Dasar</a></h2>
<pre><code class="language-javascript">import React, { useState } from 'react';
import { Modal, View, Text, Button } from 'react-native';

export default function App() {
  const [visible, setVisible] = useState(false);

  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Button title="Tampilkan Modal" onPress={() =&gt; setVisible(true)} /&gt;

      &lt;Modal
        visible={visible}
        transparent={true}
        animationType="slide"
        onRequestClose={() =&gt; setVisible(false)} // untuk Android back button
      &gt;
        &lt;View style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: 'rgba(0,0,0,0.5)'
        }}&gt;
          &lt;View style={{
            width: 300,
            padding: 20,
            backgroundColor: 'white',
            borderRadius: 10
          }}&gt;
            &lt;Text style={{ fontSize: 18, marginBottom: 20 }}&gt;Halo, ini modal!&lt;/Text&gt;
            &lt;Button title="Tutup" onPress={() =&gt; setVisible(false)} /&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/Modal&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Komponen ini memiliki beberapa property penting:</p>
<ul>
<li><code>visible</code>: kontrol apakah modal muncul atau tidak.</li>
<li><code>transparent</code>: jika true, background luar modal bisa transparan.</li>
<li><code>animationType</code>: animasi saat modal muncul/hilang (none, slide, fade).</li>
<li><code>onRequestClose</code>: dipanggil ketika user tekan back button di Android.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style--layout"><a class="header" href="#style--layout">Style &amp; Layout</a></h1>
<p>Di React Native, styling dilakukan menggunakan <strong>JavaScript</strong>.<br />
Kita menggunakan <strong><code>StyleSheet</code></strong> atau <strong>inline style</strong> untuk mengatur tampilan komponen.</p>
<hr />
<h2 id="inline-style"><a class="header" href="#inline-style">Inline Style</a></h2>
<p>Cara paling sederhana adalah menuliskan style langsung di properti <code>style</code>:</p>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text style={{ color: 'blue', fontSize: 24 }}&gt;Halo, dunia!&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Cara ini efektif jika komponen tidak memerlukan banyak style.</p>
<h3 id="menggunakan-stylesheet"><a class="header" href="#menggunakan-stylesheet">Menggunakan StyleSheet</a></h3>
<p>Gunakan StyleSheet.create() untuk menggunakan style yang lebih rapi dan terstruktur.</p>
<pre><code class="language-ts">import { Text, View, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.text}&gt;Halo, dunia!&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f2f2f2',
  },
  text: {
    color: 'blue',
    fontSize: 24,
    fontWeight: 'bold',
  },
});
</code></pre>
<h3 id="styling-text"><a class="header" href="#styling-text">Styling Text</a></h3>
<pre><code class="language-ts">&lt;Text style={{
  fontSize: 20,
  fontWeight: 'bold',
  fontStyle: 'italic',
  textAlign: 'center',
  textDecorationLine: 'underline',
}}&gt;
  Ini contoh teks
&lt;/Text&gt;
</code></pre>
<h3 id="styling-dengan-array"><a class="header" href="#styling-dengan-array">Styling dengan Array</a></h3>
<pre><code class="language-ts">&lt;Text style={[styles.text, { color: 'red' }]}&gt;
  Warna teks ini di-override jadi merah
&lt;/Text&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style--layout-lanjutan"><a class="header" href="#style--layout-lanjutan">Style &amp; Layout Lanjutan</a></h1>
<p>React Native menggunakan <strong>Flexbox</strong> untuk mengatur tata letak.<br />
Bedanya dengan web:</p>
<ul>
<li>Default <code>flexDirection</code> di web = <strong>row</strong></li>
<li>Default <code>flexDirection</code> di React Native = <strong>column</strong></li>
</ul>
<p>Artinya, secara default komponen disusun <strong>dari atas ke bawah</strong>.</p>
<hr />
<h2 id="flexbox-untuk-layout"><a class="header" href="#flexbox-untuk-layout">Flexbox untuk Layout</a></h2>
<p>React Native menggunakan Flexbox untuk mengatur tata letak.
Secara default, <code>flexDirection</code> di React Native adalah column (berbeda dengan web yang default-nya <code>row</code>).</p>
<p><strong>Flex direction</strong></p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', justifyContent: 'space-around' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<p><strong>Flex Grow</strong></p>
<pre><code class="language-ts">&lt;View style={{ flex: 1, flexDirection: 'row' }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ flex: 2, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ flex: 3, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="justifycontent"><a class="header" href="#justifycontent">justifyContent</a></h3>
<p>Mengatur posisi sepanjang main axis (sumbu utama = flexDirection).</p>
<ul>
<li><code>flex-start</code></li>
<li><code>center</code></li>
<li><code>flex-end</code></li>
<li><code>space-between</code></li>
<li><code>space-around</code></li>
<li><code>space-evenly</code></li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', justifyContent: 'space-between' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="alignitems"><a class="header" href="#alignitems">alignItems</a></h3>
<p>Mengatur posisi sepanjang cross axis (sumbu berlawanan dengan main axis).</p>
<ul>
<li><code>flex-start</code></li>
<li><code>center</code></li>
<li><code>flex-end</code></li>
<li><code>stretch</code></li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 100, backgroundColor: 'green' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="alignself"><a class="header" href="#alignself">alignSelf</a></h3>
<p>Digunakan pada child component untuk override <code>alignItems</code>.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', alignItems: 'flex-start' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green', alignSelf: 'flex-end' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="flex"><a class="header" href="#flex">flex</a></h3>
<p>Properti <code>flex</code> menentukan seberapa banyak ruang yang diambil relatif terhadap sibling-nya.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', flex: 1 }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ flex: 2, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ flex: 3, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<ul>
<li><code>flex: 1</code> → isi ruang secara proporsional.</li>
<li><code>flex: 0</code> → ukurannya tetap sesuai width/height.</li>
</ul>
<h3 id="flexwrap"><a class="header" href="#flexwrap">flexWrap</a></h3>
<p>Membungkus elemen jika ruang tidak cukup.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', flexWrap: 'wrap' }}&gt;
  {Array.from({ length: 10 }).map((_, i) =&gt; (
    &lt;View
      key={i}
      style={{ width: 80, height: 80, backgroundColor: i % 2 ? 'tomato' : 'skyblue', margin: 4 }}
    /&gt;
  ))}
&lt;/View&gt;
</code></pre>
<p><strong>Contoh Kombinasi</strong></p>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'tomato' }} /&gt;     {/* Header */}
  &lt;View style={{ flex: 4, backgroundColor: 'skyblue' }} /&gt;   {/* Content */}
  &lt;View style={{ flex: 1, backgroundColor: 'limegreen' }} /&gt; {/* Footer */}
&lt;/View&gt;
</code></pre>
<h2 id="positioning"><a class="header" href="#positioning">Positioning</a></h2>
<p>Selain Flexbox, React Native juga mendukung <strong>positioning</strong> untuk mengatur letak komponen.<br />
Prinsipnya mirip dengan CSS di web.</p>
<h3 id="relative-default"><a class="header" href="#relative-default">relative (default)</a></h3>
<ul>
<li>Semua komponen secara default memiliki <code>position: "relative"</code>.</li>
<li>Artinya posisinya ditentukan oleh layout Flexbox.</li>
<li>Jika kita menambahkan <code>top</code>, <code>left</code>, <code>right</code>, atau <code>bottom</code>, maka komponen akan bergeser relatif terhadap posisi normalnya.</li>
</ul>
<pre><code class="language-tsx">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} /&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'skyblue', top: 20, left: 20 }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="absolute"><a class="header" href="#absolute">absolute</a></h3>
<ul>
<li>Komponen akan dilepaskan dari alur Flexbox.</li>
<li>Posisi ditentukan relatif terhadap parent yang memiliki <code>position: "relative"</code> (atau container utamanya).</li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 200, height: 200, backgroundColor: 'lightgray' }}&gt;
    &lt;View style={{ position: 'absolute', top: 20, left: 20, width: 50, height: 50, backgroundColor: 'tomato' }} /&gt;
    &lt;View style={{ position: 'absolute', bottom: 20, right: 20, width: 50, height: 50, backgroundColor: 'skyblue' }} /&gt;
  &lt;/View&gt;
&lt;/View&gt;
</code></pre>
<h3 id="z-index"><a class="header" href="#z-index">Z-Index</a></h3>
<ul>
<li>Sama seperti CSS, digunakan untuk mengatur lapisan tumpukan.</li>
<li>Semakin besar <code>zIndex</code>, semakin berada di atas.</li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato', zIndex: 1, position: 'absolute', top: 50, left: 50 }} /&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'skyblue', position: 'absolute', top: 70, left: 70 }} /&gt;
&lt;/View&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="props"><a class="header" href="#props">Props</a></h1>
<p>Dalam React Native, terdapat salah satu konsep penting yang perlu dipahami yaitu <code>props</code>. <code>Props</code>, singkatan dari <strong>properties</strong>, merupakan cara untuk mengirimkan data dari satu komponen ke komponen lain. Bayangkan <code>props</code> seperti sebuah “paket data” yang diberikan oleh komponen induk (<em>parent</em>) kepada komponen anak (<em>child</em>). Dengan cara ini, beberapa komponen dapat berinteraksi atau berkomunikasi dengan baik tanpa harus mengubah struktur dasarnya.</p>
<p><code>Props</code> bersifat read-only, artinya data yang dikirim melalui props hanya bisa dibaca oleh komponen penerima, tetapi tidak bisa diubah secara langsung dari dalam komponen tersebut. Hal ini menjadikan <code>props</code> sebagai fondasi utama dalam membangun komponen yang dapat digunakan kembali (<em>reusable components</em>).</p>
<p>Misalkan kita memiliki sebuah komponen bernama <code>Card</code>. Komponen ini dirancang untuk menampilkan nama dan pekerjaan seseorang. Menggunakan <code>props</code>, kita cukup membuat satu komponen <code>Card</code> lalu mengirimkan data yang berbeda melalui <code>props</code>.</p>
<pre><code class="language-jsx">// App.tsx
import { View, StyleSheet } from "react-native";
import Card from "./components/Card";

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Card name="John Petrucci" job="Guitarist" /&gt;
      &lt;Card name="Mike Portnoy" job="Drummer" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#fefefe"
  }
});
</code></pre>
<p>Pada kode di atas, komponen <code>App</code> berperan sebagai parent, sedangkan <code>Card</code> adalah child. Data <code>name</code> dan <code>job</code> dikirim ke dalam <code>Card</code> melalui props.</p>
<pre><code class="language-jsx">// components/Card.tsx
import { View, Text, StyleSheet } from "react-native";

type CardProps = {name:string, job:string}

export default function Card({ name, job }:CardProps) {
  return (
    &lt;View style={styles.card}&gt;
      &lt;Text style={styles.name}&gt;{name}&lt;/Text&gt;
      &lt;Text style={styles.job}&gt;{job}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  card: {
    width: 200,
    padding: 10,
    margin: 8,
    borderRadius: 8,
    backgroundColor: "#e0f7fa",
    alignItems: "center"
  },
  name: {
    fontSize: 18,
    fontWeight: "bold"
  },
  job: {
    fontSize: 14,
    color: "#555"
  }
});
</code></pre>
<p>Pada kode di atas, struktur dari <code>props</code> perlu didefinisikan terlebih dahulu melalui <code>type CardProps</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>Hooks adalah fungsi khusus yang memungkinkan kita untuk menggunakan fitur <code>React</code> seperti <code>state</code>, <code>lifecycle</code>, atau <code>context</code> ke dalam <code>function component</code>. Semua hook memiliki aturan yang sama:</p>
<ul>
<li>Selalu dipanggil di level atas <code>function component</code>.</li>
<li>Tidak dapat digunakan di dalam loop atau kondisi.</li>
<li>Selalu diawali dengan kata <code>use</code>.</li>
</ul>
<p>Di dalam hook terdapat beberapa konsep inti yang perlu dipahami:</p>
<ol>
<li>
<p><a href="state.html"><strong>State Management dengan <code>useState</code></strong></a></p>
<ul>
<li>Konsep: menyimpan dan mengubah data di dalam komponen.</li>
<li>Setiap kali state berubah, komponen akan re-<em>render</em>.</li>
<li>Contoh: menyimpan teks input, toggle boolean, counter.</li>
</ul>
</li>
<li>
<p><a href="side-effects.html"><strong>Side Effects dengan <code>useEffect</code></strong></a></p>
<ul>
<li>Konsep: menjalankan efek samping setelah render.</li>
<li>Penting karena React Native sifatnya declarative, dan <code>useEffect</code> dipakai untuk hal yang tidak langsung berhubungan dengan tampilan.</li>
<li>Contoh: memanggil <code>API</code>, mengatur timer, event listener, dan unsubscribe.</li>
</ul>
</li>
<li>
<p><a href="context.html"><strong>Context dengan <code>useContext</code></strong></a></p>
<ul>
<li>Konsep: berbagi data global antar komponen tanpa harus terus menerus menggunakan <code>props</code>.</li>
<li>Misalnya: tema aplikasi (dark/light), autentikasi user, bahasa.</li>
</ul>
</li>
<li>
<p><a href="reference.html"><strong>Reference dengan <code>useRef</code></strong></a></p>
<ul>
<li>Konsep: menyimpan nilai yang tidak memicu re-<em>render</em> ketika berubah.</li>
<li>Contoh: menyimpan nilai sementara (misalnya previous value) dan akses langsung ke komponen (misalnya TextInput focus).</li>
</ul>
</li>
<li>
<p><a href="reducer.html"><strong>Reducer dengan <code>useReducer</code></strong></a></p>
<ul>
<li>Konsep: alternatif dari <code>useState</code> untuk state yang lebih kompleks.</li>
<li>Contoh: cocok untuk logika yang melibatkan banyak aksi (misalnya form dengan banyak field).</li>
</ul>
</li>
<li>
<p><a href="custom-hooks.html"><strong>Custom Hooks</strong></a></p>
<ul>
<li>Konsep: membuat hook sendiri untuk mengabstraksi logika agar dapat digunakan ulang.</li>
<li>Contoh: <code>useAuth()</code>, <code>useFetch()</code>, <code>useOrientation()</code>.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-usestate"><a class="header" href="#state-usestate">State (<code>useState</code>)</a></h1>
<p>Setelah sebelumnya kita mengenal <code>props</code> sebagai cara untuk memberikan data dari luar ke dalam sebuah komponen, kini kita akan membahas konsep penting lainnya, yaitu <code>state</code>. Jika <code>props</code> dapat kita ibaratkan seperti paket data yang dikirim dari luar, maka state adalah data milik komponen itu sendiri yang dapat berubah sepanjang waktu.</p>
<p>Sebuah komponen dapat memiliki <code>state</code> untuk menyimpan informasi yang bersifat dinamis. Misalnya, ketika pengguna menekan tombol, mengetik di dalam sebuah input, atau ketika aplikasi menerima data baru dari server, semua perubahan tersebut bisa dikelola dengan <code>state</code>. Inilah yang membuat aplikasi menjadi interaktif.</p>
<p>Berbeda dengan <code>props</code> yang hanya bisa dibaca (<strong>read-only</strong>), <code>state</code> dapat diperbarui. Ketika <code>state</code> berubah, <strong>React Native</strong> akan secara otomatis melakukan <em>re-render</em> pada bagian komponen yang menggunakan <code>state</code> tersebut. Dengan demikian, tampilan aplikasi akan selalu sesuai dengan data terbaru.</p>
<p>Struktur dasarnya seperti ini:</p>
<pre><code class="language-jsx">const [value, setValue] = useState(initialValue);
</code></pre>
<ul>
<li><code>value</code>: isi <code>state</code> saat ini.</li>
<li><code>setValue</code>: fungsi untuk mengubah isi dari <code>state</code>.</li>
<li><code>initialValue</code>: nilai awal <code>state</code>.</li>
<li><code>useState</code>: hook <strong>React Native</strong>.</li>
</ul>
<h2 id="contoh-state-1-counter-sederhana"><a class="header" href="#contoh-state-1-counter-sederhana">Contoh State 1: Counter Sederhana</a></h2>
<p>Sebagai contoh, kita ingin menampilkan angka yang bertambah setiap kali pengguna menekan tombol “+” dan begitupun sebaliknya untuk tombol “-”. Untuk menyimpan angka tersebut, kita menggunakan <code>state</code>. Setiap kali tombol ditekan, <code>state</code> diperbarui, dan tampilan angka pada layar pun langsung ikut berubah.</p>
<pre><code class="language-typescript">// App.tsx
import React, { useState } from "react";
import { View, Text, Button, StyleSheet } from "react-native";

export default function App() {
  // Membuat state bernama "count" dengan nilai awal 0
  const [count, setCount] = useState(0);

  return (
    &lt;View style={styles.container}&gt;
      // Komponen ini akan me-render jika ada perubahan nilai state
      &lt;Text style={[styles.text, count &lt; 0 ? { color: 'red' } : { color: 'black' }]}&gt;Count: {count}&lt;/Text&gt;
      &lt;View style={styles.button_container}&gt;
        &lt;Button 
          title="+" 
          // memanggil fungsi SetCount untuk menambah nilai state ketika button ditekan
          onPress={() =&gt; setCount(count + 1)} 
        /&gt;

        &lt;Button 
          title="-" 
          // memanggil fungsi SetCount untuk mengurangi nilai state ketika button ditekan
          onPress={() =&gt; setCount(count - 1)} 
        /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center"
  },
  text: {
    fontSize: 24,
    marginBottom: 20
  },
  button_container:{
    flexDirection:'row',
    justifyContent:'center',
    alignItems:'center',
    gap: 15
  }
});
</code></pre>
<p>Pada contoh di atas, kita menggunakan <strong><code>useState</code></strong> untuk membuat state <code>count</code>. Setiap kali tombol ditekan, fungsi <code>setCount</code> dipanggil untuk memperbarui nilai <code>count</code>. React Native kemudian secara otomatis memperbarui tampilan teks agar sesuai dengan nilai terbaru.</p>
<h2 id="contoh-state-2-menyimpan-input-teks"><a class="header" href="#contoh-state-2-menyimpan-input-teks">Contoh State 2: Menyimpan Input Teks</a></h2>
<p>Misalnya, kita ingin membuat aplikasi sederhana yang menampilkan teks berdasarkan teks yang diketik pengguna.</p>
<pre><code class="language-typescript">// App.tsx
import React, { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

export default function App() {
  // Membuat state bernama "name" dengan nilai awal empty string
  const [name, setName] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;Masukkan nama Anda:&lt;/Text&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik di sini..."
        value={name}
        // memanggil fungsi setName untuk mengubah nilai state (name) sesuai dengan input user
        onChangeText={(text) =&gt; setName(text)}
      /&gt;

      // Komponen ini akan me-render jika ada perubahan nilai state
      &lt;Text style={styles.greeting}&gt;
        {name ? `Halo, ${name}!` : "Silakan ketik nama Anda"}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  label: {
    fontSize: 18,
    marginBottom: 10,
  },
  input: {
    width: "100%",
    borderWidth: 1,
    borderColor: "#aaa",
    padding: 10,
    marginBottom: 20,
    borderRadius: 5,
  },
  greeting: {
    fontSize: 20,
    fontWeight: "bold",
  },
});
</code></pre>
<h2 id="contoh-state-3-menggunakan-usestate-pada-reusable-component"><a class="header" href="#contoh-state-3-menggunakan-usestate-pada-reusable-component">Contoh State 3: Menggunakan <code>useState</code> pada reusable component</a></h2>
<p>Misalnya kita ingin membuat <code>CustomInput</code> yang bisa dipakai di banyak tempat. Komponen ini memiliki state untuk menyimpan teks lokal, lalu menampilkan hasil ketikan.</p>
<h3 id="apptsx"><a class="header" href="#apptsx">App.tsx</a></h3>
<pre><code class="language-typescript">import React from "react";
import { View, StyleSheet } from "react-native";
import CustomInput from "./components/CustomInput";

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;CustomInput label="Nama" placeholder="Masukkan nama Anda" /&gt;
      &lt;CustomInput label="Email" placeholder="Masukkan email Anda" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    padding: 20,
  },
});
</code></pre>
<h3 id="componentscustominputtsx"><a class="header" href="#componentscustominputtsx">components/CustomInput.tsx</a></h3>
<pre><code class="language-typescript">import React, { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

type CustomInputProps = {
  label: string,
  placeholder: string
};

export default function CustomInput({ label, placeholder }:CustomInputProps) {
  // Membuat state lokal bernama "value" dengan nilai awal empty string
  const [value, setValue] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
      &lt;TextInput
        style={styles.input}
        placeholder={placeholder}
        value={value}
        // memanggil fungsi setValue untuk mengubah nilai state sesuai dengan input user
        onChangeText={(text) =&gt; setValue(text)}
      /&gt;

      // komponen akan di re-render jika nilai state berubah
      &lt;Text style={styles.preview}&gt;
        {value ? `Anda mengetik: ${value}` : "Belum ada input"}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
  },
  input: {
    borderWidth: 1,
    borderColor: "#aaa",
    padding: 10,
    borderRadius: 5,
  },
  preview: {
    marginTop: 5,
    fontSize: 14,
    color: "#555",
  },
});

</code></pre>
<p>Pada contoh program di atas, setiap instance <code>CustomInput</code> (yang ditambahkan ke dalam App()) memiliki state masing-masing (sehingga input nama tidak mengganggu input email).</p>
<h2 id="contoh-state-4-array-state"><a class="header" href="#contoh-state-4-array-state">Contoh State 4: Array State</a></h2>
<h3 id="componentstodolisttsx"><a class="header" href="#componentstodolisttsx">components/TodoList.tsx</a></h3>
<pre><code class="language-typescript">import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';

export default function TodoList() {
  
  const [todos, setTodos] = useState([]);

  const addTodo = () =&gt; {
    // membuat salinan array lama sehingga data yang sudah tersimpan tidak hilang
    setTodos([...todos, `Tugas ${todos.length + 1}`]);
  };

  return (
    &lt;View&gt;
      // memanggil fungsi addTodo untuk menambah data baru ke dalam state
      &lt;Button title="Tambah Tugas" onPress={addTodo} /&gt;
      {todos.map((todo, index) =&gt; (
        &lt;Text key={index}&gt;{todo}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}
</code></pre>
<p>Kalau state berupa array, biasanya perlu membuat salinan array lama lalu tambahkan data baru, agar state tetap immutable (<code>...todos</code>).</p>
<p><code>useState</code> adalah pondasi penting dalam React Native karena hampir semua komponen interaktif butuh state. Tanpa <code>useState</code>, aplikasi cuma hanya berupa sekumpulan teks dan gambar statis.</p>
<p><code>useState</code> memiliki tiga aturan simpel berikut:</p>
<ul>
<li>Mengembalikan sepasang nilai (state saat ini) dan fungsi untuk mengubah state.</li>
<li>Setiap kali state berubah, komponen otomatis merender ulang.</li>
<li>State bisa berupa apa pun: string, number, boolean, array, object, bahkan kombinasi.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side-effects-useeffect"><a class="header" href="#side-effects-useeffect">Side Effects (<code>useEffect</code>)</a></h1>
<p>Kalau sebelumnya kita belajar tentang state yang bisa menyimpan data dinamis di sebuah komponen, sekarang saatnya masuk ke hal lain yang tidak kalah penting: side effect.</p>
<p>Side effect adalah segala hal yang terjadi di luar proses rendering UI. Contohnya:</p>
<ul>
<li>Memanggil API untuk mengambil data.</li>
<li>Mengatur timer atau interval.</li>
<li>Mengupdate judul aplikasi atau menyimpan data ke storage.</li>
</ul>
<p><code>useEffect</code> adalah hook yang memungkinkan kita menjalankan kode setiap kali komponen selesai di-<em>render</em>. Dengan kata lain, dia seperti lifecycle methods di class component (componentDidMount, componentDidUpdate, dan componentWillUnmount) tapi digabung dalam satu fungsi.</p>
<p>Struktur dasarnya seperti ini:</p>
<pre><code class="language-tsx">useEffect(() =&gt; {
  // kode yang mau dijalankan setelah render

  return () =&gt; {
    // optional: kode cleanup
  };
}, [dependencies]);
</code></pre>
<ul>
<li>Bagian pertama <code>(() =&gt; { ... })</code> adalah efek yang dijalankan.</li>
<li><code>return () =&gt; { ... }</code> adalah cleanup function, dipanggil ketika efek harus dibersihkan (misalnya saat komponen di-unmount atau sebelum efek baru dipasang lagi).</li>
<li><code>[dependencies]</code> adalah array berisi nilai yang diawasi. Efek hanya dijalankan ulang ketika nilai di array ini berubah.</li>
</ul>
<h2 id="contoh-1-dipanggil-setiap-render"><a class="header" href="#contoh-1-dipanggil-setiap-render">Contoh 1: Dipanggil Setiap Render</a></h2>
<pre><code class="language-tsx">import React, { useState, useEffect } from 'react';
import { View, Text, Button } from 'react-native';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Komponen dirender. Nilai count:', count);
  });

  return (
    &lt;View&gt;
      &lt;Text&gt;Count: {count}&lt;/Text&gt;
      &lt;Button title="Tambah" onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Karena kita tidak memberi dependency array, efek ini akan dipanggil setiap kali komponen dirender.</p>
<h2 id="contoh-2-hanya-sekali"><a class="header" href="#contoh-2-hanya-sekali">Contoh 2: Hanya Sekali</a></h2>
<pre><code class="language-tsx">useEffect(() =&gt; {
  console.log('Komponen baru saja muncul di layar');

  // cleanup
  return () =&gt; {
    console.log('Komponen hilang dari layar');
  };
}, []);
</code></pre>
<p>Dengan dependency array kosong <code>[]</code>, efek hanya dijalankan sekali saat komponen pertama kali dipasang, lalu dibersihkan saat komponen dilepas.</p>
<h2 id="contoh-3-bergantung-pada-state-tertentu"><a class="header" href="#contoh-3-bergantung-pada-state-tertentu">Contoh 3: Bergantung Pada State Tertentu</a></h2>
<pre><code class="language-tsx">import React, { useState, useEffect } from 'react';
import { View, Text, Button } from 'react-native';

export default function NameWatcher() {
  const [name, setName] = useState('Mike');
  const [age, setAge] = useState(20);

  useEffect(() =&gt; {
    console.log('Nama berubah:', name);
  }, [name]); // hanya jalan kalau "name" berubah

  return (
    &lt;View&gt;
      &lt;Text&gt;{name} - {age}&lt;/Text&gt;
      &lt;Button title="Ganti Nama" onPress={() =&gt; setName('Portnoy')} /&gt;
      &lt;Button title="Tambah Umur" onPress={() =&gt; setAge(age + 1)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Efek ini cuma jalan kalau nilai <code>name</code> berubah. Kalau <code>age</code> yang berubah, efek tidak akan dijalankan.</p>
<h2 id="contoh-4-memanggil-api"><a class="header" href="#contoh-4-memanggil-api">Contoh 4: Memanggil API</a></h2>
<pre><code class="language-tsx">import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

export default function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) =&gt; res.json())
      .then((data) =&gt; {
        setUsers(data);
        setLoading(false);
      });
  }, []); // hanya sekali dijalankan saat komponen pertama kali render

  if (loading) return &lt;ActivityIndicator /&gt;;

  return (
    &lt;View&gt;
      {users.map((user) =&gt; (
        &lt;Text key={user.id}&gt;{user.name}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>useEffect</code> adalah salah satu hook paling penting di React Native. Memungkinkan kita untuk menangani hal-hal yang berhubungan dengan dunia luar render UI seperti API, timer, event listener, dan lain-lain.</p>
<p><code>useEffect</code> memiliki tiga aturan simpel berikut:</p>
<ul>
<li>Tanpa dependency array → jalan setiap render.</li>
<li>Dengan array kosong <code>[]</code> → jalan sekali di awal.</li>
<li>Dengan array berisi state/props → jalan setiap kali nilai itu berubah.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-usecontext"><a class="header" href="#context-usecontext">Context (<code>useContext</code>)</a></h1>
<p>Ketika ukuran aplikasi masih tergolong kecil, komunikasi antar komponen yang umumnya melalui <code>props</code> cukup mudah dilakukan. Bayangkan apabila data yang dikirimkan ke banyak komponen dan berada di hirarki yang cukup dalam. Menggunakan <code>props</code> untuk mengirimkan data ke setiap level tentunya bukan teknik yang efektif karena nantinya akan mempersulit pengelolaan aplikasi.</p>
<p>Dengan <code>context</code>, data dapat disimpan secara global sehingga dapat diakses oleh komponen mana pun tanpa harus melempar data menggunakan <code>props</code>.</p>
<p>Secara sederhana, <code>Context</code> memiliki tiga bagian utama:</p>
<ul>
<li><strong>Membuat Context</strong> → menggunakan <code>React.createContext()</code>.</li>
<li><strong>Provider</strong> → komponen yang membungkus bagian aplikasi, dan isinya adalah data yang akan dibagikan.</li>
<li><strong>Consumer</strong> → komponen yang membaca data dari <code>Context</code>.</li>
</ul>
<h2 id="contoh-theme-context-darklight-mode"><a class="header" href="#contoh-theme-context-darklight-mode">Contoh: Theme Context (Dark/Light Mode)</a></h2>
<p>Struktur folder:</p>
<pre><code class="language-bash">/components
   └── ThemedButton.tsx
/context
   └── ThemeContext.tsx
/screens
   └── HomeScreen.tsx
App.tsx
</code></pre>
<p><strong>ThemeContext.tsx</strong></p>
<pre><code class="language-tsx">import React from "react";
import { createContext, useState } from "react";

type ContextType = {
    theme:string,
    toggleTheme: () =&gt; void
}

type Props = {
    children: ReactNode
}

export const ThemeContext = createContext&lt;ContextType&gt;('light'); // nilai default

export function ThemeProvider({ props }:Props) {
    const [theme, setTheme] = useState('light');
    const toggleTheme = () =&gt; setTheme(theme == 'light' ? 'dark' : 'light');
    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {props.children}
        &lt;/ThemeContext.Provider&gt;
    );
}
</code></pre>
<p><code>createContext('light')</code> bertindak sebagai wadah (context) untuk menyimpan data yang dapat digunakan di seluruh komponen. Di sini context akan menyimpan theme (light/dark) dan fungsi toggleTheme.</p>
<p><code>ThemeProvider</code> adalah komponen pembungkus dengan <code>state</code> awal bernilai light. <code>ThemeContext.Provider</code> membagikan data (<code>theme</code>, <code>toggleTheme</code>) ke semua komponen di dalamnya (<code>children</code>). Artinya, komponen apa pun yang ada di bawah <code>ThemeProvider</code> dapat mengambil <code>theme</code> dan <code>toggleTheme</code>.</p>
<p><strong>ThemedButton.tsx</strong></p>
<pre><code class="language-tsx">import { useContext } from "react";
import { ThemeContext } from "../context/ThemeContext";
import { Text, TouchableOpacity } from "react-native";

type Props = {
    title: string,
    onPress: () =&gt; void
};

export default function ThemedButton({props}:Props) {
    const { theme } = useContext(ThemeContext);

    const backgroundColor = theme === 'light' ? '#007BFF' : '#555';
    const textColor = theme === 'light' ? '#fff' : '#ddd';

    return (
        &lt;TouchableOpacity
            style={{
                backgroundColor,
                padding: 12,
                borderRadius: 8,
                margin: 5,
            }}
            onPress={props.onPress}&gt;
            &lt;Text style={{ color: textColor, fontWeight: 'bold' }}&gt;{props.title}&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
    );
}
</code></pre>
<p><strong>HomeScreen.tsx</strong></p>
<pre><code class="language-tsx">import { useContext } from "react";
import { ThemeContext } from "../context/ThemeContext";
import { Text, View } from "react-native";
import ThemedButton from "../components/ThemedButton";

export default function HomeScreen() {
    const { theme, toggleTheme } = useContext(ThemeContext);
    return (
        &lt;View style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: theme === 'light' ? '#fff' : '#333',
        }}&gt;
            &lt;Text style={{ color: theme === 'light' ? '#000' : '#fff' }}&gt;
                Tema saat ini: {theme}
            &lt;/Text&gt;
            &lt;ThemedButton title="Ganti Tema" onPress={toggleTheme} /&gt;
            &lt;ThemedButton title="Button Tambahan" onPress={() =&gt; { }} /&gt;

        &lt;/View&gt;
    );
}
</code></pre>
<p><code>useContext(ThemeContext)</code> digunakan untuk mengakses value atau fungsi yang diturunkan oleh <code>ThemeContext</code>.</p>
<p><strong>App.tsx</strong></p>
<pre><code class="language-tsx">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';
import { ThemeProvider } from './context/ThemeContext';
import HomeScreen from './screens/HomeScreen';

export default function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;HomeScreen /&gt;
    &lt;/ThemeProvider&gt;
  );
}
</code></pre>
<h2 id="alur-program"><a class="header" href="#alur-program">Alur Program</a></h2>
<ol>
<li><code>App.tsx</code> → Komponen parent yang membungkus seluruh komponen lainnya dengan <code>ThemeProvider</code> agar seluruh komponen <em>child</em> dapat mengakses <code>ThemeContext</code>.</li>
<li><code>ThemeContext.tsx</code> → Menyimpan state tema (<code>light</code> atau <code>dark</code>) dan menyediakan fungsi <code>toggleTheme</code> untuk mengubah <code>state</code> tema.</li>
<li><code>HomeScreen.tsx</code> → Menampilkan teks sesuai tema + tombol untuk ganti tema.</li>
<li><code>ThemedButton.tsx</code> → Komponen tombol yang mengatur gaya sesuai tema.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-useref"><a class="header" href="#reference-useref">Reference (<code>useRef</code>)</a></h1>
<p><code>useRef</code> adalah salah satu hooks pada React Native yang berguna untuk menyimpan nilai atau mereferensikan elemen tanpa menyebabkan komponen melakukan render ulang. Kalau <code>useState</code> selalu bikin render ulang saat nilainya berubah, <code>useRef</code> tidak. Nilai yang disimpan di <code>useRef</code> tetap ada selama komponen hidup, tapi perubahan nilainya tidak memicu re-<em>render</em>.</p>
<p><code>useRef</code> cocok digunakan pada kasus:</p>
<ol>
<li>Menyimpan nilai lama (previous value).</li>
<li>Mengakses dan mengontrol elemen UI (misalnya TextInput).</li>
<li>Menyimpan variabel yang berubah-ubah tapi tidak perlu re-<em>render</em> misalnya timer.</li>
<li>Membuat animasi</li>
</ol>
<h2 id="contoh-1-menyimpan-nilai-lama"><a class="header" href="#contoh-1-menyimpan-nilai-lama">Contoh 1: Menyimpan Nilai Lama</a></h2>
<p>Kadang kita ingin tahu nilai sebelum <code>state</code> berubah. <code>useRef</code> dapat menyimpan history ini.</p>
<pre><code class="language-tsx">import React, { useState, useEffect, useRef } from "react";
import { View, Text, Button } from "react-native";

export default function App() {
  const [score, setScore] = useState(0);
  const prevScoreRef = useRef(0);

  useEffect(() =&gt; {
    prevScoreRef.current = score; // update setiap kali score berubah
  }, [score]);

  return (
    &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}&gt;
      &lt;Text&gt;Current Score: {score}&lt;/Text&gt;
      &lt;Text&gt;Previous Score: {prevScoreRef.current}&lt;/Text&gt;
      &lt;Button title="Add 10" onPress={() =&gt; setScore(score + 10)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>prevScoreRef.current</code> selalu menyimpan nilai sebelum update.</p>
<h2 id="contoh-2-mengontrol-input"><a class="header" href="#contoh-2-mengontrol-input">Contoh 2: Mengontrol Input</a></h2>
<p>Dengan <code>useRef</code>, kita dapat fokus langsung ke input tanpa perlu <code>state</code> tambahan.</p>
<pre><code class="language-tsx">import React, { useRef } from "react";
import { View, TextInput, Button } from "react-native";

export default function App() {
  const inputRef = useRef(null);

  const focusInput = () =&gt; {
    inputRef.current.focus(); // langsung fokus ke input
  };

  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;TextInput
        ref={inputRef}
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
        placeholder="Type something..."
      /&gt;
      &lt;Button title="Focus Input" onPress={focusInput} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>inputRef</code> dipakai untuk mengakses komponen TextInput langsung.</p>
<h2 id="contoh-3-timer-dengan-useref"><a class="header" href="#contoh-3-timer-dengan-useref">Contoh 3: Timer dengan useRef</a></h2>
<pre><code class="language-tsx">import React, { useRef, useState } from "react";
import { View, Text, Button } from "react-native";

export default function App() {
  const [seconds, setSeconds] = useState(0);
  const timerRef = useRef(null);

  const startTimer = () =&gt; {
    if (timerRef.current) return; // cegah timer ganda
    timerRef.current = setInterval(() =&gt; {
      setSeconds((prev) =&gt; prev + 1);
    }, 1000);
  };

  const stopTimer = () =&gt; {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };

  return (
    &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}&gt;
      &lt;Text&gt;⏱ {seconds} seconds&lt;/Text&gt;
      &lt;Button title="Start" onPress={startTimer} /&gt;
      &lt;Button title="Stop" onPress={stopTimer} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reducer-usereducer"><a class="header" href="#reducer-usereducer">Reducer (<code>useReducer</code>)</a></h1>
<p><code>useReducer</code> adalah hook di React Native yang digunakan untuk mengelola state yang lebih kompleks dibanding <code>useState</code>. Jika <code>useState</code> cocok untuk perubahan state yang sederhana, <code>useReducer</code> lebih cocok digunakan saat kita memiliki logika update state yang melibatkan banyak kondisi atau aturan.</p>
<pre><code class="language-jsx">const [state, dispatch] = useReducer(reducer, initialState);
</code></pre>
<ul>
<li><strong>state</strong> → nilai state saat ini</li>
<li><strong>dispatch</strong> → fungsi untuk mengirimkan action</li>
<li><strong>reducer</strong> → fungsi yang menentukan bagaimana state berubah</li>
<li><strong>initialState</strong> → nilai awal state</li>
</ul>
<pre><code class="language-jsx">function reducer(state, action) {
  switch (action.type) {
    case "actionType":
      return stateBaru;
    default:
      return state;
  }
}
</code></pre>
<p>Reducer menerima state lama dan sebuah action, lalu mengembalikan state baru.</p>
<h2 id="contoh-1-counter"><a class="header" href="#contoh-1-counter">Contoh 1: Counter</a></h2>
<h3 id="apptsx-1"><a class="header" href="#apptsx-1">App.tsx</a></h3>
<pre><code class="language-jsx">
import { StatusBar } from 'expo-status-bar';
import { useReducer } from 'react';
import { StyleSheet, View } from 'react-native';
import Counter from './components/Counter';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Counter title="Counter" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 20
  }
});
</code></pre>
<h3 id="componentscountertsx"><a class="header" href="#componentscountertsx">components/Counter.tsx</a></h3>
<pre><code class="language-tsx">
import { useReducer } from "react";
import { Button, StyleSheet, Text, View } from "react-native";

type State = {
    count: number
}

const initialState: State = { count: 0 };

type Action = { jenis: "increment" } | { jenis: "decrement" };

const reducer = (state: State, action: Action): State =&gt; {
    switch (action.jenis) {
        case "increment":
            return { count: state.count + 1 };
        case "decrement":
            return { count: state.count - 1 };
        default:
            return state;
    }
}

type CounterProps = { title: string }
export default function Counter({ title }: CounterProps) {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        &lt;View style={styles.card}&gt;
            &lt;Text style={styles.title}&gt;{title}&lt;/Text&gt;
            &lt;Text style={[styles.content, state.count &lt; 0 &amp;&amp; { color: 'red' }]}&gt;{state.count}&lt;/Text&gt;
            &lt;View style={styles.button_container}&gt;
                &lt;Button title="Kurangi" onPress={() =&gt; dispatch({ jenis: "decrement" })} /&gt;
                &lt;Button title="Tambah" onPress={() =&gt; dispatch({ jenis: 'increment' })} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}

const styles = StyleSheet.create({
    card: {
        width: 240,
        padding: 10,
        borderRadius: 8,
        backgroundColor: '#fff',
        elevation: 3,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
    },
    title: {
        fontSize: 18,
        fontWeight: 'bold',
    },
    content: {
        alignSelf: 'center',
        fontSize: 28,
        fontWeight: "600",
    },
    button_container: {
        padding: 8,
        borderTopWidth: 1,
        borderTopColor: '#4b4b4bff',
        flexDirection: 'row',
        gap: 10,
        justifyContent: 'center',
        alignItems: 'center'
    }
});
</code></pre>
<p>Dengan <code>dispatch</code>, kita mengirim action (misalnya <code>{ jenis: "increment" }</code>), lalu reducer mengatur perubahan <code>state</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-hooks"><a class="header" href="#custom-hooks">Custom Hooks</a></h1>
<p>Custom Hook adalah fungsi buatan kita sendiri yang mengikuti aturan Hook (diawali dengan <code>use...</code>) untuk mengenkapsulasi logic tertentu agar dapat digunakan ulang di berbagai komponen.</p>
<p>Jika <code>useState</code>, <code>useEffect</code>, <code>useReducer</code>, dll adalah hook bawaan <strong>React Native</strong>, maka custom hook memungkinkan kita bikin versi sendiri sesuai kebutuhan.</p>
<p>Custom hook memberikan beberapa keuntungan, seperti:</p>
<ol>
<li>Kode lebih bersih &amp; reusable</li>
<li>Logic &amp; UI terpisah</li>
<li>Lebih mudah testing</li>
</ol>
<h2 id="contoh-1-hook-untuk-input-text"><a class="header" href="#contoh-1-hook-untuk-input-text">Contoh 1: Hook untuk Input Text</a></h2>
<pre><code class="language-tsx">// hooks/UseInput.ts
import { useState } from "react";

// custom hook
function useInput(initialValue = "") {
  const [value, setValue] = useState(initialValue);

  const onChangeText = (text) =&gt; setValue(text);
  const reset = () =&gt; setValue("");

  return { value, onChangeText, reset };
}

export default useInput;
</code></pre>
<pre><code class="language-tsx">// App.tsx
import React from "react";
import { View, TextInput, Button, Text } from "react-native";
import useInput from "./hooks/UseInput";

export default function App() {
  const name = useInput("");
  const email = useInput("");

  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;TextInput
        placeholder="Nama"
        value={name.value}
        onChangeText={name.onChangeText}
        style={{ borderWidth: 1, marginBottom: 10, padding: 5 }}
      /&gt;
      &lt;TextInput
        placeholder="Email"
        value={email.value}
        onChangeText={email.onChangeText}
        style={{ borderWidth: 1, marginBottom: 10, padding: 5 }}
      /&gt;
      &lt;Button title="Submit" onPress={() =&gt; {
        console.log("Nama:", name.value, "Email:", email.value);
        name.reset();
        email.reset();
      }} /&gt;
      &lt;Text style={{ marginTop: 10 }}&gt;
        Nama: {name.value} | Email: {email.value}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<p>Pada dasarnya, event handling adalah mekanisme untuk menangani aksi yang dilakukan pengguna, seperti menekan tombol, mengetik teks, atau melakukan scroll. Di React Native, event handling dilakukan dengan cara menghubungkan sebuah event handler (fungsi) dengan properti event dari suatu komponen. Secara umum, ada beberapa kategori event yang sering dipakai:</p>
<p><strong>1. Event pada komponen interaktif (tombol, touchable)</strong></p>
<ul>
<li><code>onPress</code> → saat komponen ditekan (Button, TouchableOpacity, Pressable).</li>
<li><code>onLongPress</code> → saat ditekan lama.</li>
<li><code>onPressIn</code> dan <code>onPressOut</code> → saat jari menyentuh &amp; melepas.</li>
</ul>
<p><strong>2. Event pada input teks</strong></p>
<ul>
<li><code>onChangeText</code> → saat teks berubah.</li>
<li><code>onFocus</code> → saat input aktif (fokus).</li>
<li><code>onBlur</code> → saat input kehilangan fokus.</li>
<li><code>onSubmitEditing</code> → saat user menekan tombol submit/enter.</li>
</ul>
<p><strong>3. Event pada list / scroll</strong></p>
<ul>
<li><code>onScroll</code> → saat daftar/scrollview digulir.</li>
<li><code>onEndReached</code> (FlatList/SectionList) → saat mendekati akhir daftar.</li>
<li><code>onRefresh</code> → saat user menarik ke bawah (pull to refresh).</li>
</ul>
<p><strong>4. Event gesture / sentuhan</strong></p>
<ul>
<li><code>onTouchStart</code>, <code>onTouchMove</code>, <code>onTouchEnd</code> → event dasar sentuhan.</li>
<li>Jika pakai <code>PanResponder</code> atau library react-native-gesture-handler, bisa dapat event lebih kompleks seperti swipe, drag, fling.</li>
</ul>
<p><strong>5. Event pada image &amp; media</strong></p>
<ul>
<li><code>onLoad</code> dan <code>onError</code> (Image) → saat gambar berhasil/gagal dimuat.</li>
<li><code>onLoadStart</code> dan <code>onLoadEnd</code> → progres load gambar.</li>
</ul>
<h2 id="contoh-event-handling-1"><a class="header" href="#contoh-event-handling-1">Contoh Event Handling 1</a></h2>
<pre><code class="language-jsx">// App.tsx
import { useState } from "react";
import { View, Text, Button, StyleSheet } from "react-native";

export default function App() {
  const [count, setCount] = useState(0);

  const handlePress = () =&gt; {
    setCount(count + 1); // setiap kali tombol ditekan, count bertambah
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.text}&gt;Jumlah klik: {count}&lt;/Text&gt;
      &lt;Button title="Klik Saya" onPress={handlePress} /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
</code></pre>
<p>Pada contoh di atas, event <code>onPress</code> dari komponen <code>Button</code> dipasangkan dengan fungsi <code>handlePress</code>. Setiap kali tombol ditekan, state <code>count</code> akan bertambah satu, dan perubahan state ini akan langsung di-<em>rerender</em> pada teks yang ditampilkan.</p>
<h2 id="contoh-event-handling-2"><a class="header" href="#contoh-event-handling-2">Contoh Event Handling 2</a></h2>
<pre><code class="language-jsx">// App.tsx
import { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

export default function App() {
  const [name, setName] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik nama Anda"
        onChangeText={(text) =&gt; setName(text)}
      /&gt;
      &lt;Text style={styles.text}&gt;Halo, {name}!&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    width: 200,
    marginBottom: 20,
  },
  text: {
    fontSize: 18,
  },
});
</code></pre>
<p>Di sini, setiap kali pengguna mengetik, event <code>onChangeText</code> akan dijalankan dan memperbarui state name. Tampilan pun otomatis menyesuaikan dengan isi teks terbaru.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation"><a class="header" href="#navigation">Navigation</a></h1>
<p>Saat membuat aplikasi mobile, biasanya tidak hanya terdiri atas satu halaman saja. Misalnya aplikasi belanja online: ada halaman beranda, halaman detail produk, halaman keranjang belanja, hingga halaman profil pengguna. Semua halaman ini harus bisa saling terhubung agar pengalaman pengguna berjalan mulus. Bayangkan kalau aplikasi hanya menampilkan satu halaman statis, pengguna pasti akan kesulitan, karena tidak bisa berpindah ke informasi lain. Inilah alasan mengapa navigasi menjadi bagian yang sangat penting dalam pengembangan aplikasi mobile.</p>
<p>Di React Native sendiri, <strong>tidak terdapat navigasi bawaan</strong>. Artinya, diperlukan library tambahan untuk menangani navigasi antar halaman. Library yang paling populer dan direkomendasikan adalah <strong>React Navigation</strong>.</p>
<p>Dengan React Navigation, kita dapat:</p>
<ul>
<li>Membuat alur berpindah antar layar dengan Stack Navigation.</li>
<li>Membuat menu bawah dengan Tab Navigation.</li>
<li>Membuat menu samping dengan Drawer Navigation.</li>
</ul>
<h2 id="instalasi-2"><a class="header" href="#instalasi-2">Instalasi</a></h2>
<p>Setelah membuat project baru, tambahkan atau install dependencies berikut:</p>
<pre><code class="language-bash">npm install @react-navigation/native
</code></pre>
<p><strong>Expo</strong></p>
<pre><code class="language-bash">npx expo install react-native-screens react-native-safe-area-context react-native-gesture-handler react-native-reanimated
</code></pre>
<p><strong>React Native CLI</strong></p>
<pre><code class="language-bash">npm install react-native-screens react-native-safe-area-context react-native-gesture-handler react-native-reanimated
</code></pre>
<p>iOS</p>
<pre><code class="language-bash">npx pod-install ios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-navigation"><a class="header" href="#stack-navigation">Stack Navigation</a></h1>
<h2 id="konsep-dasar"><a class="header" href="#konsep-dasar">Konsep Dasar</a></h2>
<ul>
<li>Stack navigation mirip tumpukan kartu.</li>
<li>Setiap kali pindah ke layar baru → layar ditaruh di atas stack.</li>
<li>Ketika kembali → layar di atas dihapus, dan kita kembali ke layar sebelumnya.</li>
<li>Ini cocok untuk alur seperti: <code>Home → Detail → Settings</code></li>
<li>Mekanismenya mirip riwayat browser:
<ul>
<li><code>navigate()</code> = buka halaman baru dan <code>push</code> stack.</li>
<li><code>goBack()</code> = kembali ke halaman sebelumnya <code>pop</code> stack.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi"><a class="header" href="#struktur-implementasi">Struktur Implementasi</a></h2>
<p>Sebenarnya, navigasi jenis ini dapat diinisialisasi langsung pada file main yaitu <code>App.tsx</code>. Struktur modular lebih disukai karena kemudahannya dalam proyek jangka panjang yang selalu berkembang.</p>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── StackNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    └── DetailScreen.tsx
</code></pre>
<h2 id="instalasi-3"><a class="header" href="#instalasi-3">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/native-stack
</code></pre>
<h2 id="contoh-1"><a class="header" href="#contoh-1">Contoh</a></h2>
<h3 id="screenshomescreentsx"><a class="header" href="#screenshomescreentsx">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { View, Text, Button } from 'react-native';
import { RootStackParamList } from '../navigations/StackNavigator';

type Props = NativeStackScreenProps&lt;RootStackParamList, 'Home'&gt;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button
                title="Lihat Detail"
                onPress={() =&gt; navigation.navigate('Detail', { id: 101, barang: "Laptop" })}
            /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = NativeStackScreenProps&lt;RootStackParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home. Strukturnya dapat dilihat pada <a href="stack-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Detail', { id: 101, barang: "Laptop" })</code>: pindah ke halaman Detail, sekaligus mengirim data id = 101 dan barang = “Laptop”.</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman detail dengan parameter.</p>
<h3 id="screensdetailscreentsx"><a class="header" href="#screensdetailscreentsx">screens/DetailScreen.tsx</a></h3>
<pre><code class="language-javascript">import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { View, Text, Button } from 'react-native';
import { RootStackParamList } from '../navigations/StackNavigator';

type Props = NativeStackScreenProps&lt;RootStackParamList, 'Detail'&gt;

export default function DetailScreen({ route, navigation }: Props) {
    const { id, barang } = route.params || {};

    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Detail Screen&lt;/Text&gt;
            &lt;Text&gt;ID: {id}&lt;/Text&gt;
            &lt;Text&gt;Barang: {barang}&lt;/Text&gt;
            &lt;Button title="Kembali" onPress={() =&gt; navigation.goBack()} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = NativeStackScreenProps&lt;RootStackParamList, 'Detail'&gt;</code>: tipe props khusus untuk halaman Detail. Strukturnya dapat dilihat pada <a href="stack-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>route.params</code>: berisi data yang dikirim dari Home.</li>
<li><code>navigation</code>: digunakan untuk kembali atau pindah ke halaman lain.</li>
<li><code>const { id, barang } = route.params</code>: mengambil parameter id dan barang.</li>
</ul>
<p>Jadi, <code>DetailScreen.tsx</code> adalah halaman kedua yang menerima data dari Home dan bisa kembali ke halaman sebelumnya.</p>
<h3 id="TabNavigator.tsx"><a class="header" href="#TabNavigator.tsx">navigations/StackNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import HomeScreen from '../screens/HomeScreen';
import DetailScreen from '../screens/DetailScreen';

export type RootStackParamList = {
    Home: undefined,
    Detail: { id: number, barang: string }
}

const Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();

export default function StackNavigator() {
    return (
        &lt;Stack.Navigator initialRouteName="Home"
            screenOptions={{
                headerStyle: {
                    backgroundColor: '#f4511e',
                },
                headerTintColor: '#fff',
                headerTitleStyle: {
                    fontWeight: 'bold',
                },
            }}
        &gt;
            &lt;Stack.Screen
                name="Home"
                component={HomeScreen}
                options={{
                    title: 'Halaman Utama',
                }}
            /&gt;
            &lt;Stack.Screen
                name="Detail"
                component={DetailScreen}
                options={{ title: 'Detail Item' }}
            /&gt;
        &lt;/Stack.Navigator&gt;
    );
}
</code></pre>
<ul>
<li><code>RootStackParamList</code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Detail: { id: number, barang: string }</code>: Detail wajib menerima parameter id bertipe number dan barang bertipe string.</li>
</ul>
</li>
<li><code>createNativeStackNavigator&lt;RootStackParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Stack.Navigator</code>: mendefinisikan kumpulan screen.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/native-stack-navigator#options" target="_blank">halaman ini</a></li>
<li><code>Stack.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>options</code>: properti tambahan (misalnya judul di header).</li>
<li>API lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/stack-navigator/#api-definition" target="_blank">halaman ini</a></li>
</ul>
</li>
</ul>
<p>Jadi, <code>StackNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-2"><a class="header" href="#apptsx-2">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import StackNavigator from './navigations/StackNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;StackNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}

</code></pre>
<ul>
<li><code>NavigationContainer</code>: komponen utama dari React Navigation yang membungkus seluruh aplikasi. Tanpa ini, navigasi tidak dapat berjalan.</li>
<li><code>StackNavigator</code>: definisi struktur navigasi.</li>
</ul>
<p>Jadi, <code>App.tsx</code> adalah pintu masuk aplikasi yang menghubungkan navigasi dengan seluruh halaman.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bottom-tabs-navigation"><a class="header" href="#bottom-tabs-navigation">Bottom Tabs Navigation</a></h1>
<h2 id="konsep-dasar-1"><a class="header" href="#konsep-dasar-1">Konsep Dasar</a></h2>
<ul>
<li>Bottom Tabs navigation menampilkan menu tab di bawah layar.</li>
<li>Setiap tab adalah sebuah halaman (atau bahkan bisa berupa navigator lain seperti Stack).</li>
<li>Cocok untuk aplikasi dengan menu utama seperti: Home, Profile, Settings.</li>
<li>Karakteristiknya:
<ul>
<li>Tab yang aktif akan menampilkan screen terkait.</li>
<li>Navigasi antar tab tidak tumpukan (stack), jadi berpindah tab tidak menyimpan riwayat antar tab.</li>
<li>Bisa diberi ikon dan label untuk tiap tab.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi-1"><a class="header" href="#struktur-implementasi-1">Struktur Implementasi</a></h2>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── TabNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    ├── SearchScreen.tsx
    └── ProfileScreen.tsx
</code></pre>
<p>Struktur project di atas bukanlah aturan yang wajib diikuti. Struktur di atas menggunakan pendekatan modular karena:</p>
<ul>
<li>Maintainable: mudah diatur jika screen semakin banyak.</li>
<li>Scalable: mudah menambahkan jenis navigasi lainnya seperti Stack atau Drawer.</li>
<li>Clean code: App.tsx tetap terlihat ringkas.</li>
</ul>
<h2 id="instalasi-4"><a class="header" href="#instalasi-4">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/bottom-tabs
npx expo install @expo/vector-icons
</code></pre>
<h2 id="contoh-2"><a class="header" href="#contoh-2">Contoh</a></h2>
<h3 id="screenshomescreentsx-1"><a class="header" href="#screenshomescreentsx-1">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Button, Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Home'&gt;;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: "center", alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button title="Ke Profil" onPress={() =&gt; navigation.navigate('Profile')} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Profile')</code>: pindah ke halaman Profile.</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman Profile.</p>
<h3 id="screensprofilescreentsx"><a class="header" href="#screensprofilescreentsx">screens/ProfileScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Profile'&gt;;

export default function ProfileScreen({ }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Profil Screen&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Profile'&gt;</code>: mendefinisikan props khusus untuk halaman Profile, namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="bottom-tabs-navigation.html#TabNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="screenssettingscreentsx"><a class="header" href="#screenssettingscreentsx">screens/SettingScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Setting'&gt;;

export default function SettingScreen() {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Setting Screen&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Setting'&gt;</code>: mendefinisikan props khusus untuk halaman Profile, namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="bottom-tabs-navigation.html#TabNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="TabNavigator.tsx"><a class="header" href="#TabNavigator.tsx">navigations/TabNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import HomeScreen from "../screens/HomeScreen";
import ProfileScreen from "../screens/ProfileScreen";
import SettingScreen from "../screens/SettingScreen";
import { Ionicons } from "@expo/vector-icons";


export type RootParamList = {
    Home: undefined,
    Profile: undefined,
    Setting: undefined
};

const Tab = createBottomTabNavigator&lt;RootParamList&gt;();

export default function TabNavigator() {
    return (
        &lt;Tab.Navigator initialRouteName="Home"
            screenOptions={{
                headerShown: true,
                tabBarActiveTintColor: '#f4511e',
                tabBarInactiveTintColor: 'gray',
            }}
        &gt;
            &lt;Tab.Screen name="Home" component={HomeScreen} options={{
                title: "Halaman Utama",
                tabBarLabel: 'Home',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'home' : 'home-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
            &lt;Tab.Screen name="Profile" component={ProfileScreen} options={{
                title: "Halaman Profil",
                tabBarLabel: 'Profile',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'person' : 'person-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
            &lt;Tab.Screen name="Setting" component={SettingScreen} options={{
                title: "Halaman Setting",
                tabBarLabel: 'Home',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'settings' : 'settings-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
        &lt;/Tab.Navigator&gt;
    )
}
</code></pre>
<ul>
<li><code>RootParamList </code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Profile: undefined</code>: Profile tidak menerima parameter.</li>
<li><code>Setting: undefined</code>: Setting tidak menerima parameter.</li>
</ul>
</li>
<li><code>createBottomTabNavigator&lt;RootParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Tab.Navigator</code>: mendefinisikan kumpulan tab.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/bottom-tab-navigator/" target="_blank">halaman ini</a></li>
<li><code>Tab.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>options</code>: properti tambahan (misalnya judul di header dan icon tab).</li>
</ul>
</li>
</ul>
<p>Jadi, <code>TabNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-3"><a class="header" href="#apptsx-3">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import TabNavigator from './navigations/TabNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;TabNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawer-navigation"><a class="header" href="#drawer-navigation">Drawer Navigation</a></h1>
<h2 id="konsep-dasar-2"><a class="header" href="#konsep-dasar-2">Konsep Dasar</a></h2>
<ul>
<li>Drawer navigation menampilkan menu geser dari sisi kiri layar (kadang kanan).</li>
<li>Setiap item di drawer mengarah ke sebuah halaman atau bahkan ke navigator lain (Stack / Tabs).</li>
<li>Cocok untuk aplikasi dengan banyak menu yang tidak cukup untuk dimuat pada bottom tab, misalnya: <code>Home</code>, <code>Profile</code>, <code>Settings</code>, <code>About</code>.</li>
<li>Karakteristiknya:
<ul>
<li>Drawer dapat dimunculkan melalui gesture swipe atau tombol hamburger menu.</li>
<li>Drawer dapat dikustomisasi dengan menambahkan ikon, avatar, atau section.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi-2"><a class="header" href="#struktur-implementasi-2">Struktur Implementasi</a></h2>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── TabNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    ├── SearchScreen.tsx
    ├── SettingScreen.tsx
    └── ProfileScreen.tsx
</code></pre>
<p>Struktur project di atas bukanlah aturan yang wajib diikuti. Struktur di atas menggunakan pendekatan modular karena:</p>
<ul>
<li>Maintainable: mudah diatur jika screen semakin banyak.</li>
<li>Scalable: mudah menambahkan jenis navigasi lainnya seperti Stack atau Drawer.</li>
<li>Clean code: App.tsx tetap terlihat ringkas.</li>
</ul>
<h2 id="instalasi-5"><a class="header" href="#instalasi-5">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/drawer
npx expo install @expo/vector-icons
</code></pre>
<h2 id="contoh-3"><a class="header" href="#contoh-3">Contoh</a></h2>
<h3 id="screenshomescreentsx-2"><a class="header" href="#screenshomescreentsx-2">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Button, Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Home'&gt;;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button title="Profile" onPress={() =&gt; navigation.navigate('Profile', { id: 666, nama: 'John Doe' })} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Profile')</code>: pindah ke halaman Profile sekaligus mengirim data id = 666 dan barang = “John Doe”.</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman Profile dengan parameter.</p>
<h3 id="screensprofilescreentsx-1"><a class="header" href="#screensprofilescreentsx-1">screens/ProfileScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Profile'&gt;;

export default function ProfileScreen({ route, navigation }: Props) {
    const { id, nama } = route.params || {};
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 22 }}&gt;Ini adalah halaman profil, halo&lt;/Text&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;id: {id}&lt;/Text&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;nama: {nama}&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Profile'&gt;</code>: tipe props khusus untuk halaman Profile. Strukturnya dapat dilihat pada <a href="drawer-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>route.params</code>: berisi data yang dikirim dari Home.</li>
<li><code>navigation</code>: digunakan untuk kembali atau pindah ke halaman lain.</li>
<li><code>const { id, nama } = route.params</code>: mengambil parameter id dan nama.</li>
</ul>
<h3 id="screenssearchscreentsx"><a class="header" href="#screenssearchscreentsx">screens/SearchScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Search'&gt;;
export default function SearchScreen({ }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini adalah halaman search&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Search'&gt;</code>: tipe props khusus untuk halaman Profile. Namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="drawer-navigation.html#DrawerNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="screenssearchscreentsx-1"><a class="header" href="#screenssearchscreentsx-1">screens/SearchScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Setting'&gt;;

export default function SettingScreen() {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini adalah halaman setting&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Setting'&gt;</code>: tipe props khusus untuk halaman Profile. Namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="drawer-navigation.html#DrawerNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="DrawerNavigator.tsx"><a class="header" href="#DrawerNavigator.tsx">navigations/DrawerNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createDrawerNavigator } from "@react-navigation/drawer";
import HomeScreen from "../screens/HomeScreen";
import ProfileScreen from "../screens/ProfileScreen";
import SearchScreen from "../screens/SearchScreen";
import SettingScreen from "../screens/SettingScreen";

export type RootParamList = {
    Home: undefined,
    Profile: { id: number, nama: string },
    Search: undefined,
    Setting: undefined
};

const Drawer = createDrawerNavigator&lt;RootParamList&gt;();
export default function DrawerNavigator() {
    return (
        &lt;Drawer.Navigator
            initialRouteName="Home"
            screenOptions={{
                headerStyle: { backgroundColor: '#f4511e' },
                headerTintColor: '#fff',
                drawerActiveTintColor: '#f4511e',
                drawerInactiveTintColor: 'gray',
            }}
        &gt;
            &lt;Drawer.Screen name="Home" component={HomeScreen} /&gt;
            &lt;Drawer.Screen name="Profile" component={ProfileScreen} initialParams={{ id: 666, nama: "John Doe" }} /&gt;
            &lt;Drawer.Screen name="Search" component={SearchScreen} /&gt;
            &lt;Drawer.Screen name="Setting" component={SettingScreen} /&gt;
        &lt;/Drawer.Navigator&gt;
    );
}
</code></pre>
<ul>
<li><code>RootParamList </code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Profile: { id: number, nama: string }</code>: Profile wajib menerima parameter id bertipe number dan nama bertipe string.</li>
<li><code>Search: undefined</code>: Search tidak menerima parameter.</li>
<li><code>Setting: undefined</code>: Setting tidak menerima parameter.</li>
</ul>
</li>
<li><code>createDrawerNavigator&lt;RootParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Drawer.Navigator</code>: mendefinisikan kumpulan halaman.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/drawer-navigator/" target="_blank">halaman ini</a></li>
<li><code>Drawer.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>initialParams</code>: definisi parameter default</li>
</ul>
</li>
</ul>
<p>Jadi, <code>DrawerNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-4"><a class="header" href="#apptsx-4">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import DrawerNavigator from './navigations/DrawerNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;DrawerNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation"><a class="header" href="#animation">Animation</a></h1>
<p>Animasi merupakan salah satu aspek penting dalam memberikan nuansa hidup pada aplikasi. Dengan animasi, transisi antar komponen terasa lebih alami, interaksi lebih nyata, dan pengalaman pengguna meningkat.</p>
<p>React Native menyediakan dua pendekatan utama untuk membuat animasi:</p>
<ol>
<li><a href="animated-api.html">Animated API (built-in)</a> cocok untuk animasi sederhana &amp; state-driven.</li>
<li><a href="reanimated-gesture-handler.html">Reanimated library (eksternal)</a> lebih efisien &amp; mendukung gesture interaktif (digunakan di banyak app modern seperti Instagram).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animated-api"><a class="header" href="#animated-api">Animated API</a></h1>
<p><code>Animated</code> adalah API bawaan (tidak butuh instalasi tambahan) React Native untuk mengubah nilai tampilan secara halus dari satu keadaan ke keadaan lainnya. Cocok untuk animasi sederhana berbasis state, seperti:</p>
<ul>
<li>Fade in / fade out</li>
<li>Translasi (geser)</li>
<li>Skala (zoom)</li>
<li>Rotasi</li>
</ul>
<p><code>Animated</code> memiliki beberapa konsep utama yang perlu diketahui:</p>
<ul>
<li>
<p>Tidak seluruh komponen bawaan dari react native dapat menggunakan Animasi. Beberapa komponen yang dapat diberikan animasi adalah: <code>Animated.View</code>, <code>Animated.Text</code>, <code>Animated.Image</code>, <code>Animated.ScrollView</code>, <code>Animated.FlatList</code>, <code>Animated.SectionList</code>.</p>
<pre><code class="language-tsx">&lt;Animated.View style={{
    opacity: opacityAnim,
    width: 150,
    height: 150,
    backgroundColor: 'skyblue',
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
}}&gt;
</code></pre>
</li>
<li>
<p><code>Animated.Value()</code>: Menyimpan nilai numerik yang berubah seiring waktu. Nilai ini bisa dihubungkan ke properti <code>style</code> seperti <code>opacity</code>, <code>transform</code>, atau <code>position</code>. Biasanya disimpan menggunakan <code>hook</code> <code>useRef</code>.</p>
<pre><code class="language-tsx">const anim = useRef(new Animated.Value(0)).current;
</code></pre>
<p><code>Animated.Value</code> dapat dianggap seperti “state khusus animasi”. Nilainya bisa berubah secara bertahap oleh sistem animasi tanpa menyebabkan re-render React.</p>
</li>
<li>
<p><code>Animated.timing()</code>: Mengubah nilai dalam durasi tertentu. Method ini juga dapat kita berikan <code>delay</code> maupun <code>easing</code>. <code>Easing</code> merupakan kurva animasi yang dimulai dan diakhiri dengan perlahan, namun bergerak cepat di bagian tengahnya. Ini menghasilkan gerakan yang lebih halus dan natural, mirip dengan bagaimana objek di dunia nyata bergerak</p>
<pre><code class="language-tsx">Animated.timing(anim, {
    toValue: 1,        // nilai akhir animasi
    duration: 1000,    // dalam milidetik
    easing: Easing.bounce,  // kurva animasi
    delay:100,         // dalam milidetik
    useNativeDriver: true // untuk performa lebih baik
}).start();           // wajib agar animasi dijalankan
</code></pre>
<p>Konfigurasi lengkapnya dapat dilihat pada halaman <a href="https://reactnative.dev/docs/animated#timing">ini</a>. Sedangkan untuk jenis <code>easing</code> dapat dilihat pada halaman <a href="https://reactnative.dev/docs/easing">ini</a></p>
</li>
<li>
<p><code>Animated.decay()</code>: Membuat animasi yang dimulai dengan kecepatan awal yang diberikan, lalu melambat secara bertahap hingga berhenti sepenuhnya, meniru efek seperti gesekan.</p>
<pre><code class="language-tsx">Animated.decay(anim, {
    velocity: 0.5,          // kecepatan awal
    deceleration: 0.997,    // semakin kecil, semakin cepat berhenti
    useNativeDriver: true
}).start();

</code></pre>
</li>
<li>
<p><code>Animated.spring()</code>: Menciptakan efek pegas realistis seperti pantulan dan ayunan.</p>
<pre><code class="language-tsx">Animated.spring(anim, {
    toValue: 1,
    friction: 4,     // gesekan (semakin besar → lebih lambat)
    tension: 60,     // ketegangan pegas (semakin besar → lebih cepat)
    useNativeDriver: true
}).start();
</code></pre>
</li>
</ul>
<p>Beberapa Animasi dapat dikombinasikan menggunakan:</p>
<ul>
<li>
<p><code>Animated.sequence()</code>: Menyusun dan menjalankan animasi secara berurutan. Animasi dijalankan satu-persatu.</p>
<pre><code class="language-tsx">Animated.sequence([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.delay()</code>: Menciptakan jeda antar animasi.</p>
<pre><code class="language-tsx">Animated.sequence([
    Animated.decay()
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay()
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.parallel()</code>: Menjalankan beberapa animasi secara bersamaan.</p>
<pre><code class="language-tsx">Animated.parallel([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.stagger()</code>: Menjalankan rangkaian animasi dengan durasi jeda yang sama.</p>
<pre><code class="language-tsx">Animated.stagger(
    200, // delay antar animasi
    [
        Animated.timing(anim, {
            toValue: 1,
            duration: 1000,
            easing: Easing.bounce,
            useNativeDriver: true
        }),
        Animated.decay(anim, {
            velocity: 0.5,
            deceleration: 0.997,
            useNativeDriver: true
        })
    ]
).start();
</code></pre>
</li>
<li>
<p><code>Animated.loop()</code>: Mengulangi animasi secara terus menerus.</p>
<pre><code class="language-tsx">Animated.loop([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
</ul>
<h2 id="contoh-animasi"><a class="header" href="#contoh-animasi">Contoh: Animasi</a></h2>
<p>Struktur folder:</p>
<pre><code class="language-bash">/components
   ├── FadeBox.tsx
   ├── ScaleBox.tsx
   └── TranslateBox.tsx
/screens
   └── HomeScreen.tsx
App.tsx
</code></pre>
<p><strong>FadeBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, Text, View, Button } from "react-native";

export default function FadeBox() {
    const fadeAnim = useRef(new Animated.Value(0)).current;

    const fadeIn = () =&gt; {
        Animated.timing(fadeAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true
        }).start();
    }

    const fadeOut = () =&gt; {
        Animated.timing(fadeAnim, {
            toValue: 0,
            duration: 1000,
            useNativeDriver: true
        }).start()
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                opacity: fadeAnim,
                width: 150,
                height: 150,
                backgroundColor: 'skyblue',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Fade Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Fade In" onPress={fadeIn} /&gt;
                &lt;Button title="Fade Out" onPress={fadeOut} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const fadeAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>fadeAnim</code>, dan nantinya akan diubah oleh fungsi <code>fadeIn()</code> dan <code>fadeOut()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai fadeAnim tidak di-reset setiap kali komponen di-render ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini opacity) adalah 0, artinya komponen dimulai dalam keadaan transparan.</li>
</ul>
<p><code>fadeIn()</code> memiliki beberapa property, yaitu:</p>
<ul>
<li><code>Animated.timing()</code> mengatur perubahan nilai animasi secara bertahap.</li>
<li><code>toValue: 1</code> artinya fadeAnim akan meningkat dari 0 → 1, membuat komponen semakin terlihat.</li>
<li><code>duration: 1000</code> menunjukkan animasi berlangsung selama 1 detik (1000 ms).</li>
<li><code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</li>
</ul>
<p><code>fadeOut()</code> memiliki beberapa property yang serupa dengan fungsi fadeIn(). Perbedaan terletak pada nilai dari property <code>toValue: 1</code> yang menunjukkan <code>opacity</code> akan turun dari 1 → 0.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>opacity</code> dihubungkan langsung ke <code>fadeAnim</code>. Saat <code>fadeAnim</code> berubah, React Native akan otomatis menyesuaikan opacity komponen atau membuat efek fade in dan fade out.</p>
<p><strong>ScaleBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, View, EasingFunction, Text, Button, Easing } from "react-native";

export default function ScaleBox() {
    const scaleAnim = useRef(new Animated.Value(0)).current;

    const zoomIn = () =&gt; {
        Animated.spring(scaleAnim, {
            toValue: 1,
            friction: 2,
            tension: 40,
            useNativeDriver: true
        }).start()
    }

    const zoomOut = () =&gt; {
        Animated.spring(scaleAnim, {
            toValue: 0,
            friction: 4,
            tension: 60,
            useNativeDriver: true
        }).start()
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                transform: [
                    { scale: scaleAnim }
                ],
                width: 150,
                height: 150,
                backgroundColor: '#87eba2',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Slide Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Zoom In" onPress={zoomIn} /&gt;
                &lt;Button title="Zoom Out" onPress={zoomOut} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const scaleAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>scaleAnim</code>, dan nantinya akan diubah oleh fungsi <code>zoomIn()</code> dan <code>zoomOut()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai scaleAnim tidak di-reset setiap kali komponen di-render ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini scale) adalah 0, artinya komponen dimulai dalam ukuran (scale) yang kecil.</li>
</ul>
<p><code>zoomIn()</code> memiliki beberapa property, yaitu:
- <code>Animated.spring()</code> untuk menghasilkan efek pegas (spring motion).
- <code>toValue: 1</code> artinya sacleAnim akan meningkat dari 0 → 1, membuat komponen kembali ke ukuran normal.
- <code>friction</code> mengontrol gesekan. Semakin tinggi nilainya, maka semakin cepat animasi berhenti.
- <code>tension</code> mengontrol daya tarik pegas. Semakin besar nilainya, semakin cepat pergerakan awal animasi.
- <code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</p>
<p><code>zoomOut()</code> memiliki beberapa property yang serupa dengan fungsi zoomIn(). Perbedaan terletak pada nilai dari property <code>toValue: 1</code> yang menunjukkan <code>scale</code> akan turun dari 1 → 0.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>transform</code> dengan <code>{scale: scaleAnim}</code> dihubungkan langsung ke <code>scaleAnim</code>. Saat <code>sacleAnim</code> berubah, React Native akan otomatis menyesuaikan ukuran (<code>scale</code>) komponen.</p>
<p><strong>TranslateBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, Text, View, Button } from "react-native";

export default function TranslatedBox() {
    const slideAnim = useRef(new Animated.Value(0)).current;

    const startDecay = () =&gt; {
        Animated.decay(slideAnim, {
            velocity: 1.5,
            deceleration: 0.997,
            useNativeDriver: true
        }).start();
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                transform: [
                    { translateY: slideAnim }
                ],
                width: 150,
                height: 150,
                backgroundColor: '#87eba2',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Slide Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Start deacy" onPress={startDecay} /&gt;
                &lt;Button title="Reset deacy" onPress={() =&gt; slideAnim.setValue(0)} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const slideAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>slideAnim</code>, dan nantinya akan diubah oleh fungsi <code>startDecay()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai <code>slideAnim</code> tidak di-<em>reset</em> setiap kali komponen di-<em>render</em> ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini posisi) adalah 0, artinya komponen dimulai dalam posisi awal yaitu 0.</li>
</ul>
<p><code>startDecay()</code> memiliki beberapa property, yaitu:
- <code>Animated.decay()</code> untuk menghasilkan animasi yang berhenti secara alami seperti benda yang bergerak lalu melambat karena gaya gesek.
- <code>velocity: 1</code> konfigurasi kecepatan awal animasi. Semakin tinggi nilainya, maka semakin cepat animasi bergerak.
- <code>deceleration</code> mengontrol laju perlambatan. Semakin tinggi nilainya (mendekati 1), maka gerakan berhenti lebih lambat.
- <code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>transform</code> dengan <code>{translateY: scaleAnim}</code> dihubungkan langsung ke <code>slideAnim</code>. Saat <code>slideAnim</code> berubah, React Native akan otomatis menyesuaikan posisi (<code>translateY</code>) komponen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reanimated-api"><a class="header" href="#reanimated-api">Reanimated API</a></h1>
<p>Merupakan library pihak ketiga untuk membuat animasi dengan performa tinggi di React Native. Reanimated memungkinkan kita untuk menjalankan logika animasi langsung di native thread, sehingga animasi tetap halus bahkan ketika JavaScript thread sibuk. <code>Reanimated</code> sangat cocok digunakan untuk animasi interaktif dan kompleks seperti:</p>
<ul>
<li>Drag &amp; drop</li>
<li>Gesture-based animations (dengan <code>react-native-gesture-handler</code>)</li>
<li>Scroll animations</li>
<li>Transition antar halaman</li>
</ul>
<p>Sebelum menggunakan <a href="https://docs.swmansion.com/react-native-reanimated/"><code>Reanimated</code></a>, terdapat beberapa hal yang perlu dilakukan yaitu instalasi dependency dan melakukan rebuild plugin.</p>
<h2 id="instalasi-6"><a class="header" href="#instalasi-6">Instalasi</a></h2>
<pre><code class="language-bash">npm install react-native-reanimated react-native-worklets
</code></pre>
<h2 id="rebuild"><a class="header" href="#rebuild">Rebuild</a></h2>
<h3 id="expo-1"><a class="header" href="#expo-1">Expo</a></h3>
<p>Jalankan perintah berikut pada terminal</p>
<pre><code class="language-bash">npx expo prebuild
</code></pre>
<h3 id="react-native-cli-2"><a class="header" href="#react-native-cli-2">React Native CLI</a></h3>
<p>Tambahkan plugin <code>react-native-worklets/plugin</code> secara manual pada file <code>babel.config.js</code>. Pastikan <code>react-native-worklets/</code> berada di baris paling akhir.</p>
<pre><code class="language-js">module.exports = {
presets: [
    ... // don't add it here :)
],
plugins: [
    ...
    'react-native-worklets/plugin',
],
};
</code></pre>
<p>Khusus penggunaan <code>web</code> yang dibangun menggunakan React native CLI, selain wajib menambahkan <code>react-native-web</code> dan <code>react-dom</code>, kita perlu menambahkan plugin <code>@babel/plugin-proposal-export-namespace-from</code> lalu rebuild dengan cara menambahkan plugin tersebut ke <code>babel.config.js</code>.</p>
<pre><code class="language-bash">npm install @babel/plugin-proposal-export-namespace-from
</code></pre>
<pre><code class="language-js">module.exports = {
    presets: [
    ... // don't add it here :)
    ],
    plugins: [
        ...
        '@babel/plugin-proposal-export-namespace-from',
        'react-native-worklets/plugin',
    ],
};
</code></pre>
<h3 id="reanimated-memiliki-beberapa-konsep-dasar-yang-perlu-diketahui"><a class="header" href="#reanimated-memiliki-beberapa-konsep-dasar-yang-perlu-diketahui"><code>Reanimated</code> memiliki beberapa konsep dasar yang perlu diketahui:</a></h3>
<h3 id="usesharedvalue"><a class="header" href="#usesharedvalue"><code>useSharedValue</code></a></h3>
<p>Digunakan untuk menginisialisasi nilai numerik yang bisa berubah tanpa menyebabkan re-<em>render</em> React. Mirip seperti <code>Animated.Value()</code>, tapi lebih efisien karena berjalan di native thread. Untuk mengakses data pada <em>shared value</em>, kita dapat menggunakan property <code>value</code>.</p>
<pre><code class="language-tsx">const animation_value = useSharedValue(0);  // inisialisasi shared value
animation_value.value = 1; // mengubah shared value

const animation_value = useSharedValue({x: 0, y: 0});  // inisialisasi shared value
animation_value.value = {x: 50, y: -20}; // mengubah shared value

const animation_value = useSharedValue([1, 2, 3]);  // inisialisasi shared value
animation_value.value.push(4);
animation_value.value = [...animation_value.value, 1000]
</code></pre>
<h3 id="withtiming"><a class="header" href="#withtiming"><code>withTiming</code></a></h3>
<p>Merupakan fungsi animasi yang dimiliki oleh Reanimated dan berfungsi untuk membuat nilai <code>shared value</code> berubah secara bertahap dari nilai awal ke nilai target selama periode tertentu. Selain itu, kita juga dapat mengatur kecepatan animasi melalui <code>Easing</code>.</p>
<pre><code class="language-tsx">import { Easing, ReduceMotion } from 'react-native-reanimated';

withTiming(shared_value.value, {
    duration: 1000,  // dalam milisecond
    easing: Easing.inOut(Easing.quad),  
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<p><strong>Contoh:</strong></p>
<pre><code class="language-tsx">const scale_animation = useSharedValue(0);

const startScaleAnimation = () =&gt; {
    scale_animation.value = withTiming(scale_animation.value === 1 ? 1.5 : 1, { 
        duration: 500,
        easing: Easing.inOut(Easing.quad),  
        reduceMotion: ReduceMotion.System,
    });
}
</code></pre>
<h3 id="withspring"><a class="header" href="#withspring"><code>withSpring</code></a></h3>
<p>Merupakan fungsi yang digunakan untuk membuat animasi yang meniru gerakan pegas. Artinya, nilai akan bergerak menuju target (toValue), namun dengan sedikit pantulan (overshoot) dan perlambatan alami di akhir.</p>
<pre><code class="language-tsx">withSpring(shared_value.value, {
    stiffness: 900,
    damping: 120,
    mass: 4,
    overshootClamping: false,
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li><code>stiffness</code>: Kekuatan pegas (semakin besar = gerakan lebih cepat dan kuat) (default = 900)</li>
<li><code>damping</code>: Mengatur seberapa cepat gerakan melambat (semakin besar = lebih cepat berhenti) (default = 120)</li>
<li><code>mass</code>: Berat objek (semakin besar = gerakan lebih lambat) (default = 4)</li>
<li><code>overshootClamping</code>: Jika true, tidak akan memantul melewati target (default = false)</li>
</ul>
<p>Konfigurasi lainnya dari fungsi <code>withSpring</code> dapat dilihat pada <a href="https://docs.swmansion.com/react-native-reanimated/docs/animations/withSpring">laman resmi</a></p>
<p><strong>Contoh:</strong></p>
<pre><code class="language-tsx">const scale_animation = useSharedValue(0);

const startScaleAnimation = () =&gt; {
    scale_animation.value = withSpring(scale_animation.value === 1 ? 1.5 : 1, { 
        stiffness: 900,
        damping: 120,
        mass: 4,
        overshootClamping: false,
        reduceMotion: ReduceMotion.System,
    });
}
</code></pre>
<h3 id="withdecay"><a class="header" href="#withdecay"><code>withDecay</code></a></h3>
<p>Digunakan untuk membuat animasi yang terus bergerak ke arah tertentu dengan kecepatan awal, lalu melambat hingga berhenti secara alami.</p>
<pre><code class="language-tsx">withDecay({
    velocity: event.velocityX,
    deceleration: 0.998,
    clamp: [-300, 300],
    velocityFactor: 1,
    rubberBandEffect: true,
    rubberBandFactor: 0.6,
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li><code>velocity</code>: kecepatan awal gerakan (default = 0).</li>
<li><code>deceleration</code>: Nilai mendekati 1 membuat animasi melambat dengan lembut dan berjalan lebih lama, sedangkan nilai kecil (misal 0.95) membuat animasi cepat berhenti (default = 0.998).</li>
<li><code>clamp</code>: Batas minimum dan maksimum posisi. Ketika posisi hasil decay melewati nilai ini, maka animasi akan berhenti di batas tersebut. Contoh [-300, 300] artinya posisi hanya boleh di antara -300 hingga 300.</li>
<li><code>velocityFactor</code>: Faktor pengali untuk kecepatan awal (<code>velocity</code>). Gunanya untuk mengatur seberapa jauh atau seberapa cepat gerakan decay dimulai tanpa harus mengubah velocity langsung (default = 1).</li>
<li><code>rubberBandEffect</code>: menambahkan efek pantulan yang lembut seperti “karet” (default = false)</li>
<li><code>rubberBandFactor</code>: Mengatur seberapa kuat efek pantulan pada <code>rubberBandEffect</code>. Semakin kecil maka pantulan lebih kuat sedangkan semakin besar (lebih elastis) maka pantulan lebih kaku (cepat berhenti) (default = 0.6).</li>
</ul>
<p><strong>Contoh:</strong></p>
<pre><code class="language-tsx">const scale_animation = useSharedValue(0);

const startScaleAnimation = () =&gt; {
    scale_animation.value = withDecay({ 
        velocity: event.velocityX,
        deceleration: 0.998,
        clamp: [0, 300],
        velocityFactor: 1,
        rubberBandEffect: true,
        rubberBandFactor: 0.6,
        reduceMotion: ReduceMotion.System,
    });
}
</code></pre>
<h3 id="withsequence"><a class="header" href="#withsequence"><code>withSequence</code></a></h3>
<p>Digunakan untuk menjalankan beberapa animasi satu per satu (secara berurutan) bukan bersamaan. Umumnya digunakan bersama <code>withTiming()</code>, <code>withSpring()</code>, dan <code>withDecay()</code> untuk membentuk efek kompleks.</p>
<pre><code class="language-tsx">withSequence(animation1, animation2, animation3, ...)
</code></pre>
<p><em>Penjelasan</em>
Setiap <code>animation</code> bisa berupa <code>withTiming()</code>, <code>withSpring()</code>, <code>withDecay()</code> atau bahkan <code>withDelay()</code> jika ingin memiliki jeda waktu di antaranya.</p>
<pre><code class="language-tsx">translateX.value = withSequence(
  withTiming(100, { duration: 500 }),
  withTiming(-100, { duration: 500 }),
  withTiming(0, { duration: 500 })
);
</code></pre>
<p><strong>Contoh:</strong></p>
<pre><code class="language-tsx">const scale_animation = useSharedValue(0);
const startScaleAnimation = () =&gt; {
    scale_animation.value = withSequence(
        withTiming(1.5, { duration: 300 }),
        withSpring(1, { damping: 5 }
    ;)
}
</code></pre>
<h3 id="withrepeat"><a class="header" href="#withrepeat"><code>withRepeat</code></a></h3>
<p>Digunakan untuk menjalankan animasi secara berulang, baik dalam jumlah tertentu maupun tanpa batas (infinite loop). Biasanya digunakan untuk membuat animasi loading atau spinner.</p>
<pre><code class="language-tsx">withRepeat(animation, numberOfReps?, reverse?, callback?)
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li>animation: animasi yang akan diulang (biasanya menggunakan <code>withTiming</code> atau <code>withSpring</code>)</li>
<li>numberOfReps: jumlah pengulangan animasi. Gunakan -1 untuk infinite loop. (default = 2)</li>
<li>reverse: jika <code>true</code>, animasi akan membalik arah setiap kali mengulang. (default = <code>false</code>)</li>
<li>callback: fungsi yang dipanggil ketika animasi selesai (jika finite)</li>
</ul>
<pre><code class="language-tsx">withRepeat(
    withTiming(200, { duration: 1000 }),
    2,
    false,
    () =&gt; {},
    ReduceMotion.System,
)
</code></pre>
<h3 id="withdelay"><a class="header" href="#withdelay"><code>withDelay</code></a></h3>
<p>Digunakan untuk memberikan penundaan (delay) pada animasi sebelum dijalankan. Bisanya dipakai untuk menjalankan animasi yang berurutan atau bisa juga digunakan untuk memberi jeda antar efek.</p>
<pre><code class="language-tsx">withDelay(delay, animation)
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li>delay: durasi penundaan dalam milidetik sebelum animasi dimulai</li>
<li>animation: animasi yang ingin dijalankan setelah delay (biasanya <code>withTiming</code>, <code>withSpring</code>, dll)</li>
</ul>
<pre><code class="language-tsx">opacity.value = withDelay(
    1000, // tunggu 1 detik
    withTiming(1, { duration: 1000 })
);
</code></pre>
<h3 id="useanimatedstyle"><a class="header" href="#useanimatedstyle"><code>useAnimatedStyle</code></a></h3>
<p>Digunakan untuk membuat <code>object style</code> animasi. Mirip seperti <code>StyleSheet</code> namun, nilainya diambil dari <em>shared value</em>. Setiap kali nilai berubah, style akan diperbarui otomatis di native layer.</p>
<pre><code class="language-tsx">const opacity = useSharedValue(0);
const scale = useSharedValue(0.5);

const animatedStyle = useAnimatedStyle(() =&gt; {
  return { 
    opacity: opacity.value,
    transform: [{ scale: scale.value }],
  };
});
</code></pre>
<p>Kemudian digunakan di komponen Animated.<Component> seperti ini (misalnya pada komponen View):</p>
<pre><code class="language-tsx">const opacity = useSharedValue(0);
const scale = useSharedValue(0.5);

const animatedStyle = useAnimatedStyle(() =&gt; {
  return { 
    opacity: opacity.value,
    transform: [{ scale: scale.value }],
  };
});

&lt;Animated.View style={[
    {
        width: 120,
        height: 120,
        backgroundColor: 'skyblue',
        borderRadius: 10,
    },
    animatedStyle,
    ]}
/&gt;
</code></pre>
<h3 id="useanimatedprops"><a class="header" href="#useanimatedprops"><code>useAnimatedProps</code></a></h3>
<p>Digunakan untuk memberikan animasi pada properti (props) komponen yang bukan bagian dari style. Berbeda dengan <code>useAnimatedStyle</code> yang hanya bisa digunakan untuk properti style, <code>useAnimatedProps</code> memungkinkan kita menganimasikan atribut seperti:</p>
<ul>
<li><code>progress</code> pada <code>Animated.ProgressBar</code></li>
<li><code>strokeDashoffset</code> pada elemen <code>SVG</code></li>
<li><code>text</code> pada <code>Animated.TextInput</code></li>
<li><code>value</code> atau <code>scrollOffset</code> pada beberapa komponen bawaan
Animasi dijalankan langsung di native thread, sehingga komponen tidak mengalami re-render di sisi JavaScript — hasilnya, animasi menjadi lebih halus dan efisien.</li>
</ul>
<pre><code class="language-tsx">const textValue = useSharedValue('Hello');

const animatedProps = useAnimatedProps(() =&gt; {
  return {
    text: textValue.value,
  };
});

const changeText = () =&gt; {
    textValue.value = withTiming(
        textValue.value === 'Hello' ? 'Reanimated' : 'Hello',
        {duration: 600}
    )
}
</code></pre>
<p>Kemudian digunakan di komponen Animated.<Component> seperti ini (misalnya pada komponen View):</p>
<pre><code class="language-tsx">const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;AnimatedTextInput
        style={{
            fontSize: 24,
            color: 'black',
            borderWidth: 1,
            borderColor: '#aaa',
            padding: 10,
            textAlign: 'center',
            width: 200,
        }}
        editable={false}
        animatedProps={animatedProps}
    /&gt;
    &lt;Button title="Ubah Teks" onPress={changeText} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="animated-component"><a class="header" href="#animated-component">Animated Component</a></h3>
<p><code>Reanimated</code> memiliki beberapa komponen yang dapat diberikan animasi adalah: <code>Animated.View</code>, <code>Animated.Text</code>, <code>Animated.Image</code>, <code>Animated.ScrollView</code>, <code>Animated.FlatList</code>, <code>Animated.SectionList</code>.</p>
<pre><code class="language-tsx">const opacityAnim = useSharedValue(0);

const animatedStyle = useAnimatedStyle(() =&gt; ({
    opacity: opacityAnim.value,
}));

const toggleOpacity = () =&gt; {
    opacityAnim.value = withTiming(opacityAnim.value === 1 ? 0 : 1, {
      duration: 800,
    });
};

return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Animated.View
        style={[
          {
            width: 150,
            height: 150,
            backgroundColor: 'skyblue',
            borderRadius: 10,
            justifyContent: 'center',
            alignItems: 'center',
          },
          animatedStyle,
        ]}
      /&gt;
      &lt;Button title="Toggle Fade" onPress={toggleOpacity} /&gt;
    &lt;/View&gt;
);
</code></pre>
<p>Selain komponen di atas, kita juga dapat membuat komponen kustom <em>animatable</em> menggunakan <code>Animated.createAnimatedComponent()</code>.</p>
<pre><code class="language-tsx">import React from 'react';
import { View, Text } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';

// Komponen kustom biasa
const Box = ({ color }: { color: string }) =&gt; (
  &lt;View
    style={{
      width: 100,
      height: 100,
      borderRadius: 10,
      backgroundColor: color,
      justifyContent: 'center',
      alignItems: 'center',
    }}
  &gt;
    &lt;Text style={{ color: 'white', fontWeight: 'bold' }}&gt;BOX&lt;/Text&gt;
  &lt;/View&gt;
);

// Ubah menjadi komponen animatable
const AnimatedBox = Animated.createAnimatedComponent(Box);

export default function CustomAnimatedComponentExample() {
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() =&gt; ({
    transform: [{ scale: scale.value }],
  }));

  const animateBox = () =&gt; {
    scale.value = withSpring(scale.value === 1 ? 1.5 : 1);
  };

  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;AnimatedBox color="tomato" style={animatedStyle} /&gt;
      &lt;Button title="Animate Box" onPress={animateBox} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Konsep penting lainnya dari Reanimated dapat diakses pada <a href="https://docs.swmansion.com/react-native-reanimated">laman resmi</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-storage"><a class="header" href="#local-storage">Local Storage</a></h1>
<p>Banyak aplikasi membutuhkan mekanisme untuk menyimpan data pada perangkat pengguna bahkan setelah aplikasi ditutup atau perangkat di-<em>restart</em>. Tidak seperti <code>state</code> atau <code>context</code> yang hanya bertahan selama aplikasi berjalan, local storage memungkinkan data disimpan secara persisten.</p>
<p>Contoh penggunaan local storage dalam aplikasi mobile diantaranya:</p>
<ul>
<li>menyimpan status login pengguna (misalnya token atau flag “sudah login”),</li>
<li>menyimpan preferensi atau pengaturan aplikasi (seperti tema dan bahasa),</li>
<li>menyimpan draft data atau cache,</li>
<li>menyimpan daftar item sederhana seperti riwayat pencarian, keranjang belanja, atau tema aplikasi.</li>
</ul>
<p>React Native menyediakan beberapa library untuk penyimpanan data lokal, di antaranya:</p>
<ol>
<li><a href="asynchronous-storage.html"><strong>AsyncStorage</strong></a>: penyimpanan key-value sederhana, cocok untuk data kecil seperti token, settings, atau flag boolean.</li>
<li><strong><a href="secure-store.html">SecureStore</a></strong>: menyimpan data sensitif seperti token atau password dengan enkripsi.</li>
<li><strong><a href="mmkv.html">MMKV</a></strong>: solusi key-value storage modern yang sangat cepat dengan performa tinggi.</li>
<li><strong><a href="sqlite.html">SQLite</a></strong>: cocok untuk penyimpanan data kompleks seperti tabel, relasi, atau jumlah data besar.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-storage"><a class="header" href="#asynchronous-storage">Asynchronous Storage</a></h1>
<p>Menyimpan data secara lokal di perangkat pengguna menggunakan format key–value. Berbeda dengan <code>localStorage</code> pada web yang bersifat <strong>sinkron</strong>, <code>AsyncStorage</code> bersifat <strong>asinkron</strong> dan berjalan secara efisien di perangkat mobile. Data yang disimpan menggunakan <code>AsyncStorage</code> akan tetap ada meskipun aplikasi ditutup atau perangkat direstart.</p>
<p><code>AsyncStorage</code> sangat cocok digunakan untuk:</p>
<ul>
<li>Menyimpan token autentikasi (login session)</li>
<li>Menyimpan preferensi aplikasi (tema, bahasa, settings)</li>
<li>Cache ringan (misalnya data hasil fetch)</li>
<li>Menyimpan daftar recent items atau history</li>
</ul>
<p>Sebelum menggunakan <a href="https://react-native-async-storage.github.io/2.0/"><code>AsyncStorage</code></a>, terdapat beberapa hal yang perlu dilakukan yaitu instalasi dependency dan melakukan rebuild plugin.</p>
<h2 id="instalasi-7"><a class="header" href="#instalasi-7">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install @react-native-async-storage/async-storage
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install @react-native-async-storage/async-storage
cd android &amp;&amp; ./gradlew clean &amp;&amp; cd ..
</code></pre>
<h3 id="api-dasar-asyncstorage"><a class="header" href="#api-dasar-asyncstorage">API Dasar AsyncStorage</a></h3>
<p>AsyncStorage menyediakan beberapa API utama:</p>
<div class="table-wrapper"><table><thead><tr><th>Kebutuhan</th><th>Fungsi</th></tr></thead><tbody>
<tr><td>Menyimpan data</td><td><code>setItem(key: string, value: string)</code></td></tr>
<tr><td>Mengambil data</td><td><code>getItem(key:string)</code></td></tr>
<tr><td>Menghapus data</td><td><code>removeItem(key:string)</code></td></tr>
<tr><td>Menghapus semua data</td><td><code>clear()</code></td></tr>
<tr><td>Menyimpan banyak data sekaligus</td><td><code>multiSet(keyValuePairs: Array&lt;Array&lt;string&gt;&gt;)</code></td></tr>
<tr><td>Mengambil banyak data sekaligus</td><td><code>multiGet(keys: Array&lt;string&gt;)</code></td></tr>
<tr><td>Menghapus beberapa data sekaligus</td><td><code>multiRemove(keys: Array&lt;string&gt;)</code></td></tr>
</tbody></table>
</div>
<p>Semua data harus berupa string. Untuk object gunakan:</p>
<pre><code class="language-js">JSON.stringify() // saat menyimpan
JSON.parse()      // saat membaca
</code></pre>
<h3 id="setitem---menyimpan-data"><a class="header" href="#setitem---menyimpan-data"><code>setItem</code> - Menyimpan Data</a></h3>
<pre><code class="language-tsx">import AsyncStorage from '@react-native-async-storage/async-storage';

const saveUser = async () =&gt; {
  const user = { name: 'John Doe', age: 27 };
  await AsyncStorage.setItem('user', JSON.stringify(user));
};
</code></pre>
<h3 id="getitem---mengambil-data"><a class="header" href="#getitem---mengambil-data"><code>getItem</code> - Mengambil Data</a></h3>
<pre><code class="language-tsx">const loadUser = async () =&gt; {
  const jsonValue = await AsyncStorage.getItem('user');
  return jsonValue != null ? JSON.parse(jsonValue) : null;
};
</code></pre>
<h3 id="removeitem---menghapus-data"><a class="header" href="#removeitem---menghapus-data"><code>removeItem</code> - Menghapus Data</a></h3>
<pre><code class="language-tsx">const deleteUser = async () =&gt; {
  await AsyncStorage.removeItem('user');
};
</code></pre>
<h3 id="clear---menghapus-data"><a class="header" href="#clear---menghapus-data"><code>clear</code> - Menghapus Data</a></h3>
<pre><code class="language-tsx">const clearUser = async () =&gt; {
  await AsyncStorage.clear();
};
</code></pre>
<h3 id="multiset---menyimpan-banyak-data"><a class="header" href="#multiset---menyimpan-banyak-data"><code>multiSet</code> - Menyimpan Banyak Data</a></h3>
<pre><code class="language-tsx">import AsyncStorage from '@react-native-async-storage/async-storage';

const saveMultiUser = async () =&gt; {
  await AsyncStorage.multiSet([
    ['user:1', JSON.stringify({ name: 'John', age: 27 })],
    ['user:2', JSON.stringify({ name: 'Doe', age: 30 })],
  ]);
};
</code></pre>
<h3 id="multiget---mengambil-mutli-data"><a class="header" href="#multiget---mengambil-mutli-data"><code>multiGet</code> - Mengambil Mutli Data</a></h3>
<pre><code class="language-tsx">import AsyncStorage from '@react-native-async-storage/async-storage';

const getMultiUser = async () =&gt; {
  const values = await AsyncStorage.multiGet(['user:1', 'user:2']);

  const users = values.map(([key, value]) =&gt; JSON.parse(value));
  return users;
};
</code></pre>
<h3 id="multiremove---menghapus-mutli-data"><a class="header" href="#multiremove---menghapus-mutli-data"><code>multiRemove</code> - Menghapus Mutli Data</a></h3>
<pre><code class="language-tsx">import AsyncStorage from '@react-native-async-storage/async-storage';

const removeMultiUser = async () =&gt; {
  const keys = ['user:1', 'user:2'];
  await AsyncStorage.multiRemove(keys);
};
</code></pre>
<h3 id="contoh-theme-manager"><a class="header" href="#contoh-theme-manager">Contoh: Theme Manager</a></h3>
<p>Menggunakan AsyncStorage untuk menyimpan pilihan tema (light/dark) sehingga tema tetap tersimpan meskipun aplikasi ditutup. Agar lebih rapi dan scalable, kita menggunakan:</p>
<ul>
<li><strong>Context API</strong> → menyimpan state tema</li>
<li><strong>AsyncStorage</strong> → menyimpan tema secara persistent</li>
<li><strong>ThemeStyle generator</strong> → menghasilkan style sesuai tema</li>
<li><strong>GlobalThemeStyle</strong> → definisi warna untuk light/dark</li>
</ul>
<p>Struktur folder:</p>
<pre><code class="language-bash">/src
  ├── context
  |      └── ThemeContext.tsx
  ├── screens
  |      └── HomeScreen.tsx
  ├── styles
  |      └── GlobalThemeStyle.ts
  └── utils
         └── ThemeStyle.tsx
App.tsx
</code></pre>
<p><strong>ThemeContext.tsx</strong></p>
<pre><code class="language-tsx">import AsyncStorage from "@react-native-async-storage/async-storage";
import React, { createContext, useContext, useEffect, useState } from "react";

type ThemeType = 'light' | 'dark';
interface ThemeContextProps {
    theme: ThemeType,
    toggleTheme: () =&gt; void;
};

const ThemeContext = createContext&lt;ThemeContextProps | undefined&gt;(undefined);

export const ThemeProvider = ({ children }: { children: React.ReactNode }) =&gt; {
    const [theme, setTheme] = useState&lt;ThemeType&gt;('light');

    useEffect(() =&gt; {
        const loadTheme = async () =&gt; {
            const stored = await AsyncStorage.getItem('app_theme');
            if (stored === 'light' || stored === 'dark') {
                setTheme(stored);
            }
        };

        loadTheme();
    }, []);

    const toggleTheme = async () =&gt; {
        const newTheme = theme === 'light' ? 'dark' : 'light';

        setTheme(newTheme);
        await AsyncStorage.setItem('app_theme', newTheme);
    };

    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
}


export const useTheme = () =&gt; {
    const ctx = useContext(ThemeContext);
    if (!ctx) throw new Error("useTheme must be used within ThemeProvider");
    return ctx;
};
</code></pre>
<p><strong>HomeScreen.tsx</strong></p>
<pre><code class="language-tsx">import { Text, View, TouchableOpacity } from "react-native";
import { useTheme } from "../context/ThemeContext";
import { DarkTheme, LightTheme } from "../styles/GlobalThemeStyle";
import { createThemeStyle } from "../utils/ThemeStyle";

export default function HomeScreen() {
    const { theme, toggleTheme } = useTheme();
    const colors = theme === "light" ? LightTheme.colors : DarkTheme.colors;
    const styles = createThemeStyle(colors);


    return (
        &lt;View style={styles.container}&gt;
            &lt;Text style={styles.text}&gt;Tema saat ini: {theme.toUpperCase()}&lt;/Text&gt;

            &lt;View style={styles.card}&gt;
                &lt;Text style={styles.text}&gt;Card ini berubah sesuai tema 🎨&lt;/Text&gt;
            &lt;/View&gt;

            &lt;TouchableOpacity style={styles.button} onPress={toggleTheme}&gt;
                &lt;Text style={styles.buttonText}&gt;Ganti Tema&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><strong>GlobalThemeStyle.ts</strong></p>
<pre><code class="language-tsx">export const LightTheme = {
    colors: {
        background: '#ffffff',
        text: '#000000',
        card: '#f0f0f0',
        button: '#8CA9FF'
    },
};

export const DarkTheme = {
    colors: {
        background: '#000000',
        text: '#ffffff',
        card: '#222222',
        button: '#16476A'
    },
};
</code></pre>
<p><strong>ThemeStyle.tsx</strong></p>
<pre><code class="language-tsx">import { StyleSheet } from "react-native"


export const createThemeStyle = (colors: any) =&gt; {
    return StyleSheet.create({
        container: {
            flex: 1,
            backgroundColor: colors.background,
            padding: 20,
        },
        text: {
            color: colors.text,
            fontSize: 18,
        },
        card: {
            backgroundColor: colors.card,
            padding: 16,
            borderRadius: 12,
            marginTop: 20,
        },
        button: {
            padding: 12,
            marginTop: 20,
            borderRadius: 10,
            backgroundColor: colors.button,
            alignItems: "center",
        },
        buttonText: {
            color: colors.text,
            fontWeight: "600",
        },
    });
}
</code></pre>
<p><strong>App.tsx</strong></p>
<pre><code class="language-tsx">import AsyncStorage from '@react-native-async-storage/async-storage';
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';
import { ThemeProvider } from './src/context/ThemeContext';
import HomeScreen from './src/screens/HomeScreen';

export default function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;HomeScreen /&gt;
    &lt;/ThemeProvider&gt;
  );
}
</code></pre>
<!-- ### Contoh 2: Simulasi Login dan Simpan Token
Menggunakan AsyncStorage untuk menyimpan token autentikasi token tetap tersimpan meskipun aplikasi ditutup. Agar lebih rapi dan scalable, kita menggunakan: 

- **Context API** → menyimpan state token
- **AsyncStorage** → menyimpan token secara persistent
- **Navigation** → mengatur route secara dinamis

Struktur folder:
```bash
/src
  ├── context
  |      └── AuthContext.tsx
  ├── navigation
  |      └── AppNavigator.tsx
  └── screens
         ├── HomeScreen.tsx
         └── LoginScreen.tsx
App.tsx
```

**AuthContext.tsx**
```tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { createContext, useContext, useEffect, useState } from "react";


interface AuthContextProps {
    token: string | undefined,
    login: () => void,
    logout: () => void
}

export const AuthContext = createContext<AuthContextProps | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
    const [token, setToken] = useState<string | undefined>(undefined);

    useEffect(() => {
        const loadToken = async () => {
            const storedToken = await AsyncStorage.getItem('token');
            if (storedToken) {
                setToken(storedToken);
            }
        };
        loadToken();
    }, []);

    const login = async () => {
        const fakeToken = 'dNxH8zZ9xfMFzSswaNhoBCS1SQznZjkUhsuHO8u8yhuU190NhbshdbkjBM08';
        await AsyncStorage.setItem('token', fakeToken);
        setToken(fakeToken);
    }

    const logout = async () => {
        await AsyncStorage.removeItem('token');
        setToken(undefined);
    }

    return (
        <AuthContext.Provider value={{ token, login, logout }}>
            {children}
        </AuthContext.Provider>
    )
}

export const useAuth = () => {
    const ctx = useContext(AuthContext);
    if (!ctx) throw new Error("useAuth must be used within ThemeProvider");
    return ctx;
}
```

**AppNavigator.tsx**
```tsx
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import { useAuth } from "../context/AuthContext";
import { NavigationContainer } from "@react-navigation/native";
import HomeScreen from "../screens/HomeScreen";
import LoginScreen from "../screens/LoginScreen";

const Stack = createNativeStackNavigator();
export default function AppNavigator() {
    const { token } = useAuth();
    return (
        <NavigationContainer>
            <Stack.Navigator screenOptions={{ headerShown: false }}>
                {token ? (
                    <Stack.Screen name="Home" component={HomeScreen} />
                ) : (
                    <Stack.Screen name="Login" component={LoginScreen} />
                )}
            </Stack.Navigator>
        </NavigationContainer>
    )
}
```

Pastikan telah me-*install* depedency routing

**HomeScreen.tsx**
```tsx
import { Text, View, TouchableOpacity } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function HomeScreen() {
    const { logout } = useAuth();

    return (
        <View style={{flex: 1, backgroundColor: '#ffffff'}}>
            <TouchableOpacity style={{padding: 12, marginTop:20, borderRadius:10, backgroundColor:'#16476A', alignItems: 'center' }} onPress={logout}>
                <Text style={{color: '#ffffff'}}>Logout</Text>
            </TouchableOpacity>
        </View>
    );
}
```

**LoginScreen.tsx**
```tsx
import { Text, TouchableOpacity, View } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function LoginScreen() {
    const { login } = useAuth();

    const loginHandler = () => {
        login();
    }

    return (
        <View style={{ justifyContent: 'center', flex: 1, padding: 20, backgroundColor: '#ffff' }}>
            <TouchableOpacity style={{ padding: 10, borderRadius: 10, backgroundColor: '#F875AA' }} onPress={loginHandler}>
                <Text style={{ color: "#EDFFF0", fontSize: 18, alignSelf: 'center' }}>Login</Text>
            </TouchableOpacity>
        </View>
    );
}
```

**App.tsx**
```tsx
import AsyncStorage from '@react-native-async-storage/async-storage';
import { StyleSheet, Text, View } from 'react-native';
import { AuthProvider } from './src/context/AuthContext';
import AppNavigator from './src/navigation/AppNavigator';

export default function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <AppNavigator />
      </ThemeProvider>
    </AuthProvider>
  );
}
``` --><div style="break-before: page; page-break-before: always;"></div><h1 id="securestore"><a class="header" href="#securestore">SecureStore</a></h1>
<p>Merupakan penyimpanan lokal <strong>terenkripsi</strong> yang disediakan oleh <code>expo-secure-store</code>. Semua data disimpan secara aman menggunakan:</p>
<ul>
<li><strong>iOS</strong> → Keychain Services</li>
<li><strong>Android</strong> → Encrypted Shared Preferences</li>
</ul>
<p>Berbeda dengan <a href="asynchronous-storage.html"><code>AsyncStorage</code></a> yang cocok untuk data umum (tema, settings, cache), <code>SecureStore</code> dirancang untuk menyimpan data sensitif, seperti:</p>
<ul>
<li>Token autentikasi (JWT access token / refresh token)</li>
<li>Password atau credential</li>
<li>Private keys</li>
<li>Session</li>
</ul>
<p>Artinya data terenkripsi di level OS, tidak mudah dibaca meskipun device di-root/jailbreak.</p>
<p>Walaupun demikian, <code>SecureStore</code> dapat digunakan bersamaan dengan <code>AsyncStorage</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Jenis Data</th><th>Penyimpanan</th></tr></thead><tbody>
<tr><td><strong>Sensitif</strong> (token, password, keys)</td><td><strong>SecureStore</strong></td></tr>
<tr><td><strong>Umum</strong> (tema, bahasa, pengaturan, cache)</td><td><strong>AsyncStorage</strong></td></tr>
</tbody></table>
</div>
<p>Sebelum menggunakan <code>SecureStore</code>, terdapat beberapa hal yang perlu dilakukan yaitu instalasi dependency dan melakukan rebuild plugin.</p>
<h2 id="instalasi-8"><a class="header" href="#instalasi-8">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install expo-secure-store
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install expo-secure-store
npx pod-install
</code></pre>
<h3 id="api-dasar-securestore"><a class="header" href="#api-dasar-securestore">API Dasar SecureStore</a></h3>
<p><code>SecureStore</code> menyediakan beberapa API utama:</p>
<div class="table-wrapper"><table><thead><tr><th>Kebutuhan</th><th>Fungsi</th></tr></thead><tbody>
<tr><td>Cek ketersediaan</td><td><code>isAvailableAsync()</code></td></tr>
<tr><td>Cek perlunya autentikasi biometrik</td><td><code>requireAuthentication()</code></td></tr>
<tr><td>Menyimpan data</td><td><code>setItemAsync(key: string, value: string, option? )</code></td></tr>
<tr><td>Mengambil data</td><td><code>getItemAsync(key: string, option?)</code></td></tr>
<tr><td>Menghapus data</td><td><code>deleteItemAsync(key: string)</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ Semua data harus berupa string</p>
<p>Gunakan <code>JSON.stringify()</code> untuk menyimpan object dan <code>JSON.parse()</code> saat membaca.</p>
</blockquote>
<h3 id="isavailableasync---cek-ketersediaan"><a class="header" href="#isavailableasync---cek-ketersediaan"><code>isAvailableAsync</code> - Cek ketersediaan</a></h3>
<p>Tidak semua device mendukung SecureStore. Karena itu Anda disarankan mengecek terlebih dahulu:</p>
<pre><code class="language-tsx">import * as SecureStore from 'expo-secure-store';

const checkAvailability = async () =&gt; {
  const isAvailable = await SecureStore.isAvailableAsync();
  console.log("SecureStore Available:", isAvailable);
};
</code></pre>
<h3 id="setitemasync--menyimpan-data"><a class="header" href="#setitemasync--menyimpan-data"><code>setItemAsync</code> – Menyimpan data</a></h3>
<pre><code class="language-tsx">import * as SecureStore from 'expo-secure-store';

const saveToken = async () =&gt; {
  const token = 'abc123.jwt.token';
  await SecureStore.setItemAsync('auth_token', token);
};
</code></pre>
<h3 id="getitemasync---mengambilmendapatkan-data"><a class="header" href="#getitemasync---mengambilmendapatkan-data"><code>getItemAsync</code> - Mengambil/Mendapatkan data</a></h3>
<pre><code class="language-tsx">import * as SecureStore from 'expo-secure-store';

const loadToken = async () =&gt; {
  const token = await SecureStore.getItemAsync('auth_token');
  console.log("Stored Token:", token);
};
</code></pre>
<p>Jika key tidak ditemukan, return value = <code>null</code>.</p>
<h3 id="deleteitemasync---menghapus-data"><a class="header" href="#deleteitemasync---menghapus-data"><code>deleteItemAsync</code> - Menghapus data</a></h3>
<pre><code class="language-tsx">import * as SecureStore from 'expo-secure-store';

const removeToken = async () =&gt; {
  await SecureStore.deleteItemAsync('auth_token');
};
</code></pre>
<h3 id="contoh-simulasi-login-dan-simpan-token"><a class="header" href="#contoh-simulasi-login-dan-simpan-token">Contoh: Simulasi Login dan Simpan Token</a></h3>
<p>Menggunakan <code>SecureStore</code> untuk menyimpan token autentikasi. Token tetap tersimpan meskipun aplikasi ditutup dan agar lebih rapi dan scalable, gunakan:</p>
<p>Struktur folder:</p>
<pre><code class="language-bash">/src
  ├── context
  |      └── AuthContext.tsx
  ├── navigation
  |      └── AppNavigator.tsx
  └── screens
         ├── HomeScreen.tsx
         └── LoginScreen.tsx
App.tsx
</code></pre>
<p>Pastikan plugin <a href="navigation.html">navigasi</a> sudah ter-<em>install</em> pada project.</p>
<p><strong>AuthContext.tsx</strong></p>
<pre><code class="language-tsx">import { createContext, useContext, useEffect, useState } from "react"
import * as SecureStore from 'expo-secure-store';

interface AuthContextProps {
    token: string | undefined,
    login: () =&gt; Promise&lt;void&gt;,
    logout: () =&gt; Promise&lt;void&gt;
}

export const AuthContext = createContext&lt;AuthContextProps | undefined&gt;(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) =&gt; {
    const [token, setToken] = useState&lt;string | undefined&gt;(undefined);

    useEffect(() =&gt; {
        const initAuth = async () =&gt; {
            const available = await SecureStore.isAvailableAsync();
            if (!available) return;

            const storedToken = await SecureStore.getItemAsync('token');
            if (storedToken) setToken(storedToken);
        };

        initAuth();
    }, []);

    const login = async () =&gt; {
        const fakeToken = 'dNxH8zZ9xfMFzSswaNhoBCS1SQznZjkUhsuHO8u8yhuU190NhbshdbkjBM08';
        await SecureStore.setItemAsync('token', fakeToken);
        setToken(fakeToken);
    }

    const logout = async () =&gt; {
        await SecureStore.deleteItemAsync('token');
        setToken(undefined);
    }

    return (
        &lt;AuthContext.Provider value={{ token, login, logout }}&gt;
            {children}
        &lt;/AuthContext.Provider&gt;
    )
}

export const useAuth = () =&gt; {
    const ctx = useContext(AuthContext);
    if (!ctx) throw new Error("useAuth must be used within AuthProvider");
    return ctx;
}
</code></pre>
<p>Pada real project, token akan diperoleh dari server melalui API login.</p>
<p><strong>LoginScreen.tsx</strong></p>
<pre><code class="language-tsx">import { View, Text, TouchableOpacity } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function LoginScreen() {
    const { login } = useAuth();
    return (
        &lt;View style={{ justifyContent: 'center', flex: 1, padding: 20, backgroundColor: '#ffff' }}&gt;
            &lt;TouchableOpacity style={{ padding: 10, borderRadius: 10, backgroundColor: '#F875AA' }} onPress={login}&gt;
                &lt;Text style={{ color: "#EDFFF0", fontSize: 18, alignSelf: 'center' }}&gt;Login&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><strong>HomeScreen.tsx</strong></p>
<pre><code class="language-tsx">import { View, TouchableOpacity, Text } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function HomeScreen() {
    const { logout } = useAuth();

    return (
        &lt;View style={{ flex: 1, backgroundColor: '#ffffff' }}&gt;
            &lt;TouchableOpacity style={{ padding: 12, marginTop: 20, borderRadius: 10, backgroundColor: '#16476A', alignItems: 'center' }} onPress={logout}&gt;
                &lt;Text style={{ color: '#ffffff' }}&gt;Logout&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><strong>AppNavigator.tsx</strong></p>
<pre><code class="language-tsx">import { createNativeStackNavigator } from "@react-navigation/native-stack";
import { useAuth } from "../context/AuthContext";
import { NavigationContainer } from "@react-navigation/native";
import HomeScreen from "../screens/HomeScreen";
import LoginScreen from "../screens/LoginScreen";

const Stack = createNativeStackNavigator();
export default function AppNavigator() {
    const { token } = useAuth();
    return (
        &lt;NavigationContainer&gt;
            &lt;Stack.Navigator screenOptions={{ headerShown: false }}&gt;
                {token ? (
                    &lt;Stack.Screen name="Home" component={HomeScreen} /&gt;
                ) : (
                    &lt;Stack.Screen name="Login" component={LoginScreen} /&gt;
                )}
            &lt;/Stack.Navigator&gt;
        &lt;/NavigationContainer&gt;
    )
}
</code></pre>
<p><strong>App.tsx</strong></p>
<pre><code class="language-tsx">import { AuthProvider } from './src/context/AuthContext';
import AppNavigator from './src/navigation/AppNavigator';

export default function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;AppNavigator /&gt;
    &lt;/AuthProvider&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mmkv"><a class="header" href="#mmkv">MMKV</a></h1>
<p><code>MMKV</code> adalah <em>key-value</em> storage yang sangat cepat untuk React Native, dengan performa jauh lebih baik daripada <a href="asynchronous-storage.html"><code>AsyncStorage</code></a>. Library paling populer adalah <a href="https://github.com/mrousavy/react-native-mmkv">react-native-mmkv</a>. <code>MMKV</code> cocok untuk data yang perlu akses cepat &amp; sering seperti token, preferensi, cache, dsb karena sepenuhnya bekerja secara <em>synchronous</em>.</p>
<h2 id="fitur-utama"><a class="header" href="#fitur-utama">Fitur Utama</a></h2>
<ul>
<li>Mendukung penyimpanan string, boolean, number, ArrayBuffer</li>
<li>Operasi <em>synchronous</em>, tanpa <em>async</em>/<em>await</em>, tanpa <em>Promise</em> dan <em>Bridge</em></li>
<li>Mendukung enkripsi</li>
<li>Mendukung multiple instances (misalnya memisahkan data user vs settings)</li>
<li>Mendukung iOS, Android, dan Web</li>
</ul>
<h2 id="instalasi-9"><a class="header" href="#instalasi-9">Instalasi</a></h2>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install react-native-mmkv react-native-nitro-modules
</code></pre>
<p>Jika menggunakan iOS:</p>
<pre><code class="language-bash">cd ios &amp;&amp; pod install
</code></pre>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install react-native-mmkv react-native-nitro-modules
npx expo prebuild
</code></pre>
<h3 id="api-dasar-mmkv"><a class="header" href="#api-dasar-mmkv">API Dasar MMKV</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Kebutuhan</th><th>Fungsi</th></tr></thead><tbody>
<tr><td>Menyimpan data</td><td><code>set(key, value)</code></td></tr>
<tr><td>Mengambil string</td><td><code>getString(key)</code></td></tr>
<tr><td>Mengambil angka</td><td><code>getNumber(key)</code></td></tr>
<tr><td>Mengambil boolean</td><td><code>getBoolean(key)</code></td></tr>
<tr><td>Hook React untuk data otomatis sinkron</td><td><code>useMMKVString(key)</code><br><code>useMMKVNumber(key)</code><br><code>useMMKVBoolean(key)</code></td></tr>
<tr><td>Mengecek apakah key tersedia</td><td><code>contains(key)</code></td></tr>
<tr><td>Mendapatkan semua key</td><td><code>getAllKeys()</code></td></tr>
<tr><td>Hapus data</td><td><code>remove(key)</code></td></tr>
<tr><td>Hapus seluruh data</td><td><code>clearAll()</code></td></tr>
<tr><td>Enkripsi ulang data</td><td><code>recrypt(newKey)</code></td></tr>
<tr><td>Menghapus enkripsi</td><td><code>recrypt(undefined)</code></td></tr>
</tbody></table>
</div>
<p><code>MMKV</code> menyediakan beberapa API utama, namun sebelum menggunakan API MMKV, sebuah <code>instance</code> dengan konstruktor <code>MMKV</code> wajib dibuat. <code>Instance</code> ini akan digunakan di seluruh aplikasi, sehingga tidak perlu membuat <code>instance</code> baru untuk setiap fungsi.</p>
<h3 id="membuat-instance-mmkv"><a class="header" href="#membuat-instance-mmkv">Membuat instance MMKV</a></h3>
<pre><code class="language-tsx">import { createMMKV } from 'react-native-mmkv'

export const storage = createMMKV()
</code></pre>
<p>Atau jika ingin enkripsi</p>
<pre><code class="language-tsx">import { createMMKV } from 'react-native-mmkv'

export const secureStorage = createMMKV({
  id: "secure",
  encryptionKey: "my-secret-key"
});
</code></pre>
<p><strong>Penjelasan</strong></p>
<ul>
<li><code>id</code>: digunakan sebagai nama file penyimpanan di perangkat, sekaligus sebagai pembeda antar-<code>instance</code>.</li>
<li><code>encryptionKey</code>: digunakan sebagai kunci enkripsi/dekripsi, jika option ini tidak dikonfigurasi, maka seluruh data akan disimpan seperti aslinya tanpa di enkripsi.</li>
</ul>
<h3 id="set---menyimpan-data"><a class="header" href="#set---menyimpan-data"><code>set</code> - Menyimpan data</a></h3>
<pre><code class="language-tsx">storage.set("user.token", "abc123.jwt");
storage.set("user.age", 25);
storage.set("darkMode", true);
</code></pre>
<h3 id="get---mengambil-data"><a class="header" href="#get---mengambil-data"><code>get</code> - Mengambil data</a></h3>
<pre><code class="language-tsx">const token = storage.getString("user.token");
const age = storage.getNumber("user.age");
const dark = storage.getBoolean("darkMode");
</code></pre>
<h3 id="jika-ingin-menyimpan-dan-mendapatkan-data-object"><a class="header" href="#jika-ingin-menyimpan-dan-mendapatkan-data-object">Jika ingin menyimpan dan mendapatkan data object</a></h3>
<pre><code class="language-tsx">const user = {
  token: 'abc123.jwt',
  age: 25,
}

storage.set('user', JSON.stringify(user))

const jsonUser = storage.getString('user') // { 'token': 'abc123.jwt', 'age': 25 }
const userObject = JSON.parse(jsonUser)
</code></pre>
<h3 id="jika-ingin-menyimpan-dan-mendapatkan-buffer"><a class="header" href="#jika-ingin-menyimpan-dan-mendapatkan-buffer">Jika ingin menyimpan dan mendapatkan buffer</a></h3>
<pre><code class="language-tsx">const buffer = new ArrayBuffer(3)
const dataWriter = new Uint8Array(buffer)
dataWriter[0] = 1
dataWriter[1] = 100
dataWriter[2] = 255
storage.set('someToken', buffer)

const buffer = storage.getBuffer('someToken')
console.log(buffer) // [1, 100, 255]
</code></pre>
<h3 id="usemmkvstring---hooks"><a class="header" href="#usemmkvstring---hooks"><code>useMMKVString</code> - Hooks</a></h3>
<pre><code class="language-tsx">const [usertoken, setUsertoken] = useMMKVString('user.token');
const [age, setAge] = useMMKVNumber('user.age');
const [darkmode, setDarkMode] = useMMKVBoolean('darkMode');
</code></pre>
<h3 id="contains---cek-ketersediaan-key"><a class="header" href="#contains---cek-ketersediaan-key"><code>contains</code> - Cek ketersediaan key</a></h3>
<pre><code class="language-tsx">const hasUsername = storage.contains('user.name')  // false
const hasToken = storage.contains('user.token')  // true
</code></pre>
<h3 id="getallkeys---mengambil-seluruh-key"><a class="header" href="#getallkeys---mengambil-seluruh-key"><code>getAllKeys</code> - Mengambil seluruh key</a></h3>
<pre><code class="language-tsx">const keys = storage.getAllKeys() // ['user.token', 'user.age', 'darkMode']
</code></pre>
<h3 id="remove---menghapus-key-tertentu"><a class="header" href="#remove---menghapus-key-tertentu"><code>remove</code> - Menghapus key tertentu</a></h3>
<pre><code class="language-tsx">const wasRemoved = storage.remove('user.token');
</code></pre>
<h3 id="clearall---menghapus-seluruh-key"><a class="header" href="#clearall---menghapus-seluruh-key"><code>clearAll</code> - Menghapus seluruh key</a></h3>
<pre><code class="language-tsx">storage.clearAll();
</code></pre>
<h3 id="recrypt---enkripsi-menggunakan-private-key-atau-menghapus-enkripsi"><a class="header" href="#recrypt---enkripsi-menggunakan-private-key-atau-menghapus-enkripsi"><code>recrypt</code> - Enkripsi menggunakan private key atau menghapus enkripsi</a></h3>
<p>Gunakan fungsi ini jika pada saat membuat <code>instance</code> MMKV tidak menambahkan opsi <code>encryptionKey</code> atau jika ingin menggunakan private key baru</p>
<pre><code class="language-tsx">storage.recrypt('my-private-key');
</code></pre>
<p>Dapat digunakan untuk menghapus enkripsi</p>
<pre><code class="language-tsx">storage.recrypt(undefined);
</code></pre>
<h3 id="contoh-simulasi-login-dan-simpan-token-1"><a class="header" href="#contoh-simulasi-login-dan-simpan-token-1">Contoh: Simulasi Login dan Simpan Token</a></h3>
<p>Struktur folder:</p>
<pre><code class="language-bash">/src
  ├── context
  |      └── AuthContext.tsx
  ├── navigation
  |      └── AppNavigator.tsx
  └── screens
  |      ├── HomeScreen.tsx
  |      ├── LoginScreen.tsx
  |      └── RegisterScreen.tsx
  └── storage
         └── MMKVStorage.ts
App.tsx
</code></pre>
<p>Pastikan plugin <a href="navigation.html">navigasi</a> sudah ter-<em>install</em> pada project.</p>
<p><strong>MMKVStorage.ts</strong></p>
<pre><code class="language-tsx">import { createMMKV } from "react-native-mmkv"

export interface User {
    name: string,
    email: string,
    isAuthenticated: boolean,
    token: string
};

export const storage = createMMKV({
    'id': 'app-storage',
    'encryptionKey': 'my-app-private-key'
})

export const MMKVStorage = {
    setUser: (user: User | null) =&gt; {
        if (user) {
            storage.set('user', JSON.stringify(user));
        }
        return
    },

    getUser: (): User | null =&gt; {
        const data = storage.getString('user');
        return data ? JSON.parse(data) : null;
    },

    removeUser: () =&gt; {
        storage.remove('user');
    },
}
</code></pre>
<p><strong>AuthContext.tsx</strong></p>
<pre><code class="language-tsx">import { createContext, useContext, useEffect, useState } from "react";
import { useMMKVString } from "react-native-mmkv";
import { MMKVStorage, User } from "../storage/MMKVStorage";


interface AuthContextProps {
    user: User | null,
    register: (name: string, email: string) =&gt; void,
    login: () =&gt; void,
    logout: () =&gt; void
};

const AuthContext = createContext&lt;AuthContextProps | null&gt;(null);

export const AuthProvider = ({ children }: { children: React.ReactNode }) =&gt; {
    const [user, SetUser] = useState&lt;User | null&gt;(null);

    useEffect(() =&gt; {
        const savedUser = MMKVStorage.getUser();
        console.log(savedUser);

        SetUser(savedUser);
    }, []);

    useEffect(() =&gt; {
        MMKVStorage.setUser(user);
    }, [user])

    const register = (name: string, email: string) =&gt; {
        const newUser: User = {
            name,
            email,
            isAuthenticated: false,
            token: ""
        }
        SetUser(newUser);
    }

    const login = () =&gt; {
        if (!user) return;

        const loggedUser: User = {
            name: user['name'],
            email: user['email'],
            isAuthenticated: true,
            token: "TOKEN_" + Math.random().toString(36).substring(2, 12),
        };
        SetUser(loggedUser)

    }

    const logout = () =&gt; {
        if (user) {
            const loggedUser: User = {
                name: user['name'],
                email: user['email'],
                isAuthenticated: false,
                token: ""
            };
            SetUser(loggedUser)
        } else {
            return;
        }
    }

    return (
        &lt;AuthContext.Provider value={{ user, register, login, logout }}&gt;
            {children}
        &lt;/AuthContext.Provider&gt;
    )
}

export const useAuth = () =&gt; {
    const ctx = useContext(AuthContext);
    if (!ctx) throw new Error("useAuth must be used within AuthProvider");
    return ctx;
}
</code></pre>
<p><strong>HomeScreen.tsx</strong></p>
<pre><code class="language-tsx">import { Text, TouchableOpacity, View } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function HomeScreen() {
    const { user, logout } = useAuth();
    return (
        &lt;View style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center'
        }}&gt;
            &lt;Text style={{
                fontSize: 32,
            }}&gt;
                Selamat datang, {user?.name}
            &lt;/Text&gt;

            &lt;TouchableOpacity style={{ padding: 12, marginTop: 20, borderRadius: 10, backgroundColor: '#16476A', alignItems: 'center' }} onPress={logout}&gt;
                &lt;Text style={{ color: '#ffffff' }}&gt;Logout&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    )
}
</code></pre>
<p><strong>LoginScreen.tsx</strong></p>
<pre><code class="language-tsx">import { View, Text, TouchableOpacity } from "react-native";
import { useAuth } from "../context/AuthContext";

export default function LoginScreen() {
    const { login } = useAuth();

    return (
        &lt;View style={{ justifyContent: 'center', flex: 1, padding: 20, backgroundColor: '#ffff' }}&gt;
            &lt;TouchableOpacity style={{ padding: 10, borderRadius: 10, backgroundColor: '#F875AA' }} onPress={login}&gt;
                &lt;Text style={{ color: "#EDFFF0", fontSize: 18, alignSelf: 'center' }}&gt;Login&lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><strong>RegisterScreen.tsx</strong></p>
<pre><code class="language-tsx">import { View, Text, TouchableOpacity, TextInput } from "react-native";
import { MMKV } from "react-native-mmkv";
import { useAuth } from "../context/AuthContext";
import { useState } from "react";

export default function RegisterScreen({ navigation }: any) {
    const { user, register } = useAuth();
    const [name, setName] = useState("");
    const [mail, setMail] = useState("");

    const registerHandler = () =&gt; {
        register(name, mail);
    }

    return (
        &lt;View style={{ flex: 1, padding: 20, justifyContent: "center" }}&gt;
            &lt;Text style={{ fontSize: 26, fontWeight: "bold", marginBottom: 20 }}&gt;
                Register
            &lt;/Text&gt;

            &lt;TextInput
                placeholder="Nama"
                value={name}
                onChangeText={setName}
                style={{
                    borderWidth: 1,
                    borderRadius: 10,
                    padding: 12,
                    marginBottom: 10,
                }}
            /&gt;

            &lt;TextInput
                placeholder="Email"
                value={mail}
                onChangeText={setMail}
                style={{
                    borderWidth: 1,
                    borderRadius: 10,
                    padding: 12,
                    marginBottom: 10,
                }}
            /&gt;
            &lt;TouchableOpacity
                onPress={registerHandler}
                style={{
                    backgroundColor: "#0066ff",
                    padding: 15,
                    borderRadius: 10,
                    alignItems: "center",
                }}
            &gt;
                &lt;Text style={{ color: "white", fontSize: 18 }}&gt;
                    Register
                &lt;/Text&gt;
            &lt;/TouchableOpacity&gt;
            {user ? (
                &lt;TouchableOpacity
                    onPress={() =&gt; navigation.navigate("Login")}
                    style={{ marginTop: 20 }}
                &gt;
                    &lt;Text style={{ color: "#0066ff", textAlign: "center" }}&gt;
                        Sudah punya akun? Login
                    &lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
            ) : (&lt;View&gt;&lt;/View&gt;)}
        &lt;/View&gt;
    );
}
</code></pre>
<p><strong>AppNavigator.tsx</strong></p>
<pre><code class="language-tsx">import { createNativeStackNavigator } from "@react-navigation/native-stack";
import { useAuth } from "../context/AuthContext";
import { NavigationContainer } from "@react-navigation/native";
import HomeScreen from "../screens/HomeScreen";
import RegisterScreen from "../screens/RegisterScreen";
import { useEffect, useState } from "react";
import LoginScreen from "../screens/LoginScreen";

const Stack = createNativeStackNavigator();
export default function AppNavigator() {
    const { user } = useAuth();
    let initialPage = 'Register';

    if (user) {
        if (user.isAuthenticated) {
            initialPage = 'Home';
        } else {
            initialPage = 'Login';
        }
    } else {
        initialPage = 'Register';
    }


    return (
        &lt;NavigationContainer&gt;
            &lt;Stack.Navigator screenOptions={{ headerShown: false }} &gt;
                {!user &amp;&amp; (
                    &lt;Stack.Screen name="Register" component={RegisterScreen} /&gt;
                )}

                {user &amp;&amp; !user.isAuthenticated &amp;&amp; (
                    &lt;Stack.Screen name="Login" component={LoginScreen} /&gt;
                )}

                {user &amp;&amp; user.isAuthenticated &amp;&amp; (
                    &lt;Stack.Screen name="Home" component={HomeScreen} /&gt;
                )}
            &lt;/Stack.Navigator &gt;
        &lt;/NavigationContainer&gt;
    );
}
</code></pre>
<p><strong>App.tsx</strong></p>
<pre><code class="language-tsx">import { AuthProvider } from './src/context/AuthContext';
import { NavigationContainer } from '@react-navigation/native';
import AppNavigator from './src/navigation/AppNavigator';

export default function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;AppNavigator /&gt;
    &lt;/AuthProvider&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h1>
<p>Merupakan database relasional yang berjalan di dalam perangkat dan sangat cocok digunakan untuk data yang lebih komplek seperti:</p>
<div class="table-wrapper"><table><thead><tr><th>Kebutuhan</th><th>Cocok memakai</th></tr></thead><tbody>
<tr><td>Simpan token, flag kecil, preferensi</td><td><strong>MMKV</strong></td></tr>
<tr><td>Simpan beberapa data ringan</td><td><strong>AsyncStorage</strong></td></tr>
<tr><td>Simpan data banyak, tabel, relasional, CRUD kompleks</td><td><strong>SQLite</strong></td></tr>
</tbody></table>
</div>
<p>Salah satu library terbaik untuk React Native adalah <code>react-native-quick-sqlite</code> karena memiliki beberapa keunggulan seperti:</p>
<ul>
<li>Sangat cepat</li>
<li>Synchronous</li>
<li>Mendukung React Native CLI maupun Expo</li>
</ul>
<h2 id="instalasi-10"><a class="header" href="#instalasi-10">Instalasi</a></h2>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install react-native-nitro-sqlite react-native-nitro-modules
</code></pre>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install react-native-nitro-sqlite react-native-nitro-modules
npx expo prebuild
</code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metode / Properti</th><th>Deskripsi / Kegunaan</th></tr></thead><tbody>
<tr><td><strong><code>close()</code></strong></td><td>Menutup koneksi database. setelah ini operasi pada <code>db</code> tidak dapat dilakukan lagi.</td></tr>
<tr><td><strong><code>delete()</code></strong></td><td>Menghapus file database (menghapus keseluruhan database). Berguna untuk reset/clear data seluruh database.</td></tr>
<tr><td><strong><code>attach(dbNameToAttach, alias, location?)</code></strong></td><td>Melampirkan (attach) database lain ke koneksi saat ini — artinya dua database yang berbeda dapat digunakan dalam satu connection (misalnya untuk join antar-database). <code>&lt;dbNameToAttach&gt;</code>: nama database file, <code>&lt;alias&gt;</code>: alias yang akan digunakan, <code>location</code> (opsional) lokasi file.</td></tr>
<tr><td><strong><code>detach(alias)</code></strong></td><td>Melepaskan (detach) database yang sebelumnya diter-attach dengan alias tertentu. Setelah detach, tidak dapat mengakses lagi schema dari database terlampir itu.</td></tr>
<tr><td><strong><code>transaction(fn: (tx: Transaction) =&gt; void): Promise&lt;void&gt;</code></strong></td><td>Membuka transaksi. Fungsi <code>fn</code> menerima objek <code>tx</code> (Transaction). Semua operasi di dalam transaction akan dieksekusi sebagai satu unit — jika terjadi error maka akan di-<em>ROLLBACK</em>. Berguna untuk menjaga konsistensi data dalam serangkaian query.</td></tr>
<tr><td><strong><code>execute(query: string, params?: any[]): QueryResult</code></strong></td><td>Menjalankan single SQL query <strong>secara <em>sinkron</em></strong>. Mengembalikan hasil <code>QueryResult</code> (berisi misalnya <code>rows</code>, <code>rowsAffected</code>, dsb). Karena berjalan secara sinkron, perlu hati-hati jika query berat agar tidak memblok UI.</td></tr>
<tr><td><strong><code>executeAsync(query: string, params?: any[]): Promise&lt;QueryResult&gt;</code></strong></td><td>Versi <em>asynchronous</em> dari <code>execute</code>. Operasinya berlangsung di thread native dan tidak memblok UI. Kembalian via <code>Promise</code>. Cocok untuk query yang berat atau banyak data.</td></tr>
<tr><td><strong><code>executeBatch(commands: BatchQueryCommand[]): BatchQueryResult</code></strong></td><td>Menjalankan sekumpulan query dalam satu batch (transaksi tunggal) <strong>secara sinkron</strong>. <code>commands</code> adalah array objek yang berisi <code>query</code> dan <code>params</code> (opsional). Cocok untuk operasi massal (insert/update/delete banyak data) dengan efisiensi.</td></tr>
<tr><td><strong><code>executeBatchAsync(commands: BatchQueryCommand[]): Promise&lt;BatchQueryResult&gt;</code></strong></td><td>Versi asynchronous dari batch: menjalankan banyak query dalam satu transaksi, tetapi tanpa memblok UI. Mengembalikan hasil melalui <code>Promise</code>.</td></tr>
<tr><td><strong><code>loadFile(location: string): FileLoadResult</code></strong></td><td>Memuat file SQL (dump, skrip) ke database — sinkron. Berguna jika Anda ingin inisialisasi database dari file <code>.sql</code>. <code>location</code> adalah path ke file SQL.</td></tr>
<tr><td><strong><code>loadFileAsync(location: string): Promise&lt;FileLoadResult&gt;</code></strong></td><td>Versi asynchronous dari <code>loadFile</code>, cocok untuk file besar agar tidak memblok UI.</td></tr>
</tbody></table>
</div>
<p>Sebelum menggunakan API di atas, buka (atau membuat baru jika belum ada) sebuah file database SQLite menggunakan perintah berikut:</p>
<pre><code class="language-tsx">import { open } from 'react-native-nitro-sqlite'
const db = open({ name: 'myDb.sqlite' })
</code></pre>
<p>Ketika dijalankan program akan:</p>
<ul>
<li>Membuat koneksi database</li>
<li>Mengembalikan objek DB</li>
</ul>
<p>Cukup inisialisasi sekali dan gunakan diseluruh aplikasi</p>
<h3 id="execute---menjalankan-single-sql-query-sinkron"><a class="header" href="#execute---menjalankan-single-sql-query-sinkron"><code>execute</code> - Menjalankan single SQL query (sinkron)</a></h3>
<p>Contoh: membuat table + insert + select</p>
<pre><code class="language-tsx">db.execute(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT
  )
`)

db.execute(`INSERT INTO users (name) VALUES (?)`, ["Ben Duerr"])

const result = db.execute(`SELECT * FROM users`)
console.log("Rows:", result.rows)
</code></pre>
<h3 id="execute---menjalankan-single-sql-query-asinkron"><a class="header" href="#execute---menjalankan-single-sql-query-asinkron"><code>execute</code> - Menjalankan single SQL query (asinkron)</a></h3>
<p>contoh: select data besar</p>
<pre><code class="language-tsx">const result = await db.executeAsync(`SELECT * FROM big_table`)
console.log("Total rows:", result.rows.length)
rows.forEach((row) =&gt; {
    console.log(row);
});
</code></pre>
<h3 id="executebatch---multiple-sql-query-dalam-satu-batch-sinkron"><a class="header" href="#executebatch---multiple-sql-query-dalam-satu-batch-sinkron"><code>executeBatch</code> - Multiple SQL query dalam satu batch (sinkron)</a></h3>
<p>Contoh: insert banyak data sekaligus</p>
<pre><code class="language-tsx">db.executeBatch([
  { query: `INSERT INTO items (name) VALUES (?)`, params: ["Apple"] },
  { query: `INSERT INTO items (name) VALUES (?)`, params: ["Orange"] },
  { query: `INSERT INTO items (name) VALUES (?)`, params: ["Banana"] },
])
</code></pre>
<h3 id="executebatchasync---multiple-sql-query-dalam-satu-batch-asinkron"><a class="header" href="#executebatchasync---multiple-sql-query-dalam-satu-batch-asinkron"><code>executeBatchAsync</code> - Multiple SQL query dalam satu batch (asinkron)</a></h3>
<pre><code class="language-tsx">await db.executeBatchAsync([
  { query: `INSERT INTO logs (message) VALUES (?)`, params: ["Started"] },
  { query: `INSERT INTO logs (message) VALUES (?)`, params: ["Processing"] },
  { query: `INSERT INTO logs (message) VALUES (?)`, params: ["Done"] },
])
</code></pre>
<h3 id="transaction---transaksi-atomic"><a class="header" href="#transaction---transaksi-atomic"><code>transaction</code> - Transaksi atomic</a></h3>
<p>Contoh: insert 2 data. Jika satu gagal → rollback</p>
<pre><code class="language-tsx">await db.transaction(tx =&gt; {
  tx.execute(`INSERT INTO orders (item, price) VALUES (?, ?)`, ["A", 100])
  tx.execute(`INSERT INTO orders (item, price) VALUES (?, ?)`, ["B", 200])
})
</code></pre>
<h3 id="attach---melampirkan-database-lain"><a class="header" href="#attach---melampirkan-database-lain"><code>attach</code> - Melampirkan database lain</a></h3>
<p>Contoh: memakai 2 database sekaligus</p>
<pre><code class="language-tsx">db.attach("analytics.sqlite", "analytics")

const result = db.execute(`
  SELECT u.name, a.visit_count
  FROM users u
  JOIN analytics.stats a ON u.id = a.user_id
`)
</code></pre>
<h3 id="detach---melepaskan-database-terlampir"><a class="header" href="#detach---melepaskan-database-terlampir"><code>detach</code> - Melepaskan database terlampir</a></h3>
<pre><code class="language-tsx">db.detach("analytics")
</code></pre>
<h3 id="loadfile---memuat-skrip-sql-sinkron"><a class="header" href="#loadfile---memuat-skrip-sql-sinkron"><code>loadFile</code> - Memuat skrip SQL (sinkron)</a></h3>
<p>Contoh: load file schema awal</p>
<pre><code class="language-tsx">db.loadFile("assets/schema.sql")
</code></pre>
<h3 id="loadfileasync---memuat-skrip-sql-asinkron"><a class="header" href="#loadfileasync---memuat-skrip-sql-asinkron"><code>loadFileAsync</code> - Memuat skrip SQL (asinkron)</a></h3>
<pre><code class="language-tsx">await db.loadFileAsync("assets/seed.sql")
</code></pre>
<h3 id="close---menutup-koneksi"><a class="header" href="#close---menutup-koneksi"><code>close</code> - Menutup koneksi</a></h3>
<pre><code class="language-tsx">db.close()
</code></pre>
<h3 id="delete---mengahus-database"><a class="header" href="#delete---mengahus-database">delete - Mengahus database</a></h3>
<pre><code class="language-tsx">db.delete()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sensor"><a class="header" href="#sensor">Sensor</a></h1>
<p>Banyak aplikasi mobile modern memanfaatkan sensor perangkat untuk menghadirkan pengalaman yang lebih interaktif, kontekstual, dan personal. Sensor dapat memberikan informasi tentang gerakan, lokasi, tekanan udara, atau aktivitas fisik pengguna. Beberapa penggunaan sensor dalam aplikasi:</p>
<ul>
<li><strong>Accelerometer</strong> &amp; <strong>Gyroscope</strong>: mendeteksi orientasi perangkat atau gerakan pengguna, misalnya untuk fitness tracker atau game.</li>
<li><strong>Barometer</strong>: mendeteksi ketinggian atau perubahan tekanan udara, berguna untuk aplikasi cuaca atau olahraga outdoor.</li>
<li><strong>Camera</strong>: mengambil foto atau video, mendukung scanning QR/barcode, augmented reality (AR), atau pengenalan objek.</li>
<li><strong>Location</strong> / <strong>GPS</strong>: menentukan lokasi pengguna, digunakan untuk peta, navigasi, atau fitur berbasis lokasi.</li>
<li><strong>Pedometer</strong>: menghitung langkah atau aktivitas fisik pengguna, sering digunakan dalam aplikasi kesehatan atau kebugaran</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accelerometer"><a class="header" href="#accelerometer">Accelerometer</a></h1>
<p>Merupakan sensor yang mengukur percepatan perangkat pada tiga sumbu (x, y, z). Sensor ini sering digunakan untuk:</p>
<ul>
<li>Mendeteksi orientasi perangkat (portrait/landscape)</li>
<li>Membuat fitur shake atau tilt</li>
<li>Game yang memanfaatkan gerakan perangkat</li>
<li>Fitness tracker (menghitung gerakan tubuh)</li>
</ul>
<h2 id="instalasi-11"><a class="header" href="#instalasi-11">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install expo-sensors
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install expo-sensors
cd ios &amp;&amp; pod install &amp;&amp; cd ..
</code></pre>
<h2 id="api-dasar-accelerometer"><a class="header" href="#api-dasar-accelerometer">API Dasar Accelerometer</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Deskripsi</th></tr></thead><tbody>
<tr><td><code>addListener(listener)</code></td><td>Daftarkan <strong>listener</strong> untuk menerima update percepatan perangkat. <code>listener</code> menerima objek <code>AccelerometerMeasurement</code> setiap kali ada pembaruan sensor, metode ini mengembalikan <code>Subscription</code> yang memiliki metode <code>.remove()</code> untuk berhenti mendengarkan.</td></tr>
<tr><td><code>removeSubscription(subscription)</code></td><td>Menghentikan subscription yang spesifik — artinya listener tidak akan menerima update lagi.</td></tr>
<tr><td><code>removeAllListeners()</code></td><td>Menghapus semua listener yang terdaftar sekaligus.</td></tr>
<tr><td><code>setUpdateInterval(intervalMs: number)</code></td><td>Mengatur interval atau kecepatan (dalam milidetik) pembacaan data sensor.</td></tr>
<tr><td><code>isAvailableAsync()</code></td><td>Mengecek apakah sensor accelerometer tersedia pada perangkat. Mengembalikan <code>Promise&lt;boolean&gt;</code>. Disarankan untuk dipanggil sebelum mencoba menggunakan sensor, terutama untuk mendukung berbagai platform (Android / iOS / Web).</td></tr>
<tr><td><code>requestPermissionsAsync()</code> &amp; <code>getPermissionsAsync()</code></td><td>Untuk platform/web yang membutuhkan izin akses sensor: <code>requestPermissionsAsync()</code> meminta izin ke pengguna, sedangkan <code>getPermissionsAsync()</code> memeriksa status izin. Keduanya mengembalikan <code>Promise&lt;PermissionResponse&gt;</code>.</td></tr>
<tr><td><code>getListenerCount()</code></td><td>Mengembalikan jumlah listener saat ini yang aktif. Berguna untuk debugging atau manajemen listener.</td></tr>
<tr><td><code>hasListeners()</code></td><td>Mengembalikan boolean: apakah ada listener yang terdaftar saat ini.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="tipe-data--accelerometermeasurement"><a class="header" href="#tipe-data--accelerometermeasurement">Tipe Data — <code>AccelerometerMeasurement</code></a></h2>
<p>Ketika listener dipanggil, ia menerima objek <code>AccelerometerMeasurement</code> dengan properti:</p>
<ul>
<li><code>x: number</code> — percepatan sepanjang sumbu X, dalam satuan “g” (di mana 1g ≈ gravitasi bumi ≈ 9.81 m/s²)</li>
<li><code>y: number</code> — percepatan sepanjang sumbu Y</li>
<li><code>z: number</code> — percepatan sepanjang sumbu Z</li>
<li><code>timestamp: number</code> — waktu pengukuran (dalam detik, relatif) saat pembacaan terjadi.</li>
</ul>
<hr />
<h2 id="contoh-penggunaan-accelerometer"><a class="header" href="#contoh-penggunaan-accelerometer">Contoh Penggunaan Accelerometer</a></h2>
<pre><code class="language-tsx">import { useEffect, useState } from "react";
import { View, Text, Button, Alert, TouchableOpacity } from 'react-native';
import { Accelerometer } from "expo-sensors";

export default function AccelerometerContainer() {
    const [{ x, y, z }, setData] = useState({
        x: 0,
        y: 0,
        z: 0
    });
    const [subscription, setSubscription] = useState&lt;any&gt;(null);
    const [available, setAvailable] = useState&lt;boolean | null&gt;(null);

    useEffect(() =&gt; {
        const checkAvailability = async () =&gt; {
            const isAvailable = await Accelerometer.isAvailableAsync();
            setAvailable(isAvailable);
        };

        checkAvailability();
    }, []);

    const _slow = () =&gt; Accelerometer.setUpdateInterval(1000);
    const _fast = () =&gt; Accelerometer.setUpdateInterval(16);

    const startAccelerometer = async () =&gt; {
        if (!available) {
            Alert.alert("Sensor Accelerometer tidak tersedia di perangkat ini");
            return;
        }
        const sub = Accelerometer.addListener(accelData =&gt; {
            setData(accelData);
        });
        setSubscription(sub);
    }

    const stopAccelerometer = () =&gt; {
        subscription?.remove();
        setSubscription(null);
    }


    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 }}&gt;
            &lt;Text style={{ fontSize: 18, marginBottom: 10 }}&gt;Accelerometer Example&lt;/Text&gt;

            &lt;Text style={{ marginTop: 20 }}&gt;
                Sensor tersedia: {available === null ? 'Memeriksa...' : available ? 'Ya' : 'Tidak'}
            &lt;/Text&gt;

            &lt;Text&gt;X: {x.toFixed(2)}&lt;/Text&gt;
            &lt;Text&gt;Y: {y.toFixed(2)}&lt;/Text&gt;
            &lt;Text&gt;Z: {z.toFixed(2)}&lt;/Text&gt;

            &lt;View style={{ flexDirection: 'row', marginTop: 20 }}&gt;
                &lt;Button title="Start" onPress={startAccelerometer} /&gt;
                &lt;View style={{ width: 20 }} /&gt;
                &lt;Button title="Stop" onPress={stopAccelerometer} /&gt;
            &lt;/View&gt;

            &lt;View style={{ flexDirection: 'row', gap: 10, marginTop: 14 }}&gt;
                &lt;TouchableOpacity onPress={_slow} style={{
                    flex: 1,
                    justifyContent: 'center',
                    alignItems: 'center',
                    backgroundColor: '#eee',
                    padding: 10,
                }}&gt;
                    &lt;Text&gt;Slow&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
                &lt;TouchableOpacity onPress={_fast} style={{
                    flex: 1,
                    justifyContent: 'center',
                    alignItems: 'center',
                    backgroundColor: '#eee',
                    padding: 10,
                }}&gt;
                    &lt;Text&gt;Fast&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<h2 id="alur-penggunaan-api"><a class="header" href="#alur-penggunaan-api">Alur Penggunaan API</a></h2>
<ol>
<li>Panggil <code>Accelerometer.isAvailableAsync()</code> dulu — untuk memastikan sensor tersedia.</li>
<li>(Jika perlu) panggil <code>Accelerometer.requestPermissionsAsync()</code> untuk meminta akses ke sensor.</li>
<li>Atur interval update dengan <code>Accelerometer.setUpdateInterval(...)</code>.</li>
<li>Pasang listener dengan <code>Accelerometer.addListener(...)</code>.</li>
<li>Ketika sudah tidak diperlukan (misalnya komponen unmount), panggil <code>subscription.remove()</code> atau <code>Accelerometer.removeAllListeners()</code>.</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="gyroscope"><a class="header" href="#gyroscope">Gyroscope</a></h1>
<p>Merupakan sensor yang dapat mengukur kecepatan rotasi perangkat pada tiga sumbu (x, y, z) dalam satuan radian per detik. Sensor ini berbeda dari accelerometer yang mengukur percepatan linear, gyroscope lebih fokus pada rotasi. Beberapa penggunaan umum gyroscope:</p>
<ul>
<li>Mengukur putaran perangkat dalam game (contoh: mengendalikan karakter atau kamera).</li>
<li>AR/VR tracking untuk gerakan kepala</li>
<li>Gesture berbasis rotasi (misalnya memutar ponsel untuk undo/redo)</li>
<li>Meningkatkan akurasi orientasi perangkat saat digabungkan dengan accelerometer</li>
</ul>
<h2 id="instalasi-12"><a class="header" href="#instalasi-12">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install expo-sensors
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install expo-sensors
cd ios &amp;&amp; pod install &amp;&amp; cd ..
</code></pre>
<h2 id="api-dasar-gyroscope"><a class="header" href="#api-dasar-gyroscope">API Dasar Gyroscope</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Deskripsi</th></tr></thead><tbody>
<tr><td><code>addListener(listener)</code></td><td>Mendaftarkan <strong>listener</strong> untuk menerima data rotasi dari gyroscope. Listener memanggil fungsi dengan parameter <code>GyroscopeMeasurement</code>. Mengembalikan objek <code>Subscription</code> dengan metode <code>.remove()</code>.</td></tr>
<tr><td><code>removeSubscription(subscription)</code></td><td>Menghapus listener tertentu dari gyroscope.</td></tr>
<tr><td><code>removeAllListeners()</code></td><td>Menghapus semua listener yang aktif. Berguna saat reset sensor atau unmount.</td></tr>
<tr><td><code>setUpdateInterval(intervalMs: number)</code></td><td>Menentukan seberapa sering data sensor diperbarui (dalam milidetik).</td></tr>
<tr><td><code>isAvailableAsync()</code></td><td>Mengecek apakah sensor gyroscope tersedia pada perangkat. Mengembalikan <code>Promise&lt;boolean&gt;</code>.</td></tr>
<tr><td><code>requestPermissionsAsync()</code> &amp; <code>getPermissionsAsync()</code></td><td>Memeriksa dan meminta izin akses sensor. Dibutuhkan pada platform tertentu.</td></tr>
<tr><td><code>getListenerCount()</code></td><td>Mengembalikan jumlah listener aktif saat ini.</td></tr>
<tr><td><code>hasListeners()</code></td><td>Menentukan apakah ada listener yang sedang aktif.</td></tr>
</tbody></table>
</div>
<h2 id="tipe-data--gyroscopemeasurement"><a class="header" href="#tipe-data--gyroscopemeasurement">Tipe Data — GyroscopeMeasurement</a></h2>
<p>Listener gyroscope menerima data berupa objek:</p>
<ul>
<li>x: number — kecepatan rotasi pada sumbu X (radian/detik)</li>
<li>y: number — kecepatan rotasi pada sumbu Y (radian/detik)</li>
<li>z: number — kecepatan rotasi pada sumbu Z (radian/detik)</li>
<li>timestamp: number — waktu pengambilan data (detik, relatif)</li>
</ul>
<h2 id="contoh-penggunaan-gyroscope"><a class="header" href="#contoh-penggunaan-gyroscope">Contoh Penggunaan Gyroscope</a></h2>
<pre><code class="language-tsx">import { useEffect, useState } from "react";
import { View, Text, Button, Alert, TouchableOpacity } from "react-native";
import { Gyroscope } from "expo-sensors";

export default function GyroscopeContainer() {
    const [{ x, y, z }, setData] = useState({
        x: 0,
        y: 0,
        z: 0
    });
    const [subscription, setSubscription] = useState&lt;any&gt;(null);
    const [available, setAvailable] = useState&lt;boolean | null&gt;(null);

    useEffect(() =&gt; {
        const checkAvailability = async () =&gt; {
            const isAvailable = await Gyroscope.isAvailableAsync();
            setAvailable(isAvailable);
        };

        checkAvailability();

        // cleanup listener saat komponen unmount
        return () =&gt; {
            subscription?.remove();
        };
    }, [subscription]);

    const setSlowInterval = () =&gt; Gyroscope.setUpdateInterval(1000);
    const setFastInterval = () =&gt; Gyroscope.setUpdateInterval(16);

    const startGyroscope = () =&gt; {
        if (!available) {
            Alert.alert("Sensor Gyroscope tidak tersedia di perangkat ini");
            return;
        }

        const sub = Gyroscope.addListener(gyroData =&gt; {
            setData(gyroData);
        });

        setSubscription(sub);
    };

    const stopGyroscope = () =&gt; {
        subscription?.remove();
        setSubscription(null);
    };

    return (
        &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center", padding: 20 }}&gt;
            &lt;Text style={{ fontSize: 18, marginBottom: 10 }}&gt;Gyroscope Example&lt;/Text&gt;

            &lt;Text style={{ marginTop: 20 }}&gt;
                Sensor tersedia: {available === null ? "Memeriksa..." : available ? "Ya" : "Tidak"}
            &lt;/Text&gt;

            &lt;Text&gt;X: {x.toFixed(2)}&lt;/Text&gt;
            &lt;Text&gt;Y: {y.toFixed(2)}&lt;/Text&gt;
            &lt;Text&gt;Z: {z.toFixed(2)}&lt;/Text&gt;

            &lt;View style={{ flexDirection: "row", marginTop: 20 }}&gt;
                &lt;Button title="Start" onPress={startGyroscope} /&gt;
                &lt;View style={{ width: 20 }} /&gt;
                &lt;Button title="Stop" onPress={stopGyroscope} /&gt;
            &lt;/View&gt;

            &lt;View style={{ flexDirection: "row", gap: 10, marginTop: 14 }}&gt;
                &lt;TouchableOpacity
                    onPress={setSlowInterval}
                    style={{
                        flex: 1,
                        justifyContent: "center",
                        alignItems: "center",
                        backgroundColor: "#eee",
                        padding: 10
                    }}
                &gt;
                    &lt;Text&gt;Slow&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;

                &lt;TouchableOpacity
                    onPress={setFastInterval}
                    style={{
                        flex: 1,
                        justifyContent: "center",
                        alignItems: "center",
                        backgroundColor: "#eee",
                        padding: 10
                    }}
                &gt;
                    &lt;Text&gt;Fast&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<h2 id="alur-penggunaan-api-1"><a class="header" href="#alur-penggunaan-api-1">Alur Penggunaan API</a></h2>
<ul>
<li>Panggil <code>Gyroscope.isAvailableAsync()</code> untuk memastikan sensor tersedia.</li>
<li>(Jika diperlukan) panggil <code>Gyroscope.requestPermissionsAsync()</code> untuk mendapatkan izin.</li>
<li>Atur interval update menggunakan <code>Gyroscope.setUpdateInterval(...)</code>.</li>
<li>Daftarkan listener menggunakan <code>Gyroscope.addListener(...)</code>.</li>
<li>Ketika komponen di-unmount atau sensor tidak diperlukan, panggil <code>.remove()</code> atau <code>Gyroscope.removeAllListeners()</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="barometer"><a class="header" href="#barometer">Barometer</a></h1>
<p>Merupakan sensor yang mampu mengukur tekanan udara (air pressure) di sekitar perangkat. Sensor ini berguna untuk mendeteksi perubahan cuaca, altitud relatif (terutama di iOS), atau konteks lingkungan (misalnya aplikasi cuaca, altimeter, atau log tekanan udara).</p>
<h2 id="instalasi-13"><a class="header" href="#instalasi-13">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install expo-sensors
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install expo-sensors
cd ios &amp;&amp; pod install &amp;&amp; cd ..
</code></pre>
<h2 id="api-dasar-barometer"><a class="header" href="#api-dasar-barometer">API Dasar Barometer</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Deskripsi</th></tr></thead><tbody>
<tr><td><code>addListener(listener)</code></td><td>Daftarkan <strong>listener</strong> untuk menerima pembaruan data dari barometer. Listener menerima argumen berupa objek <code>BarometerMeasurement</code>. Mengembalikan objek <code>Subscription</code> dengan metode <code>.remove()</code> untuk menghentikan listener.</td></tr>
<tr><td><code>removeSubscription(subscription)</code></td><td>Hentikan listener tertentu agar tidak menerima update lagi.</td></tr>
<tr><td><code>removeAllListeners()</code></td><td>Hapus semua listener barometer yang aktif.</td></tr>
<tr><td><code>setUpdateInterval(intervalMs: number)</code></td><td>Atur interval pembaruan data sensor (dalam milidetik). Perhatikan bahwa pada Android 12+ (API 31), ada batas minimal frekuensi sensor.</td></tr>
<tr><td><code>isAvailableAsync()</code></td><td>Mengecek apakah perangkat mendukung sensor barometer. Mengembalikan <code>Promise&lt;boolean&gt;</code>. Disarankan memanggil ini dulu sebelum men-subscribe.</td></tr>
<tr><td><code>getPermissionsAsync()</code> &amp; <code>requestPermissionsAsync()</code></td><td>(Jika diperlukan) memeriksa atau meminta izin akses sensor.</td></tr>
<tr><td><code>getListenerCount()</code></td><td>Mendapatkan jumlah listener aktif saat ini (angka).</td></tr>
<tr><td><code>hasListeners()</code></td><td>Cek apakah ada listener yang terdaftar (boolean).</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="contoh-penggunaan-barometer"><a class="header" href="#contoh-penggunaan-barometer">Contoh Penggunaan Barometer</a></h2>
<pre><code class="language-tsx">import { useEffect, useState } from "react";
import { View, Text, Button, Platform, Alert, TouchableOpacity } from "react-native";
import { Barometer } from "expo-sensors";

export default function BarometerContainer() {
    const [{ pressure, relativeAltitude }, setData] = useState&lt;{ pressure: number; relativeAltitude?: number }&gt;({
        pressure: 0,
        relativeAltitude: undefined
    });
    const [subscription, setSubscription] = useState&lt;any&gt;(null);
    const [available, setAvailable] = useState&lt;boolean | null&gt;(null);

    useEffect(() =&gt; {
        const checkAvailability = async () =&gt; {
            const isAvail = await Barometer.isAvailableAsync();
            setAvailable(isAvail);
        };
        checkAvailability();

        return () =&gt; {
            subscription?.remove();
        };
    }, [subscription]);

    const setSlowInterval = () =&gt; Barometer.setUpdateInterval(1000);
    const setFastInterval = () =&gt; Barometer.setUpdateInterval(500);

    const startBarometer = () =&gt; {
        if (!available) {
            Alert.alert("Sensor Barometer tidak tersedia di perangkat ini");
            return;
        }

        const sub = Barometer.addListener(data =&gt; {
            setData(data);
        });
        setSubscription(sub);
    };

    const stopBarometer = () =&gt; {
        subscription?.remove();
        setSubscription(null);
    };

    return (
        &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center", padding: 20 }}&gt;
            &lt;Text style={{ fontSize: 18, marginBottom: 10 }}&gt;Barometer Example&lt;/Text&gt;

            &lt;Text&gt;Pressure: {pressure.toFixed(2)} hPa&lt;/Text&gt;
            {Platform.OS === "ios" &amp;&amp; relativeAltitude != null &amp;&amp; (
                &lt;Text&gt;Relative Altitude: {relativeAltitude.toFixed(2)} m&lt;/Text&gt;
            )}

            &lt;View style={{ flexDirection: "row", marginTop: 20 }}&gt;
                &lt;Button title="Start" onPress={startBarometer} /&gt;
                &lt;View style={{ width: 20 }} /&gt;
                &lt;Button title="Stop" onPress={stopBarometer} /&gt;
            &lt;/View&gt;

            &lt;Text style={{ marginTop: 20 }}&gt;
                Sensor tersedia: {available === null ? "Memeriksa..." : available ? "Ya" : "Tidak"}
            &lt;/Text&gt;

            &lt;View style={{ flexDirection: "row", gap: 10, marginTop: 14 }}&gt;
                &lt;TouchableOpacity
                    onPress={setSlowInterval}
                    style={{ flex: 1, justifyContent: "center", alignItems: "center", backgroundColor: "#eee", padding: 10 }}
                &gt;
                    &lt;Text&gt;Slow&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
                &lt;TouchableOpacity
                    onPress={setFastInterval}
                    style={{ flex: 1, justifyContent: "center", alignItems: "center", backgroundColor: "#eee", padding: 10 }}
                &gt;
                    &lt;Text&gt;Fast&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedometer"><a class="header" href="#pedometer">Pedometer</a></h1>
<p>Sensor pedometer memungkinkan aplikasi untuk memantau jumlah langkah pengguna menggunakan sensor bawaan perangkat (Android) atau layanan Core Motion (iOS).</p>
<h2 id="instalasi-14"><a class="header" href="#instalasi-14">Instalasi</a></h2>
<p>Expo:</p>
<pre><code class="language-bash">npx expo install expo-sensors
</code></pre>
<p>React Native CLI:</p>
<pre><code class="language-bash">npm install expo-sensors
cd ios &amp;&amp; pod install &amp;&amp; cd ..
</code></pre>
<h2 id="api-dasar-pedometer"><a class="header" href="#api-dasar-pedometer">API Dasar Pedometer</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method / Fungsi</th><th>Deskripsi</th></tr></thead><tbody>
<tr><td><code>Pedometer.isAvailableAsync()</code></td><td>Mengecek apakah pedometer tersedia di perangkat. Mengembalikan <code>Promise&lt;boolean&gt;</code>.</td></tr>
<tr><td><code>Pedometer.getPermissionsAsync()</code> / <code>Pedometer.requestPermissionsAsync()</code></td><td>Memeriksa atau meminta izin akses pedometer (jika diperlukan).</td></tr>
<tr><td><code>Pedometer.getStepCountAsync(start: Date, end: Date)</code></td><td>(iOS) Mengambil jumlah langkah antara dua tanggal. Mengembalikan <code>Promise&lt;PedometerResult&gt;</code> yang berisi <code>{ steps: number }</code>.</td></tr>
<tr><td><code>Pedometer.watchStepCount(callback)</code></td><td>Berlangganan update langkah secara real-time. Callback menerima <code>PedometerResult</code>. Mengembalikan <code>Subscription</code> dengan <code>.remove()</code> untuk berhenti.</td></tr>
</tbody></table>
</div>
<p>Catatan: getStepCountAsync hanya tersedia di iOS. Pada Android cukup gunakan <code>watchStepCount</code>.</p>
<h2 id="contoh-penggunaan-pedometer"><a class="header" href="#contoh-penggunaan-pedometer">Contoh Penggunaan Pedometer</a></h2>
<pre><code class="language-tsx">import { useEffect, useState } from "react";
import { View, Text, Button, Alert, Platform } from "react-native";
import { Pedometer } from "expo-sensors";

export default function PedometerContainer() {
    const [isAvailable, setIsAvailable] = useState&lt;boolean | null&gt;(null);
    const [currentSteps, setCurrentSteps] = useState(0);
    const [pastSteps, setPastSteps] = useState&lt;number | null&gt;(null);
    const [subscription, setSubscription] = useState&lt;any&gt;(null);

    useEffect(() =&gt; {
        async function init() {
            const perm = await Pedometer.getPermissionsAsync();
            console.log("Permission status:", perm);


            // cek ketersediaan sensor
            const available = await Pedometer.isAvailableAsync();
            setIsAvailable(available);

            if (!available) {
                Alert.alert("Pedometer tidak tersedia di perangkat ini");
                return;
            }

            // cek permission
            const { status } = await Pedometer.requestPermissionsAsync();

            if (status !== "granted") {
                Alert.alert("Izin pedometer ditolak");
                return;
            }

            // Ambil histori langkah hanya jika iOS
            if (Platform.OS === "ios") {
                const end = new Date();
                const start = new Date();
                start.setDate(end.getDate() - 1); // 24 jam lalu

                try {
                    const result = await Pedometer.getStepCountAsync(start, end);
                    setPastSteps(result.steps);
                } catch (e) {
                    console.warn("Error getStepCountAsync:", e);
                    setPastSteps(null);
                }
            } else {
                setPastSteps(null); // Android tidak mendukung
            }

            // subscribe real-time
            const sub = Pedometer.watchStepCount((result) =&gt; {
                setCurrentSteps(result.steps);
            });

            setSubscription(sub);
        }

        init();

        return () =&gt; {
            subscription?.remove();
        };
    }, []);

    return (
        &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center", padding: 20 }}&gt;
            &lt;Text style={{ fontSize: 18, fontWeight: "bold", marginBottom: 10 }}&gt;
                Pedometer Example
            &lt;/Text&gt;

            &lt;Text&gt;Pedometer tersedia: {isAvailable ? "Ya" : "Tidak"}&lt;/Text&gt;

            &lt;Text style={{ marginTop: 20, fontSize: 16 }}&gt;
                Langkah (real-time): {currentSteps}
            &lt;/Text&gt;

            &lt;Text style={{ marginTop: 10, fontSize: 16 }}&gt;
                Langkah 24 jam terakhir:
                {Platform.OS === "ios"
                    ? pastSteps ?? "Memuat..."
                    : "Tidak didukung di Android"}
            &lt;/Text&gt;

            &lt;Button
                title="Reset Real-Time Counter"
                onPress={() =&gt; setCurrentSteps(0)}
            /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p>Saat mengembangkan aplikasi React Native menggunakan Expo, sensor pedometer tidak berfungsi ketika dijalankan melalui Expo Go di Android. Sedangkan pada iOS, sensor pedometer dapat berfungsi melalui Expo Go.</p>
<p>Agar sensor pedometer berjalan di Android, aplikasi harus memiliki permission Activity Recognition dan di-build menggunakan Dev Client atau APK, bukan Expo Go.
Tambahkan ke <code>app.json</code>:</p>
<pre><code class="language-bash">{
  "expo": {
    "android": {
      "permissions": ["android.permission.ACTIVITY_RECOGNITION"]
    },
    "plugins": [
      [
        "expo-sensors",
        {
          "motionPermission": "Aplikasi membutuhkan akses untuk menghitung langkah."
        }
      ]
    ]
  }
}
</code></pre>
<p>Hubungkan perangkat fisik Android lalu lakukan rebuild:</p>
<pre><code class="language-bash">npx expo run:android
</code></pre>
<p>Atau build menggunakan Dev Client</p>
<pre><code class="language-bash">npx expo prebuild
npx expo run:android
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressjs"><a class="header" href="#expressjs">ExpressJs</a></h1>
<p><code>ExpressJs</code> merupakan framework backend berbasis <code>NodeJs</code> yang ringan, cepat, dan sangat populer. Beberapa alasan Express sering dipilih sebagai backend aplikasi React Native:</p>
<ol>
<li>
<p><strong>Bahasa yang sama</strong></p>
<p>Backend dan frontend sama-sama menggunakan JavaScript/TypeScript → lebih mudah dipelajari.</p>
</li>
<li>
<p><strong>Ringan dan fleksibel</strong></p>
<p>Tidak terlalu opiniated sehingga cocok untuk aplikasi kecil hingga besar.</p>
</li>
<li>
<p><strong>Ekosistem luas</strong></p>
<p>Banyak library untuk autentikasi, database, upload file, logging, dsb.</p>
</li>
<li>
<p><strong>Mudah diintegrasikan dengan mobile apps</strong></p>
<p>API yang dibangun dengan Express sangat mudah dipanggil dari React Native menggunakan <code>fetch</code> atau <code>axios</code>.</p>
</li>
<li>
<p><strong>Digunakan di industri</strong></p>
<p>Banyak perusahaan menggunakan stack React Native + Express.js + MongoDB/PostgreSQL.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressjs-setup-environment"><a class="header" href="#expressjs-setup-environment">ExpressJs Setup Environment</a></h1>
<p>Sebelum mulai membangun backend menggunakan <code>ExpressJs</code>, kita perlu menyiapkan lingkungan pengembangan terlebih dahulu. Pada bagian ini kita akan menginstal <code>ExpressJs</code>, membuat project dasar, serta mempersiapkan tools yang akan kita gunakan.</p>
<hr />
<p>Sama halnya dengan <code>React Native</code>, <code>ExpressJs</code> juga membutuhkan <code>NodeJs</code>. Pastikan <code>NodeJs</code> telah ter-<em>install</em> di perangkat.</p>
<p>Untuk mengecek apakah NodeJs sudah tersedia, jalankan perintah berikut pada terminal:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<p>Jika kedua perintah tersebut menampilkan versi (misalnya <code>v18.x.x</code>), maka NodeJs sudah siap digunakan.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membuat-project-express-pertama"><a class="header" href="#membuat-project-express-pertama">Membuat Project Express Pertama</a></h1>
<h2 id="1-membuat-folder-project"><a class="header" href="#1-membuat-folder-project">1. Membuat Folder Project</a></h2>
<p>Buat folder baru untuk project Express:</p>
<pre><code class="language-bash">mkdir BelajarExpressJs
cd BelajarExpressJs
</code></pre>
<h2 id="2-instalasi-expressjs"><a class="header" href="#2-instalasi-expressjs">2. Instalasi ExpressJs</a></h2>
<p>Inisialisasi project <code>Node</code>:</p>
<pre><code class="language-bash">npm init -y
</code></pre>
<p>Perintah ini akan membuat file <code>package.json</code> sebagai konfigurasi dasar project.</p>
<p>Selanjutnya, install ExpressJs:</p>
<pre><code class="language-bash">npm install express
</code></pre>
<p>Untuk mempermudah proses pengembangan, kita juga dapat menginstal <a href="https://nodemon.io/">nodemon</a>, sebuah tool yang akan me-<em>restart</em> server secara otomatis ketika terjadi perubahan kode.</p>
<pre><code class="language-bash">npm install --save-dev nodemon
</code></pre>
<p>Tambahkan script berikut pada file <code>package.json</code>:</p>
<pre><code class="language-json">"scripts": {
  "start": "node index.js",
  "dev": "nodemon index.js"
}
</code></pre>
<p>Dengan menambahkan script <code>dev</code>, kita bisa menjalankan server tanpa harus menghentikan dan menjalankan ulang secara manual.
Catatan: <code>index.js</code> merupakan file main program dan bisa disesuaikan nantinya.</p>
<h2 id="3-membuat-file-main"><a class="header" href="#3-membuat-file-main">3. Membuat File Main</a></h2>
<p>Buat file <code>index.js</code> lalu isi dengan kode berikut:</p>
<pre><code class="language-js">const express = require('express');
const app = express();
const PORT = 3000;

// Endpoint dasar
app.get('/', (req, res) =&gt; {
  res.send('Hello Express!');
});

// Menjalankan server
app.listen(PORT, () =&gt; {
  console.log(`Server running on http://localhost:${PORT}`);
});
</code></pre>
<p>Penjelasan singkat:</p>
<ul>
<li><code>express()</code> → membuat instance server</li>
<li><code>app.get()</code> → membuat endpoint GET</li>
<li><code>res.send()</code> → mengirim response</li>
<li><code>app.listen()</code> → menjalankan server</li>
</ul>
<h2 id="4-menjalankan-server"><a class="header" href="#4-menjalankan-server">4. Menjalankan Server</a></h2>
<p>Jalankan command:</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>Jika berhasil, akan muncul di terminal:</p>
<pre><code class="language-bash">Server running on http://localhost:3000
</code></pre>
<h2 id="5-mengakses-api"><a class="header" href="#5-mengakses-api">5. Mengakses API</a></h2>
<p>Buka browser atau gunakan tools lain seperti <a href="https://www.postman.com/">Postman</a> lalu akses url:</p>
<pre><code class="language-bash">http://localhost:3000/
</code></pre>
<h2 id="6-menghentikan-server"><a class="header" href="#6-menghentikan-server">6. Menghentikan Server</a></h2>
<p>Untuk menghentikan server gunakan <code>CTRL + C</code> pada terminal yang menjalankan server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struktur-project"><a class="header" href="#struktur-project">Struktur Project</a></h1>
<p>Setelah membuat project Express dasar, langkah selanjutnya adalah memahami bagaimana cara menyusun struktur folder yang rapi, terorganisir, dan mudah dikembangkan. Struktur folder sangat penting terutama ketika API semakin besar dan memiliki banyak endpoint.</p>
<p>Pada bagian ini kita akan membahas struktur minimal untuk project Express serta penjelasan per masing-masing folder/file.</p>
<h2 id="1-struktur-sederhana-untuk-project-kecil"><a class="header" href="#1-struktur-sederhana-untuk-project-kecil">1. Struktur Sederhana untuk Project Kecil</a></h2>
<p>Untuk project sederhana (misalnya API untuk belajar dasar Express), struktur yang umum digunakan adalah:</p>
<pre><code class="language-bash">project-folder/
├── node_modules/
├── index.js
├── package.json
└── package-lock.json
</code></pre>
<p>Struktur ini hanya cocok untuk aplikasi kecil. Namun untuk API yang memiliki banyak route, controller, middleware, dan model. Kedepannya kita pasti akan membutuhkan struktur yang lebih modular. Berikut adalah contoh struktur proyek yang lebih modular</p>
<pre><code class="language-bash">project-folder/
├── node_modules/
├── src/
│   ├── routes/
│   │   └── user.routes.js
│   ├── controllers/
│   │   └── user.controller.js
│   ├── middlewares/
│   │   └── auth.middleware.js
│   ├── config/
│   │   └── db.js
│   └── app.js
├── index.js
├── package.json
└── package-lock.json
</code></pre>
<h2 id="2-tips-menyusun-struktur-project"><a class="header" href="#2-tips-menyusun-struktur-project">2. Tips Menyusun Struktur Project</a></h2>
<ul>
<li>Pisahkan route dan controller agar file tidak terlalu besar.</li>
<li>Semua konfigurasi sebaiknya ada dalam folder <code>/config</code>.</li>
<li>Gunakan folder <code>/services</code> jika API mulai kompleks.</li>
<li>Middleware jangan digabungkan dengan controller.</li>
<li>Simpan file statis (jika ada) dalam folder <code>public/</code>.</li>
</ul>
<h2 id="3-kapan-harus-memperluas-struktur"><a class="header" href="#3-kapan-harus-memperluas-struktur">3. Kapan Harus Memperluas Struktur?</a></h2>
<p>Gunakan struktur modular jika:</p>
<ul>
<li>API memiliki banyak endpoint</li>
<li>Ketika menggunakan database</li>
<li>Perlu auth, middleware, validation</li>
<li>Project akan dikembangkan oleh tim</li>
</ul>
<p>Untuk materi lanjutan, kita akan menggunakan struktur modular ini agar lebih terorganisir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing"><a class="header" href="#routing">Routing</a></h1>
<p>Routing adalah konsep dasar dalam <code>ExpressJs</code> yang digunakan untuk menentukan bagaimana server merespons suatu <em>request</em> dari client berdasarkan HTTP method dan URL path.</p>
<p>Dengan routing, kita dapat mengatur endpoint seperti:</p>
<ul>
<li><code>GET /users</code></li>
<li><code>POST /login</code></li>
<li><code>PUT /products/:id</code></li>
<li><code>PATCH /posts/:id</code></li>
<li><code>DELETE /posts/:id</code></li>
</ul>
<p>Routing menjadi fondasi utama dalam membangun <a href="./rest-api-express-js.html">RESTful API</a>.</p>
<h2 id="http-methods-yang-didukung-express"><a class="header" href="#http-methods-yang-didukung-express">HTTP Methods yang Didukung Express</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Keterangan</th></tr></thead><tbody>
<tr><td><strong>GET</strong></td><td>Mengambil data</td></tr>
<tr><td><strong>POST</strong></td><td>Mengirim data baru</td></tr>
<tr><td><strong>PUT</strong></td><td>Mengupdate data (replace)</td></tr>
<tr><td><strong>PATCH</strong></td><td>Mengupdate sebagian data</td></tr>
<tr><td><strong>DELETE</strong></td><td>Menghapus data</td></tr>
</tbody></table>
</div>
<p>Contoh route dasar di Express:</p>
<pre><code class="language-js">app.get("/hello", (req, res) =&gt; {
  res.send("Hello World!");
});
</code></pre>
<h3 id="memahami-objek-req-dan-res"><a class="header" href="#memahami-objek-req-dan-res">Memahami Objek <code>req</code> dan <code>res</code></a></h3>
<p>Ketika membuat route, handler function akan menerima dua objek penting yaitu <code>req</code> (request) dan <code>res</code> (response).</p>
<h3 id="objek-req"><a class="header" href="#objek-req">Objek <code>req</code></a></h3>
<p>Berisi informasi dari client yang dikirim ke server. Objek ini memiliki beberapa property penting:</p>
<ul>
<li>
<p><code>req.originalUrl</code> Menunjukkan URL lengkap. <code>req.baseUrl</code> Menunjukkan dasar tempat sebuah router dipasang. <code>req.path</code> Menunjukkan path spesifik dari URL yang menangani suatu route.</p>
<pre><code class="language-js">// GET 'http://www.example.com/admin/new?sort=desc'
app.use("/admin", (req, res, next) =&gt; {
  console.dir(req.originalUrl); // '/admin/new?sort=desc'
  console.dir(req.baseUrl); // '/admin'
  console.dir(req.path); // '/new'
  next();
});
</code></pre>
</li>
</ul>
<p><code>next</code> merupakan fungsi tambahan untuk kebutuhan <a href="./middleware-expres-js.html">Middleware</a></p>
<ul>
<li>
<p><code>req.subdomains</code> Menunjukkan array subdomain.</p>
<pre><code class="language-js">// Host: "tobi.ferrets.example.com/admin"
app.get("/admin", (req, res) =&gt; {
  console.dir(req.subdomains);
  // =&gt; ["ferrets", "tobi"]
});
</code></pre>
</li>
<li>
<p><code>req.params</code> Menyimpan nilai dari <a href="./route-parameter-express-js.html">Route Parameters</a>.</p>
<pre><code class="language-yaml">GET /users/45
</code></pre>
<pre><code class="language-js">app.get("/users/:id", (req, res) =&gt; {
  console.log(req.params.id); // 45
});
</code></pre>
</li>
<li>
<p><code>req.query</code> Menyimpan <a href="./query-parameter-express-js.html">Query Parameters</a></p>
<pre><code class="language-yaml">GET /search?title=express?year=2025
</code></pre>
<pre><code class="language-js">app.get("/search", (req, res) =&gt; {
  // const title = req.params.title   // jika ingin mendapatkan key tertentu
  // const year = req.params.year   // jika ingin mendapatkan key tertentu
  const { title, year } = req.params;

  console.log(title, year); // "express", 2025
});
</code></pre>
<p>Pastikan key sudah sama dengan yang terdapat pada URL. Contoh di atas, key-nya adalah <code>title</code> dan <code>year</code></p>
</li>
<li>
<p><code>req.headers</code> Berisi semua header request HTTP yang dikirim oleh client.</p>
<pre><code class="language-js">app.get("/data", (req, res) =&gt; {
  const userAgent = req.headers["User-Agent"];
  console.log(`User Agent: ${userAgent}`);
});
</code></pre>
</li>
<li>
<p><code>req.body</code> Berisi data yang dikirim melalui body (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>) dan wajib menambahkan <a href="./middleware-expres-js.html">Middleware</a> berikut</p>
<pre><code class="language-js">app.use(express.json());
</code></pre>
<pre><code class="language-js">app.post("/user/register", (req, res) =&gt; {
  const dataBody = req.body; // mendapatkan seluruh data body
  const username = req.body.username; // mendapatkan data dari suatu key
});
</code></pre>
</li>
<li>
<p><code>req.method</code> Menunjukkan HTTP method yang digunakan dan <code>req.url</code> Menunjukkan URL path yang diminta.</p>
<pre><code class="language-js">app.use((req, res, next) =&gt; {
  console.log(`Request: ${req.method} - ${req.url}`);
  next();
});
</code></pre>
</li>
</ul>
<h3 id="objek-res"><a class="header" href="#objek-res">Objek <code>res</code></a></h3>
<p>Digunakan untuk mengirim response ke client. Objek ini memiliki beberapa method penting:</p>
<ul>
<li>
<p><code>res.send()</code> digunakan untuk mengirim <code>string</code>, <code>object</code>, <code>buffer</code>, atau <code>array</code> sebagai response.</p>
<pre><code class="language-js">app.get("/hello", (req, res) =&gt; {
  res.send("Hello world!");
});
</code></pre>
</li>
<li>
<p><code>res.json()</code> digunakan untuk mengirimkan response ke client dalam format JSON.</p>
<pre><code class="language-js">app.post("/register", (req, res) =&gt; {
  res.json({
    message: "Behasil mendaftar",
    status: "success",
  });
});
</code></pre>
</li>
<li>
<p><code>res.status()</code> digunakan untuk mengatur HTTP status code.</p>
<pre><code class="language-js">app.get("/hello", (req, res) =&gt; {
  res.status(200).send("Hello world!");
});
</code></pre>
</li>
<li>
<p><code>res.end()</code> diguanakan untuk mengakhiri proses response tanpa mengirimkan data.</p>
<pre><code class="language-js">app.all("*", (req, res) =&gt; {
  res.status(404).end();
});
</code></pre>
</li>
<li>
<p><code>res.status()</code> digunakan untuk mengatur HTTP status code.</p>
<pre><code class="language-js">app.get("/hello", (req, res) =&gt; {
  res.status(200).send("Hello world!");
});
</code></pre>
<pre><code class="language-js">app.all("*", (req, res) =&gt; {
  res.status(404).send("Route tidak ditemukan");
});
</code></pre>
</li>
<li>
<p><code>res.redirect()</code> digunakan untuk mengalihkan client ke URL lain.</p>
<pre><code class="language-js">app.get("/register", (req, res) =&gt; {
  // logic register
  res.redirect("/beranda");
});
</code></pre>
</li>
<li>
<p><code>res.attachment()</code> digunakan untuk mengirimkan suatu file ke client.</p>
<pre><code class="language-js">app.post("/register", (req, res) =&gt; {
  res.attachment("path/file.ekstensi").json({
    message: "Behasil mendaftar",
    status: "success",
  });
});
</code></pre>
</li>
<li>
<p><code>res.format()</code> digunakan untuk negosiasi konten yang memungkinkan server merespons dengan tipe konten yang berbeda seperti HTML, JSON, atau teks biasa berdasarkan header HTTP Accept yang dikirim oleh client.</p>
<pre><code class="language-js">res.format({
  "text/plain"() {
    res.send("hey");
  },

  "text/html"() {
    res.send("&lt;p&gt;hey&lt;/p&gt;");
  },

  "application/json"() {
    res.send({ message: "hey" });
  },

  default() {
    // log the request and respond with 406
    res.status(406).send("Not Acceptable");
  },
});
</code></pre>
<p>Kode di atas menunjukkan perbedaan jenis konten yang akan diterima oleh client.</p>
</li>
<li>
<p><code>res.render()</code> digunakan untuk merender template tampilan dan mengirimkan HTML ke client. Untuk menggunakan metode ini, pastikan untuk menggunakan view engine seperti <a href="https://ejs.co/">EJS</a>.</p>
<pre><code class="language-js">const express = require("express");
const app = express();

app.set("view engine", "ejs");
app.set("views", "./views"); // folder tempat menyimpan file .ejs

app.get("/", (req, res) =&gt; {
  res.render("home", { nama: "John" });
});
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing-dasar"><a class="header" href="#routing-dasar">Routing Dasar</a></h1>
<p>Route dasar adalah titik awal untuk memahami bagaimana Express menangani sebuah request dari client. Pada route dasar, kita mendefinisikan HTTP method, path, dan handler (fungsi yang dijalankan saat route dipanggil).</p>
<h2 id="apa-itu-route"><a class="header" href="#apa-itu-route">Apa itu Route?</a></h2>
<p>Route adalah kombinasi dari:</p>
<ul>
<li>HTTP method → <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code></li>
<li>Path (URL) → misalnya <code>/users</code>, <code>/products/:id</code></li>
<li>Handler (callback) → fungsi yang menangani request dan memberikan response</li>
</ul>
<h2 id="membuat-route"><a class="header" href="#membuat-route">Membuat Route</a></h2>
<h3 id="get"><a class="header" href="#get"><code>GET</code></a></h3>
<p>Route GET digunakan untuk mengambil data atau menampilkan informasi.</p>
<pre><code class="language-js">app.get("/hello", (req, res) =&gt; {
  res.send("Ini adalah route GET!");
});
</code></pre>
<p>Selain <code>res.send()</code>, Express juga mendukung <code>res.json()</code> untuk mengirim data format JSON.</p>
<pre><code class="language-js">app.get("/json", (req, res) =&gt; {
  res.json({
    message: "Hello dari JSON!",
    status: "success",
  });
});
</code></pre>
<h3 id="post"><a class="header" href="#post"><code>POST</code></a></h3>
<p>Route POST biasanya digunakan untuk mengirimkan data dari client ke server.</p>
<pre><code class="language-js">app.post("/submit", (req, res) =&gt; {
  res.send("Data berhasil diterima!");
});
</code></pre>
<p>Catatan:
Jika menggunakan body JSON, pastikan app menggunakan <a href="./middleware-expres-js.html">middleware</a> <code>express.json()</code>:</p>
<pre><code class="language-js">app.use(express.json());

app.post("/submit", (req, res) =&gt; {
  console.log(req.body);
  res.json(req.body);
});
</code></pre>
<h3 id="put"><a class="header" href="#put"><code>PUT</code></a></h3>
<p>Digunakan untuk memperbarui seluruh data.</p>
<pre><code class="language-js">app.put("/update", (req, res) =&gt; {
  res.send("Data berhasil diperbarui!");
});
</code></pre>
<h3 id="patch"><a class="header" href="#patch"><code>PATCH</code></a></h3>
<p>Digunakan untuk memperbarui sebagian data.</p>
<pre><code class="language-js">app.use(express.json());
app.patch("/update", (req, res) =&gt; {
  const updatedData = req.body;
  // logic update data

  res.status(200).send("Data berhasil diperbarui!");
});
</code></pre>
<h3 id="delete"><a class="header" href="#delete"><code>DELETE</code></a></h3>
<p>Digunakan untuk menghapus data.</p>
<pre><code class="language-js">app.delete("/delete", (req, res) =&gt; {
  res.send("Data berhasil dihapus!");
});
</code></pre>
<h3 id="menangani-semua-http-method"><a class="header" href="#menangani-semua-http-method">Menangani Semua HTTP Method</a></h3>
<p>Express dapat menerima semua HTTP method menggunakan <code>all()</code>.</p>
<pre><code class="language-js">app.all("/all", (req, res) =&gt; {
  res.send(`Metode HTTP yang diterima oleh route ini: ${req.method}`);
});
</code></pre>
<h3 id="menangani-semua-url-dengan"><a class="header" href="#menangani-semua-url-dengan">Menangani Semua URL dengan</a></h3>
<p>Route wildcard (<code>*</code>) biasanya digunakan untuk 404</p>
<pre><code class="language-js">app.all("*", (req, res) =&gt; {
  res.status(404).send("Route tidak ditemukan");
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="route-parameters"><a class="header" href="#route-parameters">Route Parameters</a></h1>
<p>Dalam <code>ExpressJs</code>, Route Parameters digunakan untuk membuat route yang memiliki bagian URL dinamis. Artinya, sebagian path dapat berubah-ubah, misalnya:</p>
<ul>
<li><code>/users/10</code></li>
<li><code>/articles/sport/2025</code></li>
<li><code>/products/666</code></li>
</ul>
<p>Bagian yang berubah tersebut disebut parameter dan ditulis menggunakan tanda titik dua <code>:</code> pada definisi route.</p>
<p>Contoh route parameter sederhana</p>
<pre><code class="language-js">app.get("/users/:id", (req, res) =&gt; {
  const userId = req.params.id;
  res.send(`User dengan ID: ${userId}`);
});
</code></pre>
<p>Pada contoh di atas:</p>
<ul>
<li><code>:id</code> adalah parameter</li>
<li><code>req.params.id</code> digunakan untuk mengambil nilainya</li>
</ul>
<p>Jika URL yang dipanggil adalah</p>
<pre><code class="language-yaml">/users/50
</code></pre>
<p>Maka response-nya</p>
<pre><code class="language-bash">User dengan ID: 50
</code></pre>
<h2 id="menggunakan-banyak-parameter"><a class="header" href="#menggunakan-banyak-parameter">Menggunakan Banyak Parameter</a></h2>
<p>Kita mendefinisikan lebih dari satu route parameter</p>
<pre><code class="language-js">app.get("/products/:category/:id", (req, res) =&gt; {
  const { category, id } = req.params;

  res.send(`Kategori: ${category}, Produk ID: ${id}`);
});
</code></pre>
<p>Contoh pemanggilan</p>
<pre><code class="language-yaml">/products/electronics/123
</code></pre>
<p>Response</p>
<pre><code class="language-bash">Kategori: electronics, Produk ID: 123
</code></pre>
<h3 id="parameter-opsional"><a class="header" href="#parameter-opsional">Parameter Opsional</a></h3>
<p>Dengan menambahkan tanda <code>?,</code> parameter menjadi opsional</p>
<pre><code class="language-js">app.get("/hello/:name?", (req, res) =&gt; {
  const name = req.params.name || "Guest";
  res.send(`Hello, ${name}!`);
});
</code></pre>
<p>Contoh URL valid:</p>
<ul>
<li><code>/hello</code> -&gt; response
<pre><code class="language-bash">Hello
</code></pre>
</li>
<li><code>/hello/Admin</code> -&gt; response
<pre><code class="language-bash">Hello Admin
</code></pre>
</li>
</ul>
<h3 id="wildcard-parameter"><a class="header" href="#wildcard-parameter">Wildcard Parameter</a></h3>
<p>Jika ingin menangkap sisa path URL sebagai satu parameter, Express menyediakan teknik bernama splat parameter:</p>
<pre><code class="language-js">app.get("/files/*", (req, res) =&gt; {
  const path = req.params[0];
  res.send(`Anda mengakses file: ${path}`);
});
</code></pre>
<p>Contoh akses:</p>
<pre><code class="language-yaml">/files/images/2025/banner.png
</code></pre>
<p>Output:</p>
<pre><code class="language-yaml">Anda mengakses file: images/2025/banner.png
</code></pre>
<p>Teknik ini cocok digunakan untuk routing file statis dan dynamic path.</p>
<h3 id="validasi-menggunakan-regex"><a class="header" href="#validasi-menggunakan-regex">Validasi Menggunakan Regex</a></h3>
<p>Express memungkinkan parameter memiliki pattern menggunakan regex.</p>
<pre><code class="language-js">app.get("/users/:id(\\d+)", (req, res) =&gt; {
  res.send(`User ID valid: ${req.params.id}`);
});
</code></pre>
<p>Contoh valid:</p>
<ul>
<li><code>/users/123</code></li>
</ul>
<p>Contoh tidak valid:</p>
<ul>
<li><code>/users/abc</code></li>
<li><code>/users/12x</code></li>
</ul>
<p>Regex umum yang dapat digunakan:</p>
<div class="table-wrapper"><table><thead><tr><th>Regex</th><th>Arti</th></tr></thead><tbody>
<tr><td><code>\\d+</code></td><td>Hanya angka</td></tr>
<tr><td><code>[a-zA-Z]+</code></td><td>Hanya huruf</td></tr>
<tr><td><code>[a-z0-9]+</code></td><td>Alphanumeric</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="query-parameters"><a class="header" href="#query-parameters">Query Parameters</a></h1>
<p>Query Parameters adalah nilai yang dikirimkan melalui URL dengan format</p>
<pre><code class="language-yaml">url?key_1=value_1&amp;key_2=value_2
</code></pre>
<p>Query parameter <strong>tidak berada di path</strong>, melainkan berada setelah tanda tanya <code>?</code>, dan dapat memiliki banyak pasangan <code>key=value</code> yang dipisahkan oleh <code>&amp;</code>.</p>
<p>Contoh URL</p>
<pre><code class="language-yaml">/search?keyword=music&amp;limit=10
</code></pre>
<p>Pada <code>ExpressJs</code>, query parameters dapat diakses menggunakan <code>req.query</code></p>
<h3 id="contoh-query-parameters"><a class="header" href="#contoh-query-parameters">Contoh Query Parameters</a></h3>
<pre><code class="language-js">app.get("/search", (req, res) =&gt; {
  const { keyword, limit } = req.query;
  res.send(`Mencari: ${keyword}, batas: ${limit}`);
});
</code></pre>
<p>Jika diakses</p>
<pre><code class="language-yaml">/search?keyword=express&amp;limit=5
</code></pre>
<p>Response</p>
<pre><code class="language-bash">Mencari: express, batas: 5
</code></pre>
<h3 id="query-parameters-untuk-filtering-data"><a class="header" href="#query-parameters-untuk-filtering-data">Query Parameters untuk Filtering Data</a></h3>
<pre><code class="language-js">app.get("/products", (req, res) =&gt; {
  const { category, sort, page } = req.query;
  res.json({
    message: "Filter produk",
    category,
    sort,
    page,
  });
});
</code></pre>
<p>Jika diakses</p>
<pre><code class="language-yaml">/products?category=furniture&amp;sort=asc&amp;page=2
</code></pre>
<p>Response</p>
<pre><code class="language-json">{
  "message": "Filter produk",
  "category": "furniture",
  "sort": "asc",
  "page": "2"
}
</code></pre>
<h3 id="query-parameters-dengan-nilai-array"><a class="header" href="#query-parameters-dengan-nilai-array">Query Parameters dengan Nilai Array</a></h3>
<p>Express secara otomatis mengubah query parameter berulang menjadi array</p>
<pre><code class="language-yaml">/products?tag=promo&amp;tag=discount
</code></pre>
<pre><code class="language-js">app.get("/products", (req, res) =&gt; {
  res.json(req.query.tag);
});
</code></pre>
<p>Output:</p>
<pre><code class="language-yaml">["promo", discount]
</code></pre>
<h3 id="menggabungkan-route--query-parameters"><a class="header" href="#menggabungkan-route--query-parameters">Menggabungkan Route &amp; Query Parameters</a></h3>
<pre><code class="language-js">app.get("/users/:id", (req, res) =&gt; {
  res.json({
    id: req.params.id,
    status: req.query.status,
  });
});
</code></pre>
<p>Jika diakses</p>
<pre><code class="language-yaml">/users/7?status=true
</code></pre>
<p>Response</p>
<pre><code class="language-json">{
  "id": "7",
  "status": "true"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-router"><a class="header" href="#express-router">Express Router</a></h1>
<p>Saat aplikasi Express semakin besar, jumlah route akan bertambah dan dapat membuat file utama (<code>index.js</code> atau <code>app.js</code>) menjadi berantakan. Untuk menjaga struktur tetap rapi, Express menyediakan fitur Router untuk memisahkan route ke file-file terpisah.</p>
<p>Dengan Express Router, kita dapat:</p>
<ul>
<li>Mengelompokkan route berdasarkan fitur (Users, Products, Auth, dll.)</li>
<li>Menjaga file utama tetap bersih</li>
<li>Mempermudah scaling dan maintenance aplikasi</li>
<li>Menerapkan middleware khusus untuk grup route tertentu</li>
</ul>
<h2 id="konsep-dasar-express-router"><a class="header" href="#konsep-dasar-express-router">Konsep Dasar Express Router</a></h2>
<p><code>Router</code> adalah instance terpisah dari Express yang hanya bertanggung jawab mengatur route.</p>
<pre><code class="language-js">const router = express.Router();
</code></pre>
<p>Router dapat:</p>
<ul>
<li>Memiliki route sendiri</li>
<li>Memiliki middleware sendiri</li>
<li>di-<em>mount</em> ke path tertentu menggunakan <code>app.use()</code></li>
</ul>
<h2 id="membuat-router-sederhana"><a class="header" href="#membuat-router-sederhana">Membuat Router Sederhana</a></h2>
<p>Misalnya, kita ingin membuat router untuk user.</p>
<h3 id="langkah-1--buat-folder-dan-file-router"><a class="header" href="#langkah-1--buat-folder-dan-file-router">Langkah 1 — Buat folder dan file router</a></h3>
<pre><code class="language-bash">src/
└── routes/
│    ├── user.routes.js
│    └── article.routes.js
└── app.js
</code></pre>
<h3 id="langkah-2---isi-file-userroutesjs-dan-articleroutesjs"><a class="header" href="#langkah-2---isi-file-userroutesjs-dan-articleroutesjs">Langkah 2 - Isi file <code>user.routes.js</code> dan <code>article.routes.js</code>:</a></h3>
<pre><code class="language-js">const express = require("express");
const router = express.Router();

// GET /users
router.get("/", (req, res) =&gt; {
  res.send("Menampilkan daftar user");
});

// GET /users/:id
router.get("/:id", (req, res) =&gt; {
  res.send(`Detail user dengan ID: ${req.params.id}`);
});

module.exports = router;
</code></pre>
<pre><code class="language-js">const express = require("express");
const router = express.Router();

// GET /users
router.get("/", (req, res) =&gt; {
  res.send("Menampilkan daftar artikel");
});

// GET /users/:id
router.get("/:id", (req, res) =&gt; {
  const { include, limit } = req.query;
  res.json({
    articleId: req.params.id,
    include,
    limit,
  });
});

module.exports = router;
</code></pre>
<p>Catatan:</p>
<ul>
<li>Path pada router tidak perlu menuliskan /users</li>
<li>Prefix URL akan ditentukan saat router dipasang</li>
</ul>
<h3 id="langkah-3---menggunakan-router-di-file-utama"><a class="header" href="#langkah-3---menggunakan-router-di-file-utama">Langkah 3 - Menggunakan Router di File Utama</a></h3>
<p>Di file utama (misalnya <code>index.js</code> atau <code>src/app.js</code>), kita import router tersebut</p>
<pre><code class="language-js">const express = require("express");
const app = express();
const userRoutes = require("./src/routes/user.routes");
const articleRoutes = require("./src/routes/article.routes");

// gunakan router
app.use("/users", userRoutes);
app.use("/articles", articleRoutes);

app.listen(3000, () =&gt; {
  console.log("Server berjalan pada port 3000");
});
</code></pre>
<p>Sekarang route berikut otomatis aktif</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>URL</th><th>Handler</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/users</code></td><td>Menampilkan daftar user</td></tr>
<tr><td>GET</td><td><code>/users/:id</code></td><td>Menampilkan detail user</td></tr>
<tr><td>GET</td><td><code>/articles</code></td><td>Menampilkan daftar artkel</td></tr>
<tr><td>GET</td><td><code>/articles/:id</code></td><td>Menampilkan detail artikel</td></tr>
</tbody></table>
</div>
<h3 id="best-practice"><a class="header" href="#best-practice">Best Practice</a></h3>
<ol>
<li>Gunakan 1 router per fitur</li>
<li>Hindari logic bisnis di file route</li>
<li>Pisahkan controller dan service</li>
<li>Gunakan nama file konsisten (<code>*.routes.js</code>)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p>Middleware adalah fungsi yang berada di antara <em>request</em> dan <em>respond</em> pada Express. Setiap <em>request</em> yang masuk ke server akan melewati satu atau rangkaian middleware sebelum akhirnya mencapai <code>route handler</code>. Middleware digunakan untuk berbagai kebutuhan, seperti:</p>
<ul>
<li>Memproses atau memodifikasi <em>request</em> sebelum ke route.</li>
<li>Melakukan logging.</li>
<li>Validasi data.</li>
<li>Autentikasi dan otorisasi.</li>
<li>Menangani error.</li>
<li>dll.</li>
</ul>
<h2 id="cara-kerja-middleware"><a class="header" href="#cara-kerja-middleware">Cara Kerja Middleware</a></h2>
<p>Sebuah middleware Express memiliki bentuk dasar:</p>
<pre><code class="language-js">function (req, res, next){
    // kode middleware
    next();
}
</code></pre>
<p>Penjelasan parameter:</p>
<ul>
<li><code>req</code>: objek <em>request</em></li>
<li><code>res</code>: objek <em>response</em></li>
<li><code>next()</code>: fungsi untuk melanjutkan ke middleware berikutnya</li>
</ul>
<h2 id="jenis-jenis-middleware-di-express"><a class="header" href="#jenis-jenis-middleware-di-express">Jenis-jenis Middleware di Express</a></h2>
<p>Express mendukung beberapa jenis middleware:</p>
<h2 id="application-level-middleware"><a class="header" href="#application-level-middleware">Application-level Middleware</a></h2>
<p>Application-level middleware adalah middleware yang diterapkan langsung pada instance aplikasi Express, yaitu <code>app</code>.
Biasanya digunakan untuk kebutuhan yang berlaku global di seluruh route, seperti:</p>
<ul>
<li>Logging request</li>
<li>Autentikasi dasar</li>
<li>Validasi global</li>
<li>Parsing body (JSON, URL-encoded)</li>
<li>Rate limiting</li>
<li>Menambah data ke objek req</li>
<li>Mengatur response header</li>
</ul>
<h3 id="cara-menggunakan-application-level-middleware"><a class="header" href="#cara-menggunakan-application-level-middleware">Cara Menggunakan Application-level Middleware</a></h3>
<p>Untuk menggunakan Application-level middleware, dapat dilakukan melalui dua cara, yaitu:</p>
<pre><code class="language-js">app.use(middlewareFunction);
</code></pre>
<p>Middleware ini akan berjalan setiap kali ada request masuk, kecuali jika dibatasi pada route tertentu seperti cara berikut
atau</p>
<pre><code class="language-js">app.use("/path", middlewareFunction);
</code></pre>
<h3 id="contoh-application-level-middleware-paling-dasar"><a class="header" href="#contoh-application-level-middleware-paling-dasar">Contoh Application-level middleware paling dasar:</a></h3>
<pre><code class="language-js">const express = require("express");
const app = express();

app.use(express.json());

// Application-level middleware
app.use((req, res, next) =&gt; {
  console.log(`Request: ${req.method} - ${req.url}`);
  next(); // lanjut ke middleware berikutnya
});

app.get("/", (req, res) =&gt; {
  res.send("Hello dari Home Page!");
});

app.post("/submit", (req, res) =&gt; {
  const dataSubmited = req.body;
  res.send("Berhasil submit data");
});

app.listen(3000, () =&gt; {
  console.log("Server berjalan di port 3000");
});
</code></pre>
<p>Middleware di atas akan mencetak log setiap kali ada request masuk.</p>
<h3 id="contoh-application-level-middleware-dengan-path"><a class="header" href="#contoh-application-level-middleware-dengan-path">Contoh Application-level middleware dengan Path</a></h3>
<p>Middleware juga dapat diberlakukan hanya untuk path tertentu.</p>
<pre><code class="language-js">app.use("/admin", (req, res, next) =&gt; {
  console.log("Middleware admin dijalankan");
  next();
});

app.get("/admin/dashboard", (req, res) =&gt; {
  res.send("Dashboard Admin");
});
</code></pre>
<p>Middleware hanya berjalan untuk URL yang diawali <code>/admin</code>.</p>
<h3 id="contoh-rangkaian-application-level-middleware"><a class="header" href="#contoh-rangkaian-application-level-middleware">Contoh rangkaian Application-level middleware</a></h3>
<p>Kita juga dapat membuat rangkaian middleware</p>
<pre><code class="language-js">app.use(
  "/user/:id",
  (req, res, next) =&gt; {
    console.log("Request URL:", req.originalUrl);
    next();
  },
  (req, res, next) =&gt; {
    console.log("Request Type:", req.method);
    next();
  }
);
</code></pre>
<p>Kode di atas menunjukkan adanya dua middleware yang dirangkai untuk route yang mengarah ke path <code>/user/:id</code></p>
<h3 id="-middleware-tanpa-next"><a class="header" href="#-middleware-tanpa-next">🛑 Middleware tanpa <code>next()</code></a></h3>
<p>Jika sebuah middleware <strong>TIDAK</strong> memanggil <code>next()</code> maka request akan terhenti.</p>
<pre><code class="language-js">app.use((req, res) =&gt; {
  res.send("Request dihentikan di middleware ini");
});
</code></pre>
<p>Ini dapat digunakan untuk:</p>
<ul>
<li>Menolak akses</li>
<li>Mengembalikan error</li>
<li>Maintenance mode</li>
</ul>
<p><strong>Catatan:</strong></p>
<p>Express mengeksekusi middleware secara berurutan dari atas ke bawah sesuai urutan penulisannya di kode.</p>
<h2 id="router-level-middleware"><a class="header" href="#router-level-middleware">Router-level Middleware</a></h2>
<p>Router-level middleware adalah middleware yang prinsip kerjanya sama seperti application-level middleware, tetapi dikhususkan hanya untuk instance Router. Artinya, middleware jenis ini hanya berlaku untuk sekelompok route tertentu. Biasanya digunakan untuk kebutuhan:</p>
<ul>
<li>Membantu modularisasi</li>
<li>Membatasi cakupan middleware</li>
<li>Membuat struktur kode lebih bersih dan terorganisir</li>
</ul>
<h3 id="cara-menggunakan-router-level-middleware"><a class="header" href="#cara-menggunakan-router-level-middleware">Cara Menggunakan Router-level Middleware</a></h3>
<p>Untuk menggunakan Router-level middleware, dapat dilakukan dalam dua tahap, yaitu:</p>
<ol>
<li>
<p>Buat Router dan tambahkan middleware ke router</p>
<p><strong>src/routes/user.routes.js</strong></p>
<pre><code class="language-js">const express = require("express");
const router = express.Router();

// Router-level middleware dengan path
router.use(
  "/profile/:id",
  (req, res, next) =&gt; {
    console.log("Request URL:", req.originalUrl);
    next();
  },
  (req, res, next) =&gt; {
    console.log("Request Type:", req.method);
    next();
  }
);

// Route
router.get("/profile/:id", (req, res) =&gt; {
  res.send(`Profil user dengan ID: ${req.params.id}`);
});

module.exports = router;
</code></pre>
<p>Penjelasan:</p>
<ul>
<li><code>router.use()</code> menerapkan middleware hanya untuk route di router ini.</li>
<li>Middleware akan berjalan untuk semua request yang cocok dengan path <code>/profile/:id</code>.</li>
</ul>
</li>
<li>
<p>Tambahkan router ke aplikasi utama</p>
<p><strong>index.js</strong></p>
<pre><code class="language-js">const express = require("express");
const app = express();
const userRoutes = require("./src/routes/user.routes");

// gunakan router
app.use("/users", userRoutes);

app.listen(3000, () =&gt; {
  console.log("Server berjalan pada port 3000");
});
</code></pre>
</li>
</ol>
<h2 id="error-handling-middleware"><a class="header" href="#error-handling-middleware">Error-Handling Middleware</a></h2>
<p>Error-handling middleware adalah middleware khusus di Express yang digunakan untuk menangani error dalam aplikasi. Middleware ini memiliki empat parameter, yaitu: <code>err</code>, <code>req</code>, <code>res</code>, <code>next</code>. Express secara otomatis akan mengenali middleware sebagai error handler ketika memiliki empat parameter, bukan tiga.</p>
<p>Error-handling middleware berfungsi untuk:</p>
<ul>
<li>Menangkap error dari route handler atau middleware lain</li>
<li>Mengirim response error yang konsisten</li>
<li>Mencegah aplikasi berhenti ketika terjadi error</li>
<li>Logging error secara terpusat</li>
<li>Mengatur standar format error aplikasi</li>
</ul>
<h3 id="bentuk-dasar-error-handling-middleware"><a class="header" href="#bentuk-dasar-error-handling-middleware">Bentuk dasar error-handling middleware</a></h3>
<pre><code class="language-js">app.use((err, req, res, next) =&gt; {
  console.error(err.stack);
  res.status(500).send("Terjadi kesalahan pada server");
});
</code></pre>
<h3 id="contoh-sederhana"><a class="header" href="#contoh-sederhana">Contoh sederhana</a></h3>
<pre><code class="language-js">const express = require("express");
const app = express();

app.use(express.json());

// Route dengan validasi manual
app.post("/register", (req, res, next) =&gt; {
  const { username } = req.body;

  if (!username) {
    const error = new Error("Username wajib diisi");
    error.status = 400;
    return next(error);
  }

  res.send("Register berhasil");
});

// 404 Handler
app.use((req, res, next) =&gt; {
  res.status(404).json({ message: "Endpoint tidak ditemukan" });
});

// Error handler
app.use((err, req, res, next) =&gt; {
  res.status(err.status || 500).json({
    success: false,
    message: err.message,
  });
});

app.listen(3000, () =&gt; console.log("Server berjalan di port 3000"));
</code></pre>
<p>Error-handling middleware harus ditempatkan setelah semua route dan middleware lainnya, karena Express memprosesnya secara berurutan (top-down).</p>
<h2 id="built-in-middleware"><a class="header" href="#built-in-middleware">Built-in Middleware</a></h2>
<p>Built-in middleware adalah middleware bawaan yang sudah disediakan oleh Express tanpa perlu menginstal library tambahan. Middleware ini sangat sering digunakan dalam aplikasi backend untuk memproses body request, menyajikan file statis, dan menangani URL-encoded form. Express menyediakan beberapa built-in middleware utama:</p>
<h3 id="expressjson"><a class="header" href="#expressjson"><code>express.json()</code></a></h3>
<p>Middleware ini digunakan untuk membaca request body yang dikirim dalam format JSON. Tanpa middleware ini, <code>req.body</code> akan bernilai <code>undefined</code>.</p>
<h3 id="contoh-4"><a class="header" href="#contoh-4">Contoh:</a></h3>
<pre><code class="language-js">const express = require("express");
const app = express();

// Mengaktifkan JSON parser
app.use(express.json());

app.post("/data", (req, res) =&gt; {
  res.send({
    message: "Data diterima",
    data: req.body,
  });
});

app.listen(3000, () =&gt; console.log("Server berjalan di port 3000"));
</code></pre>
<h3 id="expressurlencoded"><a class="header" href="#expressurlencoded"><code>express.urlencoded()</code></a></h3>
<p>Middleware untuk membaca body request dari form HTML (seperti <code>application/x-www-form-urlencoded</code>). Biasanya digunakan untuk form login atau register.</p>
<h3 id="contoh-5"><a class="header" href="#contoh-5">Contoh:</a></h3>
<pre><code class="language-js">const express = require("express");
const app = express();
const PORT = 3000;
app.use(express.urlencoded({ extended: true }));

app.get("/login", (req, res) =&gt; {
  res.send(
    "&lt;form method=POST action=/login&gt;&lt;input type=text name=username&gt;&lt;input type=number name=age&gt;&lt;input type=submit&gt;&lt;/form&gt;"
  );
});

app.post("/login", (req, res) =&gt; {
  console.log(req.body);
  res.send("data has been recieved by the server");
});

app.listen(PORT, () =&gt; {
  console.log("Server is running on localhost://3000");
});
</code></pre>
<h3 id="expressstatic"><a class="header" href="#expressstatic"><code>express.static()</code></a></h3>
<p>Middleware ini digunakan untuk menyajikan file statis, seperti:</p>
<ul>
<li>Gambar</li>
<li>CSS</li>
<li>File JavaScript frontend</li>
<li>Dokumen</li>
<li>Asset lainnya</li>
</ul>
<p>Biasanya digunakan untuk folder publik.</p>
<h3 id="contoh-6"><a class="header" href="#contoh-6">Contoh:</a></h3>
<p>Jika kita memiliki sebuah file di <code>public/logo.png</code>.</p>
<pre><code class="language-js">// tambahkan middleware pada aplikasi utama
app.use("/assets", express.static("public"));
</code></pre>
<p>maka dapat diakses <code>http://localhost:3000/assets/logo.png</code></p>
<h2 id="custom-middleware"><a class="header" href="#custom-middleware">Custom Middleware</a></h2>
<p>Custom middleware adalah middleware yang dapat dibuat sendiri oleh pengguna yang biasanya ditujukan untuk menangani kebutuhan tertentu pada aplikasi Express misalnya logging, autentikasi, validasi, hingga memodifikasi objek <code>req</code> atau <code>res</code>.</p>
<p>Middleware custom memiliki struktur dasar:</p>
<pre><code class="language-js">function middlewareName(req, res, next) {
  // logic middleware
  next(); // lanjut ke middleware berikutnya
}
</code></pre>
<p>Middleware wajib memanggil <code>next()</code> agar request dapat diteruskan ke middleware atau route handler berikutnya.</p>
<p>Setelah didefinisikan, middleware bisa digunakan dengan:</p>
<pre><code class="language-js">app.use(middlewareName);
</code></pre>
<p>Atau jika ingin diterapkan pada route tertentu</p>
<pre><code class="language-js">app.get("/route", middlewareName, (req, res) =&gt; {
  res.send("OK");
});
</code></pre>
<h3 id="contoh-custom-logging-request"><a class="header" href="#contoh-custom-logging-request">Contoh: custom logging request</a></h3>
<pre><code class="language-js">const requestLogger = (req, res, next) =&gt; {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  next();
};

app.use(requestLogger);
</code></pre>
<h3 id="contoh-middleware-autentikasi-sederhana"><a class="header" href="#contoh-middleware-autentikasi-sederhana">Contoh: Middleware Autentikasi Sederhana</a></h3>
<pre><code class="language-js">const simpleAuth = (req, res, next) =&gt; {
  const token = req.headers["x-api-key"];

  if (token !== "12345") {
    return res.status(401).json({ message: "Unauthorized" });
  }

  next();
};

// Contoh penggunaan
app.get("/dashboard", simpleAuth, (req, res) =&gt; {
  res.send("Welcome to Dashboard");
});
</code></pre>
<h3 id="contoh-middleware-validasi-sederhana"><a class="header" href="#contoh-middleware-validasi-sederhana">Contoh: Middleware Validasi Sederhana</a></h3>
<pre><code class="language-js">const validateName = (req, res, next) =&gt; {
  const { name } = req.body;

  if (!name) {
    return res.status(400).json({ message: "Name wajib diisi" });
  }

  next();
};

app.post("/hello", validateName, (req, res) =&gt; {
  res.send(`Halo, ${req.body.name}`);
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>Database berfungsi untuk menyimpan dan mengelola data secara permanen, sehingga aplikasi dapat:</p>
<ul>
<li>menyimpan data pengguna,</li>
<li>mengambil daftar produk,</li>
<li>mengupdate informasi,</li>
<li>menghapus data,</li>
</ul>
<p>Pada aplikasi backend, Express bertindak sebagai web server yang menerima <em>request</em> lalu memprosesnya. Biasanya juga berinteraksi dengan database untuk mengambil atau menyimpan data. Menurut <a href="https://expressjs.com/en/guide/database-integration.html">dokumentasi resmi Express</a>, integrasi database dilakukan dengan menggunakan driver database bawaan Node.js seperti <code>Cassandra</code>, <code>Couchbase</code>, <code>CouchDB</code>, <code>MongoDB</code>, <code>MySQL</code>, dll. Namun, pada modul ini kita akan fokus pada MySQL, salah satu database relasional yang paling populer dan sering digunakan untuk aplikasi web skala kecil hingga besar.</p>
<h2 id="instalasi-15"><a class="header" href="#instalasi-15">Instalasi</a></h2>
<p>Untuk menggunakan MySQL pada Express, kita membutuhkan driver Node.js. Library yang direkomendasikan adalah:</p>
<ul>
<li><a href="https://sidorares.github.io/node-mysql2/docs">mysql2</a> merupakan versi lebih modern dari <a href="https://github.com/mysqljs/mysql">mysql</a>.</li>
</ul>
<pre><code class="language-bash">npm i mysql2
</code></pre>
<h2 id="membuat-koneksi-ke-database"><a class="header" href="#membuat-koneksi-ke-database">Membuat Koneksi ke Database</a></h2>
<p>Terdapat dua cara dalam membuat koneksi ke MySQL.</p>
<h3 id="1-koneksi-tunggal-single-connection"><a class="header" href="#1-koneksi-tunggal-single-connection">1. Koneksi Tunggal (Single Connection)</a></h3>
<p>Cocok untuk aplikasi kecil atau latihan.</p>
<pre><code class="language-js">const mysql = require("mysql2");

const db = mysql.createConnection({
  host: "localhost",
  user: "root",
  password: "",
  database: "nama_database",
  port: 3306,
});

db.connect((err) =&gt; {
  if (err) {
    console.error("Gagal koneksi ke database:", err);
    return;
  }
  console.log("Berhasil terkoneksi ke MySQL");
});

module.exports = db;
</code></pre>
<h3 id="2-pool-koneksi"><a class="header" href="#2-pool-koneksi">2. Pool Koneksi</a></h3>
<p>Lebih stabil untuk aplikasi sebenarnya karena dapat mengelola banyak koneksi secara efisien.</p>
<pre><code class="language-js">const mysql = require("mysql2");

const pool = mysql.createPool({
  host: "localhost",
  user: "root",
  password: "",
  database: "nama_database",
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

module.exports = pool.promise();
</code></pre>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<h3 id="select"><a class="header" href="#select"><code>Select</code></a></h3>
<pre><code class="language-js">const db = require("./connection");

async function getDataById(id) {
  try {
    const [rows, field] = await db.query(
      `SELECT * FROM table_data WHERE id=${id}`
    );
    return rows;
  } catch (error) {
    console.log(err);
  }
}
</code></pre>
<ul>
<li><code>.query()</code>: metode untuk mengeksekusi query</li>
<li><code>rows</code>: memuat data hasil query</li>
<li><code>fields</code>: memuat meta data dari baris</li>
</ul>
<p>Jika ingin menggunakan prepared statement. Prepared Statement adalah fitur database untuk mengeksekusi query SQL yang sudah disiapkan sebelumnya dengan parameter dinamis. Dengan cara ini, nilai yang dimasukkan ke query dipisahkan dari struktur query SQL-nya.</p>
<pre><code class="language-js">const db = require("./connection");

async function getDataById(id) {
  try {
    const [rows, field] = await db.execute(
      "SELECT * FROM table_data WHERE id=?",
      [id]
    );
    return rows;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<h3 id="insert"><a class="header" href="#insert"><code>Insert</code></a></h3>
<pre><code class="language-js">async function insertData(value_1, value_2) {
  try {
    const [result, fields] = await db.query(
      `INSERT INTO table_data (col_1, col_2) VALUES (${value_1}, ${value_2})`
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<p>Atau jika ingin menggunakan prepared statement</p>
<pre><code class="language-js">async function insertData(value_1, value_2) {
  try {
    const [result, fields] = await db.execute(
      "INSERT INTO table_data (col_1, col_2) VALUES (?,?)",
      [value_1, value_2]
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<h3 id="update"><a class="header" href="#update"><code>Update</code></a></h3>
<pre><code class="language-js">async function updateData(new_value, edited_id) {
  try {
    const [result, fields] = await db.query(
      `UPDATE table_data SET edited_column = ${new_value} WHERE edited_id = ${edited_id}`
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<p>Atau jika ingin menggunakan prepared statement</p>
<pre><code class="language-js">async function updateData(new_value, edited_id) {
  try {
    const [result, fields] = await db.execute(
      "UPDATE table_data SET edited_column = ? WHERE edited_id = ?",
      [new_value, edited_id]
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<h3 id="delete-1"><a class="header" href="#delete-1"><code>Delete</code></a></h3>
<pre><code class="language-js">async function deleteData(deleted_id) {
  try {
    const [result, fields] = await db.query(
      `DELETE FROM table_data WHERE deleted_id = ${deleted_id}`
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<p>Atau jika ingin menggunakan prepared statement</p>
<pre><code class="language-js">async function deleteData(deleted_id) {
  try {
    const [result, fields] = await db.execute(
      "DELETE FROM table_data WHERE deleted_id = ?",
      [deleted_id]
    );
    return result;
  } catch (error) {
    console.log(error);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p>REST (Representational State Transfer) adalah arsitektur yang menggunakan HTTP sebagai protokol komunikasi. REST API menyediakan serangkaian endpoint untuk melakukan operasi data menggunakan HTTP method standar seperti:</p>
<ul>
<li>GET → mengambil data</li>
<li>POST → menambah data</li>
<li>PUT → mengupdate data</li>
<li>PATCH → mengupdate sebagian data</li>
<li>DELETE → menghapus data</li>
</ul>
<p>Setiap endpoint biasanya mewakili sebuah resource, misalnya:</p>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Contoh Endpoint</th></tr></thead><tbody>
<tr><td>Task</td><td><code>/task</code>, <code>/task/:id</code></td></tr>
<tr><td>User</td><td><code>/user</code>, <code>/user/:id</code></td></tr>
</tbody></table>
</div>
<p>REST API selalu mengembalikan data dalam format JSON sehingga mudah diproses di frontend.</p>
<p><strong>Cara Kerja REST API di Express</strong>
Pada aplikasi Express, alur kerja REST API adalah sebagai berikut:</p>
<ol>
<li>Ketika client mengirim request ke server:</li>
<li>Request masuk ke routing (routes/)</li>
<li>Diteruskan ke controller</li>
<li>Controller memanggil service (business logic)</li>
<li>Service berhubungan dengan repository (query ke database)</li>
<li>Hasil dikembalikan ke controller</li>
<li>Controller mengirim response JSON ke client</li>
</ol>
<h2 id="integrasi-rest-api--express--mysql"><a class="header" href="#integrasi-rest-api--express--mysql">Integrasi REST API + Express + MySQL</a></h2>
<p>Contoh pada modul ini menggunakan database <a href="./assets/todo_app.sql">todo_app</a> dan menerapakan struktur yang rapi (clean architecture sederhana).</p>
<h2 id="struktur-folder"><a class="header" href="#struktur-folder">Struktur Folder</a></h2>
<pre><code class="language-bash">project/
│
├── src/
│  ├── config/
│  │  └── db.js → koneksi MySQL
│  │
│  ├── repositories/  → query SQL (data access layer)
│  │  ├── task.repository.js
│  │  └── user.repository.js
│  │
│  ├── services/  → business logic (domain layer)
│  │  ├── task.service.js
│  │  └── user.service.js
│  │
│  ├── controllers/  → HTTP request handler (interface layer)
│  │  ├── task.controller.js
│  │  └── user.controller.js
│  │
│  ├── routes/
│  │  ├── task.routes.js
│  │  └── user.routes.js
│  │
│  ├── middlewares/
│  │  └── errorHandler.js
│  │
│  └── app.js → konfigurasi Express
│
└── index.js → entry point server
</code></pre>
<h3 id="routing-1"><a class="header" href="#routing-1">Routing</a></h3>
<p>Routing bertugas untuk menerima request berdasarkan URL dan HTTP method, lalu meneruskannya ke controller.</p>
<p>Contoh file <code>src/routes/task.routes.js</code></p>
<pre><code class="language-js">const express = require("express");
const router = express.Router();
const authController = require("../controllers/auth.controller");

router.get("/", taskController.getAllTasks);
router.get("/:id", taskController.getTaskById);
router.post("/", taskController.createTask);
router.put("/:id", taskController.updateTask);
router.delete("/:id", taskController.deleteTask);

module.exports = router;
</code></pre>
<p>Routing hanya berfungsi sebagai penghubung, tidak mengandung logic bisnis maupun query database.</p>
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<p>Controller bertugas:</p>
<ul>
<li>Menerima <em>request</em> (<code>req</code>)</li>
<li>Memanggil service</li>
<li>Mengembalikan response ke client</li>
</ul>
<p>Contoh file <code>src/controllers/task.controller.js</code></p>
<pre><code class="language-js">const taskService = require("../services/task.service");

class TaskController {
  async getTaskById(req, res) {
    try {
      const { id } = req.params;
      const task = await taskService.getTaskById(id);

      res.status(200).json({
        success: true,
        data: task,
      });
    } catch (error) {
      res.status(404).json({
        success: false,
        message: error.message,
      });
    }
  }

  async getUserTasks(req, res) {
    try {
      const { userId } = req.params;
      const result = await taskService.getUserTasks(userId);

      res.status(200).json({
        success: true,
        data: result,
      });
    } catch (error) {
      res.status(404).json({
        success: false,
        message: error.message,
      });
    }
  }

  async createTask(req, res) {
    try {
      const taskData = req.body;
      const result = await taskService.createTask(taskData);

      res.status(201).json(result);
    } catch (error) {
      res.status(400).json({
        success: false,
        message: error.message,
      });
    }
  }

  async updateTask(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      const result = await taskService.updateTask(id, updateData);
      res.status(200).json(result);
    } catch (error) {
      res.status(400).json({
        success: false,
        message: error.message,
      });
    }
  }

  async deleteTask(req, res) {
    try {
      const { id } = req.params;
      const result = await taskService.deleteTask(id);
      res.status(200).json(result);
    } catch (error) {
      res.status(400).json({
        success: false,
        message: error.message,
      });
    }
  }
}

module.exports = new TaskController();
</code></pre>
<h3 id="service"><a class="header" href="#service">Service</a></h3>
<p>Service berisi logic aplikasi, misalnya:</p>
<ul>
<li>Validasi tambahan</li>
<li>Aturan bisnis</li>
<li>Pengolahan data sebelum atau sesudah dari database</li>
</ul>
<p>Contoh file <code>src/services/task.service.js</code></p>
<pre><code class="language-js">const taskRepository = require("../repositories/task.repository");

class TaskService {
  async getTaskById(id) {
    const task = await taskRepository.findById(id);
    if (!task) throw new Error("Task tidak ditemukan");
    return task;
  }

  async getUserTasks(userId) {
    const tasks = await taskRepository.findByUserId(userId);
    if (!tasks) throw new Error("Task dari user ini tidak ditemukan");
    return tasks;
  }

  async createTask(taskData) {
    const createdTask = await taskRepository.createTask(taskData);
    if (!createdTask) throw new Error("Gagal menambahkan task");
    return {
      success: true,
      message: "Berhasil menambahkan task baru",
    };
  }

  async updateTask(id, updatedData) {
    const existingData = await taskRepository.findById(id);
    if (!existingData) throw new Error("Task tidak ditemukan");

    const result = await taskRepository.updateTask(id, updatedData);
    return {
      success: true,
      message: result
        ? "Berhasil memperbarui data task"
        : "Tidak ada task yang diperbarui",
    };
  }

  async deleteTask(id) {
    const existingData = await taskRepository.findById(id);
    if (!existingData) throw new Error("Task tidak ditemukan");

    const result = await taskRepository.deleteTask(id);

    return {
      success: true,
      message: result
        ? "Berhasil menghapus data task"
        : "Tidak ada task yang dihapus",
    };
  }
}

module.exports = new TaskService();
</code></pre>
<h3 id="repository"><a class="header" href="#repository">Repository</a></h3>
<p>Repository bertugas untuk menangani komunikasi dengan database, menggunakan query SQL seperti yang telah dibahas pada materi <a href="./database-express-js.html">Database</a>.</p>
<p>Contoh file <code>repositories/task.repository.js</code>:</p>
<pre><code class="language-js">const db = require("../configs/db");

class TaskRepository {
  async findById(id) {
    const query = "SELECT * FROM tb_tasks WHERE id=?";
    const [result] = await db.execute(query, [id]);
    return result[0] || null;
  }

  async findByUserId(user_id) {
    const query = "SELECT * FROM tb_tasks WHERE user_id=?";
    const [result] = await db.execute(query, [user_id]);
    return result;
  }

  async createTask(taskData) {
    const keys = Object.keys(taskData);
    const values = Object.values(taskData);

    const query = `INSERT INTO tb_tasks (${keys.join(", ")}) VALUES (${keys
      .map((_) =&gt; "?")
      .join(", ")})`;
    const [result] = await db.execute(query, values);
    return result.affectedRows &gt; 0;
  }

  async updateTask(id, taskData) {
    const keys = Object.keys(taskData);
    const values = Object.values(taskData);

    const query = `UPDATE tb_tasks SET ${keys
      .map((key) =&gt; key + "=?")
      .join(", ")} WHERE id=?`;
    const [result] = await db.execute(query, [...values, id]);
    return result.affectedRows &gt; 0;
  }

  async deleteTask(id) {
    const query = `DELETE FROM tb_tasks WHERE id=?`;
    const [result] = await db.execute(query, [id]);
    return result.affectedRows &gt; 0;
  }
}

module.exports = new TaskRepository();
</code></pre>
<p>Dengan pendekatan ini, query database terisolasi dan mudah dikelola.</p>
<h3 id="database-1"><a class="header" href="#database-1">Database</a></h3>
<pre><code class="language-js">const mysql = require('mysql2/promise');

const pool = mysql.createPool({
    host: localhost,
    user: root,
    password: ,
    database: todo_app,
    port: 3306,
    waitForConnections: true,
    connectionLimit: 10,
});

module.exports = pool;
</code></pre>
<h3 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h3>
<p>Middleware dapat digunakan untuk:</p>
<ul>
<li>Logging</li>
<li>Validasi input</li>
<li>Autentikasi</li>
<li>Error handling</li>
</ul>
<p>Contoh file <code>src/middlewares/error_handler.js</code></p>
<pre><code class="language-js">module.exports = (err, req, res, next) =&gt; {
  console.log(err);
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    method: req.method,
    url: req.originalUrl,
    message: err.message || "Internal Server Error",
  });
};
</code></pre>
<h3 id="gabungkan-semuanya"><a class="header" href="#gabungkan-semuanya">Gabungkan Semuanya</a></h3>
<p><code>src/app.js</code></p>
<pre><code class="language-js">const express = require("express");
const errorHandler = require("./middlewares/error_handler");
const taskRoutes = require("./routes/task.routes");

const app = express();
app.use(express.json());
app.use(express.urlencoded());

app.use("task", taskRoutes);

app.use(errorHandler);
module.exports = app;
</code></pre>
<p><code>index.js</code></p>
<pre><code class="language-js">require("dotenv").config();
const app = require("./src/app");

const PORT = 3000;

app.listen(PORT, () =&gt; {
  console.log(`Server berjalan pada http://localhost:${PORT}`);
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validasi-input"><a class="header" href="#validasi-input">Validasi Input</a></h1>
<p>Validasi input merupakan proses penting dalam pengembangan aplikasi backend untuk memastikan bahwa data yang dikirim oleh client benar-benar sesuai dengan yang diharapkan oleh server. Proses ini dilakukan sebelum data diproses lebih lanjut atau disimpan ke dalam database.</p>
<p>Dengan validasi input, aplikasi dapat memastikan bahwa data yang diterima:</p>
<ul>
<li>Memiliki format yang benar</li>
<li>Tidak kosong jika wajib diisi</li>
<li>Sesuai dengan aturan bisnis</li>
<li>Aman sebelum diproses atau disimpan ke database</li>
</ul>
<p>Tanpa validasi yang baik, aplikasi berisiko menerima data tidak valid yang dapat menyebabkan error, inkonsistensi data, hingga celah keamanan.</p>
<p>Dalam aplikasi Express, data dari client dapat dikirim melalui beberapa bagian request, yaitu <code>req.body</code>, <code>req.params</code>, dan <code>req.query</code>. Semua sumber data tersebut perlu divalidasi, karena seluruhnya berasal dari input eksternal.</p>
<p>Validasi input sebenarnya dapat dilakukan secara manual menggunakan kondisi <code>if</code>, misalnya:</p>
<pre><code class="language-js">if (!req.body.email) {
  return res.status(400).json({ message: "Email wajib diisi" });
}
</code></pre>
<p>Pendekatan ini masih dapat diterima untuk aplikasi yang sangat kecil. Namun, pendekatan ini kurang direkomendasikan untuk aplikasi berskala menengah hingga besar. Oleh karena itu, Express menyediakan kemudahan integrasi dengan library pihak ketiga. Salah satu library yang paling umum dan direkomendasikan adalah <a href="https://express-validator.github.io/docs">express-validator</a>. <code>express-validator</code> merupakan middleware berbasis <code>validator.js</code> yang terintegrasi langsung dengan Express.</p>
<h2 id="instalasi-16"><a class="header" href="#instalasi-16">Instalasi</a></h2>
<p>Untuk mulai menggunakan <code>express-validator</code>, instal terlebih dahulu library-nya:</p>
<pre><code class="language-bash">npm install express-validator
</code></pre>
<p>Setelah instalasi selesai, kita dapat langsung menggunakan <code>express-validator</code> sebagai middleware pada route Express untuk melakukan validasi input.</p>
<h2 id="konsep-dasar-validasi"><a class="header" href="#konsep-dasar-validasi">Konsep Dasar Validasi</a></h2>
<p>Validasi pada Express umumnya terdiri dari dua bagian:</p>
<ol>
<li>Aturan validasi (validation rules)</li>
<li>Handler hasil validasi (menangani error validasi)</li>
</ol>
<p>express-validator menyediakan fungsi <code>body</code>, <code>param</code>, dan <code>query</code> untuk mendefinisikan aturan validasi.</p>
<h2 id="membuat-aturan-validasi"><a class="header" href="#membuat-aturan-validasi">Membuat Aturan Validasi</a></h2>
<p>Buat file <code>validators/task.validator.js</code>:</p>
<pre><code class="language-js">const { body } = require("express-validator");

exports.createTaskValidation = [
  body("title").notEmpty().withMessage("Title tidak boleh kosong"),

  body("description")
    .optional()
    .isString()
    .withMessage("Description harus berupa string"),
];
</code></pre>
<p>Penjelasan:</p>
<ul>
<li><code>body("title")</code>: mengambil data dari req.body.title</li>
<li><code>notEmpty()</code>: field tidak boleh kosong</li>
<li><code>withMessage()</code>: pesan error kustom</li>
<li><code>optional()</code>: field boleh tidak dikirim</li>
</ul>
<p>Rule lainnya dapat dilihat pada <a href="https://express-validator.github.io/docs/api/validation-chain/">laman ini</a></p>
<h2 id="menangani-hasil-validasi"><a class="header" href="#menangani-hasil-validasi">Menangani Hasil Validasi</a></h2>
<p>Aturan validasi yang dibuat menggunakan express-validator tidak otomatis menghentikan request ketika terjadi kesalahan. Express hanya akan mencatat hasil validasi tersebut. Oleh karena itu, kita membutuhkan satu middleware tambahan untuk:</p>
<ul>
<li>Mengumpulkan hasil validasi</li>
<li>Mengecek apakah terdapat error</li>
<li>Menghentikan request jika validasi gagal</li>
<li>Meneruskan request jika validasi berhasil</li>
</ul>
<p>Middleware inilah yang biasanya disebut sebagai <code>validate</code>.</p>
<p><strong>src/middleware/validate.js</strong></p>
<pre><code class="language-js">const { validationResult } = require("express-validator");

const validate = (req, res, next) =&gt; {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: "Validasi gagal",
      errors: errors.array(),
    });
  }
  next();
};

module.exports = validate;
</code></pre>
<p>Cara Kerja Middleware validate</p>
<ol>
<li><code>validationResult(req)</code> mengambil seluruh hasil validasi yang sebelumnya dijalankan</li>
<li>Jika terdapat error:
<ul>
<li>Request dihentikan</li>
<li>Server mengirim response status <code>400</code></li>
<li>Daftar error dikirim ke client</li>
</ul>
</li>
<li>Jika tidak ada error:
<ul>
<li><code>next()</code> dipanggil</li>
<li>Request diteruskan ke request handler</li>
</ul>
</li>
</ol>
<h2 id="contoh-validasi-reqbody"><a class="header" href="#contoh-validasi-reqbody">Contoh Validasi <code>req.body</code></a></h2>
<p>Misalnya kita memiliki endpoint untuk membuat user dan ingin memastikan:</p>
<ul>
<li><code>username</code> wajib diisi.</li>
<li><code>email</code> harus berupa email yang valid.</li>
</ul>
<p><strong>src/validators/user.validation.js</strong></p>
<pre><code class="language-js">const { body } = require("express-validator");

exports.createUserValidator = [
  body("username").notEmpty().withMessage("Username wajib diisi"),
  body("email").isEmail().withMessage("Format email tidak valid"),
];
</code></pre>
<p>Penjelasan:</p>
<ul>
<li><code>body("username")</code> mengambail nilai dari <code>req.body.username</code>.</li>
<li><code>body("email")</code> mengambil nilai dari <code>req.body.email</code>.</li>
<li><code>.notEmpty()</code> memastikan nilainya tidak kosong.</li>
<li><code>.isEmail()</code> memastikan format email valid.</li>
<li><code>withMessage()</code> menentukan pesan error jika validasi gagal.</li>
</ul>
<p>Selanjutnya, tambahkan validator beserta middleware ke dalam route</p>
<p><strong>src/routes/user.routes.js</strong></p>
<pre><code class="language-js">const { createUserValidator } = require("../validators/user.validation");
const validate = require("../middlewares/validate");

router.post("/users", createUserValidator, validate, (req, res) =&gt; {
  res.json({ message: "User berhasil dibuat" });
});
</code></pre>
<p>Selain melakukan validasi terhadap objek <code>req.body</code>, <code>express-validator</code> juga memungkinkan untuk memvalidasi parameter URL dan Query parameter.</p>
<h2 id="validasi-parameter-url"><a class="header" href="#validasi-parameter-url">Validasi Parameter URL</a></h2>
<p>Untuk endpoint seperti:</p>
<pre><code class="language-yaml">GET /users/:id
</code></pre>
<p>Kita dapat memvalidasi parameter <code>id</code> sebagai berikut:</p>
<pre><code class="language-js">const { param } = require("express-validator");

exports.userIdValidator = [
  param("id").isInt().withMessage("ID harus berupa angka"),
];
</code></pre>
<p>Penjelasan:</p>
<ul>
<li><code>param("id")</code> mengambail nilai dari <code>req.params.id</code>.</li>
<li><code>isInt()</code> memastikan parameter berupa angka.</li>
<li><code>withMessage()</code> menentukan pesan error jika validasi gagal.</li>
</ul>
<h2 id="validasi-query-parameter"><a class="header" href="#validasi-query-parameter">Validasi Query Parameter</a></h2>
<p>Query parameter biasanya digunakan untuk kebutuhan seperti filtering, sorting, atau pagination.</p>
<p>Contoh endpoint:</p>
<pre><code class="language-yaml">GET /users?search=John&amp;status=true
</code></pre>
<p>Kita dapat memvalidasi query sebagai berikut:</p>
<pre><code class="language-js">const { query } = require("express-validator");

exports.userQueryValidator = [
  query("search")
    .optional()
    .trim()
    .notEmpty()
    .withMessage("Search tidak boleh kosong"),

  query("status").optional().isBoolean().withMessage("Status harus boolean"),
];
</code></pre>
<p>Penjelasan:</p>
<ul>
<li><code>query("search")</code> mengambil nilai dari req.query.search</li>
<li><code>optional()</code> menandakan bahwa parameter tidak wajib</li>
<li><code>trim()</code> menghapus spasi di awal dan akhir</li>
<li><code>isBoolean()</code> memastikan nilai berupa boolean</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
