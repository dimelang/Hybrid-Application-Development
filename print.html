<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hybrid Application Development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hybrid Application Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pendahuluan"><a class="header" href="#pendahuluan">Pendahuluan</a></h1>
<h2 id="apa-itu-react-native"><a class="header" href="#apa-itu-react-native">Apa itu React Native?</a></h2>
<p>React Native adalah <strong>framework open-source</strong> yang dikembangkan oleh <strong>Meta (Facebook)</strong> untuk membangun aplikasi mobile <strong>Android</strong> dan <strong>iOS</strong> menggunakan bahasa pemrograman <strong>JavaScript</strong> atau <strong>TypeScript</strong>.<br />
Dengan React Native, developer dapat menulis satu basis kode dan menjalankannya di berbagai platform tanpa harus menulis kode terpisah untuk Android (Java/Kotlin) dan iOS (Objective-C/Swift).</p>
<hr />
<h2 id="mengapa-react-native"><a class="header" href="#mengapa-react-native">Mengapa React Native?</a></h2>
<p>Beberapa alasan mengapa React Native populer di kalangan developer:</p>
<ol>
<li>
<p><strong>Cross-Platform</strong><br />
Satu kode bisa berjalan di Android dan iOS.</p>
</li>
<li>
<p><strong>Performance Lebih Baik dibanding Hybrid Webview</strong><br />
React Native menggunakan komponen native, bukan sekadar membungkus aplikasi web.</p>
</li>
<li>
<p><strong>Hot Reloading &amp; Fast Refresh</strong><br />
Mempercepat proses pengembangan karena perubahan kode bisa langsung dilihat tanpa build ulang penuh.</p>
</li>
<li>
<p><strong>Ekosistem &amp; Komunitas Besar</strong><br />
Banyak library, tutorial, dan komunitas aktif.</p>
</li>
<li>
<p><strong>Dukungan TypeScript</strong><br />
Menjadikan aplikasi lebih aman dan maintainable.</p>
</li>
</ol>
<hr />
<h2 id="arsitektur-dasar-react-native"><a class="header" href="#arsitektur-dasar-react-native">Arsitektur Dasar React Native</a></h2>
<p>Secara garis besar, arsitektur React Native terdiri dari:</p>
<ul>
<li><strong>JavaScript Layer</strong> → tempat kode aplikasi ditulis (JS/TS).</li>
<li><strong>Bridge</strong> → penghubung antara JavaScript dan kode native.</li>
<li><strong>Native Layer</strong> → komponen asli Android/iOS (misalnya <code>View</code>, <code>Text</code>, <code>Button</code>).</li>
</ul>
<hr />
<h2 id="perbedaan-react-native-dengan-framework-lain"><a class="header" href="#perbedaan-react-native-dengan-framework-lain">Perbedaan React Native dengan Framework Lain</a></h2>
<ul>
<li><strong>Flutter</strong> → menggunakan bahasa Dart dan rendering engine sendiri.</li>
<li><strong>Ionic / Cordova</strong> → berbasis WebView.</li>
<li><strong>React Native</strong> → menggunakan komponen asli (native component) sehingga performa lebih dekat ke aplikasi native.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-script-intro"><a class="header" href="#type-script-intro">Pengenalan TypeScript</a></h1>
<h2 id="apa-itu-typescript"><a class="header" href="#apa-itu-typescript">Apa itu TypeScript?</a></h2>
<p>TypeScript adalah superset dari JavaScript yang artinya seluruh kode JavaScript valid bisa dijalankan di TypeScript, tapi TypeScript menambahkan fitur baru, yang paling penting adalah static typing.</p>
<p>Dengan TypeScript, kita bisa menentukan tipe data untuk variabel, fungsi, maupun objek, sehingga kesalahan bisa dicegah sejak proses pengembangan (compile time), bukan saat aplikasi sudah berjalan (runtime).</p>
<h2 id="mengapa-typescript-dibutuhkan"><a class="header" href="#mengapa-typescript-dibutuhkan">Mengapa TypeScript Dibutuhkan?</a></h2>
<p>JavaScript sangat fleksibel (loosely typed), tapi justru karena itu sering menimbulkan bug yang sulit dilacak. Misalnya:</p>
<pre><code class="language-js">let age = 25;
age = "dua puluh lima"; // JavaScript tidak error
</code></pre>
<p>Kalau kode di atas berjalan di aplikasi besar, bisa menimbulkan error tidak terduga.
Dengan TypeScript:</p>
<pre><code class="language-ts">let age: number = 25;
age = "dua puluh lima"; // ❌ Error saat compile
</code></pre>
<p>Dengan demikian, menggunakan typescript, kesalahan dapat terdeteksi lebih awal.</p>
<h3 id="keunggulan-yang-dimiliki-oleh-typescript"><a class="header" href="#keunggulan-yang-dimiliki-oleh-typescript">Keunggulan yang dimiliki oleh TypeScript:</a></h3>
<ol>
<li><strong>Type safety</strong>, kode lebih aman karena ada pemeriksaan tipe.</li>
<li><strong>Autocompletion</strong>, beberap editor bisa memberi saran kode yang lebih akurat.</li>
<li><strong>Lebih mudah dipelihara</strong>, terutama di proyek besar dengan banyak developer.</li>
<li><strong>Mendukung fitur modern JavaScript</strong>, TypeScript selalu up-to-date dengan ECMAScript terbaru.</li>
<li><strong>Kompatibel dengan JavaScript</strong>, kode JS bisa langsung dipakai di TS.</li>
</ol>
<h2 id="instalasi"><a class="header" href="#instalasi">Instalasi</a></h2>
<p>Sebelum menggunakan TypeScript, pastikan di komputer teman-teman sudah menginstal <a href="https://nodejs.org/en/download">Node.js</a>. Untuk memastikan <strong>Node.js</strong> sudah berhasil diinstal, silahkan jalankan perintah berikut di dalam terminal/CMD.</p>
<pre><code>node -v
</code></pre>
<p>Hasilnya adalah versi dari <strong>Node.js</strong> yang diinstal. Selanjutnya, lakukan instalasi TypeScript melalui <em>npm</em>. Jalankan perintah berikut untuk menginstal TypeScript secara <em>global</em>.</p>
<pre><code>npm install -g typescript
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membuat-dan-menjalankan-program-typescript"><a class="header" href="#membuat-dan-menjalankan-program-typescript">Membuat dan Menjalankan Program TypeScript</a></h1>
<p>Sekarang mari buat file TypeScript pertama kita. TypeScript dapat ditulis dalam file <code>.ts</code> yang nantinya akan dikompilasi ke JavaScript lalu jalankan menggunakan <strong>Node.js</strong>.</p>
<h2 id="langkah-langkah"><a class="header" href="#langkah-langkah">Langkah-langkah</a></h2>
<ol>
<li>
<p>Buat file <code>hello.ts</code></p>
<pre><code class="language-ts">let word: string = "World";
console.log(`Hello, ${word}!`);
</code></pre>
</li>
<li>
<p>Kompilasi file <code>hello.ts</code> ke JavaScript menggunakan perintah berikut di terminal/CMD.</p>
<pre><code class="language-bash">tsc hello.ts
</code></pre>
<p>Nantinya, akan tercipta sebuah file baru yaitu <code>hello.js</code></p>
</li>
<li>
<p>Jalankan dengan Node.js menggunakan perintah termnial/CMD berikut</p>
<pre><code>node hello.js
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar"><a class="header" href="#konsep-typescript-1-tipe-data-dasar">Konsep TypeScript 1: Tipe Data Dasar</a></h1>
<p>Di JavaScript, kita bebas memberikan nilai apapun ke sebuah variabel. Ini tentunya sangat fleksibel, tapi berpotensi menyebabkan bug. Seperti yang telah dijelaskan <a href="./typescript.html">di awal</a>. TypeScript hadir dengan sistem tipe yang ketat: kita bisa mendefinisikan sejak awal bahwa variabel hanya boleh menyimpan data dengan tipe tertentu. Dengan cara ini, kesalahan dapat dideteksi lebih awal, bahkan sebelum program dijalankan. TypeScript memiliki beberapa tipe data dasar, yaitu</p>
<ol>
<li>
<p><strong>String</strong></p>
<p>Digunakan untuk menyimpan data string yang menggunakan <code>"</code> atau <code>'</code></p>
<pre><code class="language-ts">let word: string = "World";
let greeting: string = `Hello, ${word}!`;
</code></pre>
</li>
</ol>
<hr />
<ol start="2">
<li>
<p><strong>Number</strong></p>
<p>Digunakan untuk menyimpan data numerik seperti (integer, float/pecahan, heksadesimal, oktal)</p>
<pre><code class="language-ts">let age: number = 25;
let pi: number = 3.14;
let hex: number = 0xff;   // 255
let binary: number = 0b1010; // 10
let octal: number = 0o744; // 484
</code></pre>
</li>
</ol>
<hr />
<ol start="3">
<li><strong>Boolean</strong>
Digunakan untuk menyimpan data yang bernilai <code>true</code> atau <code>false</code>
<pre><code class="language-ts">let isActive: boolean = true;
let isAdmin: boolean = false;
</code></pre>
</li>
</ol>
<hr />
<ol start="4">
<li>
<p><strong>Null dan Undefined</strong></p>
<p><code>null</code> merupakan nilai kosong yang diberikan secara eksplisit. Akan dikonversi menjadi 0 dalam operasi aritmatika.
<code>undefined</code> merupakan nilai default ketika suatu variable belum diberi nilai. Akan menghasilkan NaN (Not a Number) dalam operasi aritmatika.</p>
<pre><code class="language-ts">let emptyValue: null = null;
let notAssigned: undefined = undefined;
</code></pre>
</li>
</ol>
<hr />
<p>Selain tipe data dasar di atas, TypeScript juga memiliki beberapa tipe data khusus seperti</p>
<ol>
<li>
<p><strong>Any</strong></p>
<p>Tipe data yang menonaktifkan pemeriksaan tipe sehingga memperbolehkan variable atau fungsi menerima dan menampung nilai dari tipe data apapun. Tapi ini menghilangkan manfaat TypeScript, jadi gunakan hanya jika perlu.</p>
<pre><code class="language-ts">let randomValue: any = 10;
randomValue = "Hello"; // tidak error
randomValue = true;    // tidak error
</code></pre>
</li>
<li>
<p><strong>Unknown</strong></p>
<p>Tipe data yang merepresentasikan nilai yang tipenya tidak diketahui atau tidak pasti pada saat kompilasi. Mirip <code>any</code>, tapi lebih aman. Kita harus cek tipe sebelum digunakan.</p>
<pre><code class="language-ts">let input: unknown = "Hello";
if (typeof input === "string") {
    console.log(input.toUpperCase()); // HELLO
}

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar-lanjutan"><a class="header" href="#konsep-typescript-1-tipe-data-dasar-lanjutan">Konsep TypeScript 1: Tipe Data Dasar Lanjutan</a></h1>
<ol>
<li>
<p><strong>Array</strong></p>
<p>TypeScript juga memiliki beberapa struktur data yang juga terdapat dalam JavaScript. Array digunakan untuk menyimpan sekumpulan nilai dengan urutan tertentu. Bedanya, di TypeScript kita bisa menentukan tipe data yang boleh ada di dalam array. Hal ini membuat array kita lebih konsisten, karena semua elemennya punya tipe yang sama."</p>
<pre><code class="language-ts">let numbers: number[] = [1, 2, 3, 4];
let names: string[] = ["Ani", "Budi", "Citra"];
</code></pre>
<p>Atau dengan generics</p>
<pre><code class="language-ts">let scores: Array&lt;number&gt; = [90, 80, 100];
</code></pre>
</li>
<li>
<p><strong>Tuple</strong></p>
<p>Jenis struktur data seperti array yang memiliki panjang tetap dan tipe data yang ditentukan untuk setiap posisinya. Ini berbeda dari array biasa karena tuple menjamin jumlah elemen dan urutan tipenya. Tuple cocok digunakan untuk merepresentasikan kumpulan nilai yang terstruktur, seperti koordinat (x, y) atau nilai RGB (merah, hijau, biru), di mana setiap posisi memiliki arti yang jelas</p>
<pre><code class="language-ts">let person: [string, number] = ["Alice", 25]; // Di sini, elemen pertama wajib diisi dengan string dan elemen kedua adalah numerik
console.log(person[0]); // Alice
console.log(person[1]); // 25
</code></pre>
</li>
<li>
<p><strong>Enum</strong></p>
<p>Sekumpulan nilai konstan yang lebih mudah dibaca. Pada TypeScript <code>Enum</code> disediakan dalam bentuk numeric dan string atau bahkan keduanya. Untuk mendefiniskan <code>Enum</code> kita menggunakan keyword <code>enum</code>.</p>
<pre><code class="language-ts">enum NameOfEnum {
   member: constantValue // constantValue is optional
}
</code></pre>
<p><strong>Numeric Enums</strong>
Artinya adalah kita melakukan inisiasi pada member dengan tipe data Number.</p>
<pre><code class="language-ts">enum Direction {
    Up=1,
    Down,
    Left,
    Right
}

let move_up: Direction = Direction.Up;
let move_down: Direction = Direction.Down;
let move_left: Direction = Direction.Left;
let move_right: Direction = Direction.Right;

console.log(move_up); // 1
console.log(move_down); // 2
console.log(move_left); // 3
console.log(move_right); // 4
</code></pre>
<p>Enum pada TypeScript menganut sistem Auto Incerement dari setelah member yand diberi inisiasi</p>
<p><strong>String Enums</strong>
Pada dasarnya sama dengan Numeric Enums hanya saja perbedaanya adalah ketika kita assign pada member tipenya adalah String. Dan satu hal lagi tidak ada konsep Auto Increment pada String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up="UP",
    Down="DOWN",
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
<p><strong>Heterogeneous Enums</strong>
Enum jenis ini adalah gabungan dari Numeric Enums dan String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up=0,
    Down=1,
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
</li>
<li>
<p><strong>Union</strong>
Fitur yang memungkinkan sebuah variabel memiliki salah satu dari beberapa tipe data yang berbeda atau lebih sederhananya bisa menyimpan lebih dari satu tipe.</p>
<pre><code class="language-ts">let id: string | number;
id = "ABC123"; // ✅
id = 101;      // ✅
id = true;     // ❌ Error

</code></pre>
</li>
<li>
<p><strong>Literal</strong>
Variable yang membatasi nilai hanya ke konstanta tertentu.</p>
<pre><code class="language-ts">let direction: "up" | "down";
direction = "up";   // ✅
direction = "down"; // ✅
direction = "left"; // ❌ Error

</code></pre>
</li>
</ol>
<p>Sebenarnya, TypeScript memiliki mekanisme untuk menentukan tipe data dari suatu variable berdasarkan nilainya (type inference).</p>
<pre><code class="language-ts">let city = "Semarang"; // otomatis string
city = 123; // ❌ Error
</code></pre>
<p>Jika deklarasi tanpa nilai</p>
<pre><code class="language-ts">let data; // otomatis any
data = "Hello";
data = 123;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-2-function--parameter"><a class="header" href="#konsep-typescript-2-function--parameter">Konsep TypeScript 2: Function &amp; Parameter</a></h1>
<p>Dalam JavaScript, function bisa menerima argumen apa saja dan mengembalikan apapun. Ini tentunya sangat fleksibel, tapi rawan error. Dengan TypeScript, kita bisa menentukan tipe parameter dan tipe return value, sehingga function lebih jelas dan aman.</p>
<p>Contoh JavaScript:</p>
<pre><code class="language-js">function add(a, b) {
  return a + b;
}

console.log(add(10, "20")); // "1020" → salah paham jadi string
</code></pre>
<p>Contoh TypeScript</p>
<pre><code class="language-ts">function add(a: number, b: number): number {
  return a + b;
}

console.log(add(10, 20)); // 30
console.log(add(10, "20")); // ❌ Error

</code></pre>
<pre><code class="language-ts">function full_name(first_name: string, last_name: string): string {
  return first_name + last_name;
}

console.log(full_name("Georgy", "Adelson")); // Georgy Adelson
console.log(full_name("Georgy", 62)); // ❌ Error

</code></pre>
<p>Jika function tidak mengembalikan nilai, gunakan <code>void</code> sebagai return type</p>
<pre><code class="language-ts">function logMessage(message: string): void {
  console.log(message);
}
</code></pre>
<h2 id="optional-parameter-"><a class="header" href="#optional-parameter-">Optional Parameter (?)</a></h2>
<p>Parameter dalam TypeScript dapat dibuat opsional dengan tanda <code>?</code>, sehingga boleh tidak diisi.</p>
<pre><code class="language-ts">function sayHello(name?: string): string {
    return name ? `Hello, ${name}` : "Hello, stranger!";
}

console.log(sayHello("Georgy")); // Hello, Georgy
console.log(sayHello());        // Hello, stranger!
</code></pre>
<h2 id="deafult-parameter"><a class="header" href="#deafult-parameter">Deafult Parameter</a></h2>
<p>Kita juga dapat memberi nilai default pada parameter.</p>
<pre><code class="language-ts">function greetUser(name: string = "Guest"): string {
  return `Welcome, ${name}!`;
}

console.log(greetUser());       // Welcome, Guest!
console.log(greetUser("Georgy"));  // Welcome, Ani!
</code></pre>
<h2 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h2>
<p>Jika jumlah parameter tidak menentu, kita dapat menggunakan <code>...</code></p>
<pre><code class="language-ts">function sumAll(...numbers: number[]): number {
  return numbers.reduce((acc, curr) =&gt; acc + curr, 0);
}

console.log(sumAll(1, 2, 3, 4, 5)); // 15
</code></pre>
<h2 id="function-expression"><a class="header" href="#function-expression">Function Expression</a></h2>
<p>Selain deklarasi biasa, kita juga bisa menuliskan function sebagai ekspresi</p>
<pre><code class="language-ts">const multiply = function (a: number, b: number): number {
  return a * b;
};
</code></pre>
<h2 id="arrow-function-"><a class="header" href="#arrow-function-">Arrow Function (=&gt;)</a></h2>
<p>Arrow function disediakan untuk meringkas penulisa sebuah function sederhana</p>
<pre><code class="language-ts">const divide = (a: number, b: number): number =&gt; a / b;

console.log(divide(10, 2)); // 5
</code></pre>
<h2 id="overloading-function"><a class="header" href="#overloading-function">Overloading Function</a></h2>
<p>TypeScript mendukung overloading yaitu function dengan bentuk parameter berbeda tapi memiliki nama yang sama</p>
<pre><code class="language-ts">function combine(a: string, b: string): string;
function combine(a: number, b: number): number;
function combine(a: any, b: any): any {
  return a + b;
}

console.log(combine(10, 20));     // 30
console.log(combine("Hello, ", "World")); // Hello, World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-3-object--interface"><a class="header" href="#konsep-typescript-3-object--interface">Konsep TypeScript 3: Object &amp; Interface</a></h1>
<h2 id="objek"><a class="header" href="#objek">Objek</a></h2>
<p>Dalam JavaScript, objek adalah kumpulan properti yang menyimpan berbagai data. Pada TypeScript, kita bisa menentukan tipe properti dalam sebuah objek sehingga lebih jelas struktur datanya.</p>
<p>Contoh sederhana:</p>
<pre><code class="language-ts">let user: { name: string; age: number; isAdmin: boolean } = {
  name: "Max",
  age: 25,
  isAdmin: true
};

console.log(user.name); // Max
</code></pre>
<p>Pastikan ketika memberikan nilai untuk setiap properti sudah sesuai dengan tipe data yang didefinisikan.</p>
<p>Selain pada function, operator optional <code>?</code> juga dapat digunakan pada objek.</p>
<pre><code class="language-ts">let product: { id: number; name: string; description?: string } = {
  id: 101,
  name: "Laptop"
};

console.log(product.description); // undefined
</code></pre>
<h4 id="readonly-property"><a class="header" href="#readonly-property">Readonly Property</a></h4>
<p>Dalam TypeScript, properti dapat dibuat tidak bisa diubah. Caranya adalah menambahkan syntax <code>readonly</code> sebelum nama properti.</p>
<pre><code class="language-ts">let car: { readonly band: string; year: number } = {
  brand: "Dream Theater",
  year: 1985
};

car.year = 1968;     // ✅ Bisa diubah
car.brand = "Led Zeppelin"; // ❌ Error
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Interface adalah cara mendefinisikan bentuk dari sebuah objek dengan lebih rapi dan bisa digunakan berulang kali. Kalau tadi kita mendefinisikan tipe objek langsung di variabel, sekarang kita bisa memisahkan definisinya agar lebih mudah dibaca.</p>
<p>Contoh interface sederhana</p>
<pre><code class="language-ts">interface User {
  name: string;
  age: number;
  isAdmin: boolean;
}

let admin: User = {
  name: "Ani",
  age: 30,
  isAdmin: true
};
</code></pre>
<p>Fitur opsional <code>?</code> dan <code>readonly</code> juga dapat diterapkan pada interface.</p>
<pre><code class="language-ts">interface Product {
  readonly id: number;
  name: string;
  description?: string;
}

let item: Product = {
  id: 123,
  name: "Smartphone"
};

item.name = "Tablet";   // ✅
item.id = 456;          // ❌ Error
</code></pre>
<p>Selain menggunakan properti dengan nilai tunggal, properti pada interface juga bisa mendefinisikan bentuk function.</p>
<pre><code class="language-ts">interface Person {
  name: string;
  greet(): void;
}

let user1: Person = {
  name: "John",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

user1.greet(); // Hello, my name is John
</code></pre>
<p>Interface juga bisa mewarisi (extend) sifat ke interface lainnya.</p>
<pre><code class="language-ts">interface Animal {
  name: string;
  sound(): void;
}

interface Dog extends Animal {
  breed: string;
}

let myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
  sound() {
    console.log("Woof woof!");
  }
};

myDog.sound(); // Woof woof!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-4-union--intersection"><a class="header" href="#konsep-typescript-4-union--intersection">Konsep TypeScript 4: Union &amp; Intersection</a></h1>
<p>Dalam pemrograman nyata, kadang sebuah variabel bisa menampung lebih dari satu tipe data. Misalnya, ID user bisa berupa number atau string.</p>
<h2 id="union-types-"><a class="header" href="#union-types-">Union Types (<code>|</code>)</a></h2>
<p>Union <code>|</code> berarti salah satu dari beberapa tipe.
Contoh sederhana</p>
<pre><code class="language-ts">let userId: number | string;

userId = 101;       // ✅ number
userId = "A102";    // ✅ string
userId = true;      // ❌ Error: Type 'boolean' is not assignable
</code></pre>
<p>Selain digunakan dalam variable, union (<code>|</code>) juga dapat digunakan pada function
contoh union pada function</p>
<pre><code class="language-ts">function printId(id: number | string) {
  console.log("User ID:", id);
}

printId(123);     // ✅
printId("ABC");   // ✅
</code></pre>
<p>Union sangat berguna ketika kita berhadapan dengan data yang fleksibel tapi masih terkontrol. Namun, ketika menggunakan union, kita harus hati-hati. TypeScript memaksa kita untuk memastikan operasi yang dilakukan valid untuk semua tipe dalam union.</p>
<h3 id="narrowing-mempersempit-union"><a class="header" href="#narrowing-mempersempit-union">Narrowing (Mempersempit Union)</a></h3>
<p>Ketika menggunakan union, kita sering perlu memeriksa tipe data sebelum mengaksesnya. Proses ini disebut type narrowing.</p>
<p>Contoh narrowing sederhana:</p>
<pre><code class="language-ts">function formatId(id: number | string) {
  if (typeof id === "string") {
    return id.toUpperCase(); // ✅ aman karena pasti string
  } else {
    return id.toFixed(2);    // ✅ aman karena pasti number
  }
}

console.log(formatId(123));     // "123.00"
console.log(formatId("abc"));   // "ABC"
</code></pre>
<h2 id="intersection-"><a class="header" href="#intersection-">Intersection (<code>&amp;</code>)</a></h2>
<p>Fitur yang memungkinkan kita untuk menggabungkan beberapa tipe data menjadi satu tipe baru yang memiliki semua properti dan anggota dari setiap tipe yang digabungkan. Fitur ini sangat berguna untuk membuat tipe yang kompleks dari tipe-tipe yang lebih sederhana, di mana objek yang menggunakan tipe interseksi ini harus memenuhi semua persyaratan dari setiap tipe yang termasuk di dalamnya.
Contoh sederhana:</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Employee {
  company: string;
}

interface Worker = Person &amp; Employee;

let staff: Worker = {
  name: "Max",
  company: "Microsoft"
};
</code></pre>
<p><code>Worker</code> adalah seseorang yang sekaligus seorang karyawan, sehingga harus punya properti dari <code>Person</code> dan <code>Employee</code></p>
<p>Selain pada interface, kita juga dapat menggunakan intersection pada tipe data dasar.</p>
<pre><code class="language-ts">type A = { x: number };
type B = { y: string };

type AB = A &amp; B;

let obj: AB = { x: 10, y: "hello" }; // ✅ harus punya keduanya
</code></pre>
<pre><code class="language-ts">type C = { id: number };
type D = { id: string };

type CD = C &amp; D; // ❌ Tidak mungkin, karena 'id' tidak bisa number sekaligus string
</code></pre>
<h2 id="menggabungkan-union--intersection"><a class="header" href="#menggabungkan-union--intersection">Menggabungkan Union &amp; Intersection</a></h2>
<p>Terkadang, kita perlu mengombinasikan union dan intersection untuk membentuk tipe yang lebih kompleks. Teknik ini sering digunakan dalam aplikasi nyata, misalnya ketika mendesain model data yang fleksibel.</p>
<pre><code class="language-ts">interface Admin {
  role: "admin";
  accessLevel: number;
}

interface User {
  role: "user";
  email: string;
}

interface Account = (Admin | User) &amp; { id: number };

let acc1: Account = {
  id: 1,
  role: "admin",
  accessLevel: 5
};

let acc2: Account = {
  id: 2,
  role: "user",
  email: "test@mail.com"
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-5-generics"><a class="header" href="#konsep-typescript-5-generics">Konsep TypeScript 5: Generics</a></h1>
<p>Sebelumnya kita sudah membahas Union &amp; Intersection yang memberi fleksibilitas pada tipe. Terkadang terdapat sebuah kondisi yang membuat kita untuk membuat fungsi atau class yang bisa bekerja dengan banyak tipe tanpa kehilangan informasi tipe aslinya. Walaupun TypeScript memiliki operator <code>any</code>, namun hal ini akan membuat kebingungan karena kehilangan identitas. Di sinilah Generics sangat berguna. Generics memungkinkan kita menulis kode yang dapat digunakan kembali untuk berbagai tipe, tapi tetap memberikan jaminan tipe yang kuat.</p>
<h2 id="generics-pada-function"><a class="header" href="#generics-pada-function">Generics pada Function</a></h2>
<p>Dengan generics, kita bisa membuat fungsi yang menerima parameter dengan tipe yang bisa berubah-ubah.</p>
<p>Tanpa generics:</p>
<pre><code class="language-ts">function identity(arg: any): any {
  return arg;
}

let a = identity(5);      // a: any
let b = identity("Hello"); // b: any
</code></pre>
<p>Masalah: hasilnya selalu any, sehingga kita kehilangan informasi tipe.</p>
<p>Dengan generics:</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  return arg;
}

let num = identity&lt;number&gt;(10);   // num: number
let str = identity("Halo");       // str: string (infer otomatis)
</code></pre>
<p>Dengan generics, kita mendefinisikan tipe sebagai parameter <code>&lt;T&gt;</code>. Hasilnya, TypeScript tahu bahwa input dan output punya tipe yang sama.</p>
<h2 id="penamaan-parameter-generics"><a class="header" href="#penamaan-parameter-generics">Penamaan Parameter Generics</a></h2>
<p>Kalau diperhatikan, kenapa kita sering melihat <T>, <K>, <V> di kode TypeScript?
Sebenarnya itu hanyalah nama variabel tipe, sama seperti kita memberi nama variabel biasa.
Namun, ada konvensi umum agar lebih mudah dibaca.</p>
<div class="table-wrapper"><table><thead><tr><th>Nama</th><th>Makna Umum</th><th>Contoh Penggunaan</th></tr></thead><tbody>
<tr><td><code>T</code></td><td>Type (umum)</td><td><code>identity&lt;T&gt;(arg: T): T</code></td></tr>
<tr><td><code>U</code>,<code>S</code></td><td>Type tambahan / second</td><td><code>pair&lt;T, U&gt;(a: T, b: U)</code></td></tr>
<tr><td><code>K</code></td><td>Key dari sebuah object</td><td><code>getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K)</code></td></tr>
<tr><td><code>V</code></td><td>Value dari sebuah object</td><td><code>Record&lt;K, V&gt; (objek dengan key K dan value V)</code></td></tr>
</tbody></table>
</div>
<p>Kita bisa pakai nama lain (<code>&lt;MyType&gt;</code>, <code>&lt;Foo&gt;</code>), tapi <code>&lt;T&gt;</code>, <code>&lt;K&gt;</code>, <code>&lt;V&gt;</code> sudah jadi kebiasaan.</p>
<p>Contoh:</p>
<pre><code class="language-ts">function pair&lt;K, V&gt;(key: K, value: V): [K, V] {
  return [key, value];
}

let result = pair("id", 101); 
// result: [string, number]
</code></pre>
<p><strong>Generics pada function expression/arrow function:</strong></p>
<pre><code class="language-ts">const getFirstElement = &lt;T&gt;(arr: T[]): T =&gt; {
  return arr[0];
};

let numbers = [1, 2, 3];
let first = getFirstElement(numbers); // first: number

let names = ["Ani", "Budi", "Cici"];
let firstName = getFirstElement(names); // firstName: string
</code></pre>
<p><strong>Generics dengan multi parameter:</strong></p>
<pre><code class="language-ts">function merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {
  return { ...obj1, ...obj2 };
}

let person = merge({ name: "Max" }, { age: 25 });
console.log(person); // { name: "Max", age: 25 }
</code></pre>
<p>**Constraint pada Generics</p>
<p>Kadang kita ingin membatasi tipe generics agar hanya tipe tertentu yang bisa digunakan.
Gunakan <code>extends</code>.</p>
<pre><code class="language-ts">function getLength&lt;T extends { length: number }&gt;(arg: T): number {
  return arg.length;
}

console.log(getLength("Hello"));    // ✅ string punya length
console.log(getLength([1, 2, 3]));  // ✅ array punya length
// console.log(getLength(123));     // ❌ number tidak punya length
</code></pre>
<h2 id="interface-dengan-generics"><a class="header" href="#interface-dengan-generics">Interface dengan Generics</a></h2>
<p>Generics juga bisa digunakan dalam interface.</p>
<pre><code class="language-ts">interface Repository&lt;T&gt; {
  data: T[];
  add(item: T): void;
  getAll(): T[];
}

class MemoryRepository&lt;T&gt; implements Repository&lt;T&gt; {
  data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

let userRepo = new MemoryRepository&lt;string&gt;();
userRepo.add("Jordan");
userRepo.add("Ani");
console.log(userRepo.getAll()); // ["Jordan", "Ani"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class--oop-dasar"><a class="header" href="#class--oop-dasar">Class &amp; OOP Dasar</a></h1>
<p>JavaScript sudah mengenalkan konsep class sejak ES6. Di TypeScript, class mendapatkan kekuatan tambahan berupa static typing, access modifier, dan interface/class inheritance. Dengan class, kita bisa membuat blueprint untuk objek, sehingga kode lebih terstruktur dan mudah dikelola.</p>
<h3 id="membuat-class-dasar"><a class="header" href="#membuat-class-dasar">Membuat Class Dasar</a></h3>
<p>Class adalah cetak biru (blueprint) untuk membuat objek.</p>
<pre><code class="language-ts">class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Halo, nama saya ${this.name} dan saya berusia ${this.age} tahun.`);
  }
}

let user = new Person("Ryo", 35);
user.greet();
// Output: Halo, nama saya Ryo dan saya berusia 35 tahun.
</code></pre>
<p>Contoh di atas, kita membuat class Person dengan properti name dan age. Constructor digunakan untuk menginisialisasi properti, dan method greet menampilkan data. Dengan ini, kita bisa membuat banyak objek Person tanpa menulis ulang struktur yang sama.</p>
<h3 id="access-modifier"><a class="header" href="#access-modifier">Access Modifier</a></h3>
<p>TypeScript menambahkan access modifier untuk mengatur visibilitas properti dan method.</p>
<pre><code class="language-ts">class Car {
  public brand: string;       // Bisa diakses dari mana saja
  private engineNumber: string; // Hanya bisa diakses dari dalam class
  protected year: number;     // Bisa diakses oleh class ini &amp; turunannya

  constructor(brand: string, engineNumber: string, year: number) {
    this.brand = brand;
    this.engineNumber = engineNumber;
    this.year = year;
  }

  getInfo() {
    return `${this.brand} (${this.year})`;
  }
}

let car = new Car("Toyota", "EN12345", 2020);
console.log(car.brand);          // ✅ Toyota
// console.log(car.engineNumber); // ❌ Error: private
</code></pre>
<ul>
<li><code>public</code>: default, bisa diakses dari mana saja.</li>
<li><code>private</code>: hanya bisa diakses di dalam class itu sendiri.</li>
<li><code>protected</code>: bisa diakses dari class dan subclass (turunan).</li>
</ul>
<h3 id="getter--setter"><a class="header" href="#getter--setter">Getter &amp; Setter</a></h3>
<p>Kita bisa membuat method khusus untuk mengambil dan mengubah nilai dengan kontrol lebih.</p>
<pre><code class="language-ts">class Account {
  private _balance: number = 0;

  get balance(): number {
    return this._balance;
  }

  set balance(amount: number) {
    if (amount &lt; 0) throw new Error("Balance tidak boleh negatif");
    this._balance = amount;
  }
}

let acc = new Account();
acc.balance = 1000;        // Setter
console.log(acc.balance);  // Getter -&gt; 1000
</code></pre>
<p>Getter &amp; Setter memberi kontrol penuh atas cara data diakses dan dimodifikasi.
Misalnya, kita bisa menolak nilai negatif untuk <code>balance</code>.</p>
<h3 id="inheritance-pewarisan"><a class="header" href="#inheritance-pewarisan">Inheritance (Pewarisan)</a></h3>
<p>Class bisa mewarisi dari class lain dengan <code>extends</code>.</p>
<pre><code class="language-ts">class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move() {
    console.log(`${this.name} bergerak.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} menggonggong.`);
  }
}

let dog = new Dog("Buddy");
dog.move();  // Buddy bergerak.
dog.bark();  // Buddy menggonggong.
</code></pre>
<p>Dengan inheritance, kita bisa membuat class baru yang mewarisi properti dan method dari class lain.
Ini memungkinkan reuse kode dan membuat struktur hierarki yang lebih natural.</p>
<h3 id="method-overriding"><a class="header" href="#method-overriding">Method Overriding</a></h3>
<p>Subclass bisa menimpa (override) method dari superclass.</p>
<pre><code class="language-ts">class Bird extends Animal {
  move() {
    console.log(`${this.name} terbang.`);
  }
}

let bird = new Bird("Garuda");
bird.move(); // Garuda terbang.
</code></pre>
<h3 id="abstract-class"><a class="header" href="#abstract-class">Abstract Class</a></h3>
<p>Abstract class tidak bisa dibuat instance langsung. Biasanya digunakan sebagai blueprint untuk class lain. Abstract class seperti kontrak: class turunan wajib mengimplementasikan method yang abstrak.</p>
<pre><code class="language-ts">abstract class Shape {
  abstract area(): number;
}

class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super();
  }

  area(): number {
    return this.width * this.height;
  }
}

let rect = new Rectangle(10, 5);
console.log(rect.area()); // 50
</code></pre>
<h3 id="static-member"><a class="header" href="#static-member">Static Member</a></h3>
<p>Kita bisa membuat properti dan method yang dimiliki oleh class itu sendiri, bukan oleh objeknya.</p>
<pre><code class="language-ts">class MathUtil {
  static PI: number = 3.14159;

  static circleArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtil.PI);               // 3.14159
console.log(MathUtil.circleArea(10));   // 314.159
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module--importexport"><a class="header" href="#module--importexport">Module &amp; Import/Export</a></h1>
<p>Di JavaScript (sejak ES6) dan TypeScript, modul digunakan untuk membagi kode ke dalam file-file terpisah sehingga kode lebih mudah dibaca &amp; dikelola dan bisa dipakai ulang di file lain.</p>
<h3 id="export"><a class="header" href="#export">Export</a></h3>
<p>Sebuah file TypeScript dianggap sebagai modul ketika memiliki <code>export</code> atau <code>import</code>.</p>
<p>Contoh:</p>
<p><code>mathUtils.ts</code></p>
<pre><code class="language-ts">// export variabel
export const PI = 3.14159;

// export fungsi
export function add(a: number, b: number): number {
  return a + b;
}

// export class
export class Calculator {
  multiply(x: number, y: number): number {
    return x * y;
  }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Kita bisa mengimpor apa yang diekspor dari file lain.</p>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { PI, add, Calculator } from "./mathUtils";

console.log(PI); // 3.14159
console.log(add(10, 5)); // 15

const calc = new Calculator();
console.log(calc.multiply(4, 3)); // 12
</code></pre>
<p>Dengan kurung kurawal <code>{}</code> kita bisa mengambil item-item spesifik dari modul. TypeScript memastikan hanya yang diekspor yang bisa diimpor.</p>
<h3 id="export-default"><a class="header" href="#export-default">Export Default</a></h3>
<p>Kadang sebuah modul hanya punya satu hal utama. Untuk kasus ini kita bisa pakai default export.
Contoh:</p>
<p>logger.ts</p>
<pre><code class="language-ts">export default function log(message: string): void {
  console.log("[LOG]:", message);
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import log from "./logger";

log("Halo dari default export!");
</code></pre>
<h3 id="alias-import--export"><a class="header" href="#alias-import--export">Alias Import &amp; Export</a></h3>
<p>Kita bisa mengganti nama saat export atau import menggunakan <code>as</code>. Alias sering dipakai untuk menghindari konflik nama atau membuat kode lebih singkat.</p>
<p><code>shapes.ts</code></p>
<pre><code class="language-ts">export function areaRectangle(w: number, h: number): number {
  return w * h;
}

export function areaCircle(r: number): number {
  return Math.PI * r * r;
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { areaRectangle as rect, areaCircle as circle } from "./shapes";

console.log(rect(10, 5)); // 50
console.log(circle(7));   // 153.938...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment"><a class="header" href="#setup-environment">Setup Environment</a></h1>
<p>Sebelum mulai membuat aplikasi React Native, kita perlu menyiapkan <strong>environment</strong> terlebih dahulu.<br />
Ada dua cara utama untuk menjalankan React Native:</p>
<ol>
<li><a href="./react-native-cli.html"><strong>React Native CLI</strong></a> → lebih fleksibel, cocok untuk aplikasi production dengan native module.</li>
<li><a href="./expo-go.html"><strong>Expo Go</strong></a> → lebih mudah, cocok untuk belajar dan prototyping.</li>
</ol>
<h2 id="1-prasyarat"><a class="header" href="#1-prasyarat">1. Prasyarat</a></h2>
<h3 id="nodejs--package-manager"><a class="header" href="#nodejs--package-manager">Node.js &amp; Package Manager</a></h3>
<p>React Native membutuhkan <strong>Node.js</strong>. Disarankan menggunakan versi <strong>LTS</strong>.<br />
Unduh di <a href="https://nodejs.org/">nodejs.org</a>.</p>
<p>Cek instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<p>Opsional: gunakan Yarn atau pnpm sebagai pengganti npm.</p>
<pre><code class="language-bash">npm install -g yarn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli"><a class="header" href="#react-native-cli">React Native CLI</a></h1>
<p>Untuk menggunakan <strong>React Native CLI</strong>, kita perlu menyiapkan lingkungan pengembangan (development environment).</p>
<p>Karena React Native berjalan di Android dan iOS, maka langkah setup dibedakan berdasarkan sistem operasi target:</p>
<ul>
<li><a href="./react-native-cli-android.html">Setup Android</a></li>
<li><a href="./react-native-cli-ios.html">Setup iOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--android"><a class="header" href="#setup-environment-react-native-cli--android">Setup Environment React Native CLI – Android</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<ol>
<li>Install Node.js dan Java
<ul>
<li>Unduh <strong>Node.js</strong> (versi LTS) dari <a href="https://nodejs.org/">nodejs.org</a>.</li>
<li>Install <strong>Java JDK</strong> (disarankan versi 11 atau lebih baru).</li>
</ul>
</li>
</ol>
<p>Cek instalasi java:</p>
<pre><code class="language-bash">node -v
java -version
</code></pre>
<ol start="2">
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Konfigurasi ANDROID_HOME environment variable</p>
<ul>
<li>Buka <strong>Window Control Panel</strong></li>
<li>Klik <strong>User Accounts</strong>, lalu pilih <strong>Change my environment variables</strong></li>
<li>Klik <strong>New...</strong> untuk membuat user variable baru. Masukkan Variable name <strong>ANDROID_HOME</strong> dan Variable value <strong>Lokasi SDK Android</strong></li>
</ul>
<p><img src="./assets/env%20variable%20windows.png" alt="Ilustrasi menambahkan environment variable" title="Ilustrasi menambahkan environment variable" /></p>
<p>Untuk menemukan lokasi SDK dapat dilakukan melalui <strong>Android Studio</strong>. Pilih <strong>Settings</strong> → <strong>Languages &amp; Frameworks</strong> → <strong>Android SDK</strong></p>
</li>
<li>
<p>Menjalankan Emulator Android</p>
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>
<p>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>
<p>Install JDK menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install --cask zulu@17
brew info --cask zulu@17
open /opt/homebrew/Caskroom/zulu@17/&lt;version number&gt;
</code></pre>
<p>Setelah Finder terbuka, Klik double untuk menginstal Azul Zulu JDK 17.pkg.</p>
<p>Tambahkan atau update JAVA_HOME environment variable di ~/.zshrc (or in ~/.bash_profile).</p>
<p>JDK umunya berada di /Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home. Lalu jalankan command berikut pada terminal</p>
<pre><code class="language-bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
</code></pre>
</li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
</li>
</ol>
<ul>
<li>
<p>Unduh <a href="developer.android.com/studio">Android Studio</a></p>
</li>
<li>
<p>Saat instalasi, pastikan mencentang:</p>
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>
<p>Setelah instalasi, buka Android Studio → SDK Manager → install:</p>
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install <a href="https://nodejs.org/en/download"><strong>Node</strong></a></li>
<li>Install <a href="https://openjdk.org/"><strong>JDK</strong></a></li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Android/Sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--ios"><a class="header" href="#setup-environment-react-native-cli--ios">Setup Environment React Native CLI – iOS</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>Install <a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12"><strong>Xcode</strong></a></li>
<li>Install Xcode Command Line Tools
Buka Xcode lalu pilih <strong>Settings... (atau Preferences...)</strong> pada menu Xcode.
Pilih panel <strong>Locations</strong> lalu pilih versi Command line tools terbaru
<img src="./assets/install%20command%20line%20tools.png" alt="Ilustrasi install command line tool Xcode" title="Ilustrasi install command line tool Xcode" /></li>
</ul>
</li>
<li>
<p>Install iOS simulator</p>
<ul>
<li>Buka Xcode → Settings... → tab Platforms.</li>
<li>Pilih "+" dan pilih opsi iOS…</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native--expo"><a class="header" href="#setup-environment-react-native--expo">Setup Environment React Native – Expo</a></h1>
<p>Expo adalah framework dan platform untuk React Native yang memudahkan pengembangan aplikasi mobile tanpa perlu konfigurasi native (Android Studio / Xcode).<br />
Dengan Expo, kita bisa langsung membuat aplikasi, menjalankan di perangkat fisik dengan <strong>Expo Go</strong>, atau di emulator.</p>
<hr />
<h2 id="1-install-nodejs"><a class="header" href="#1-install-nodejs">1. Install Node.js</a></h2>
<p>Unduh <strong>Node.js LTS</strong> dari <a href="https://nodejs.org/">nodejs.org</a>.<br />
Verifikasi instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<h2 id="2-install-expo-go"><a class="header" href="#2-install-expo-go">2. Install Expo Go</a></h2>
<p>Unduh aplikasi Expo Go di <a href="https://apps.apple.com/us/app/expo-go/id982107779">App Store</a> atau <a href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www">Google Play</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli-1"><a class="header" href="#react-native-cli-1">React Native CLI</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan React Native CLI.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx @react-native-community/cli@latest init MyFirstApp
</code></pre>
<p>Jika sebelumnya sudah pernah menginstal react-native-cli secara global, jalankan command terminal berikut unutk mencegah kesalahan</p>
<pre><code class="language-bash">npm uninstall -g react-native-cli @react-native-community/cli
</code></pre>
</li>
<li>
<p>Start Metro
<a href="https://metrobundler.dev/">Metro</a> merupakan tool build berbasis JavaScript. Jalankan terminal command berikut untuk menjalankan Metro</p>
<pre><code class="language-bash">npm start
</code></pre>
</li>
<li>
<p>Jalankan Aplikasi
Buka terminal baru lalu jalankan terminal command berikut untuk menjalankan aplikasi React Native</p>
<pre><code class="language-bash">npm run android
</code></pre>
<p>atau</p>
<pre><code class="language-bash">npm run ios // hanya pada macOS
</code></pre>
<p>Aplikasi akan berjalan di emulator</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expo"><a class="header" href="#expo">Expo</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan Framework Expo.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx create-expo-app --template blank-typescript
</code></pre>
<p><code>blank-typescript</code> merupakan salah satu opsi <a href="https://docs.expo.dev/more/create-expo/#--template">template</a> yang tersedia. Opsi ini akan memberikan template kosong (tanpa navigasi dengan basisnya adalah typescript)</p>
</li>
<li>
<p>Menjalankan Aplikasi
Jalankan terminal command berikut pada directory project.</p>
<pre><code class="language-bash">npx expo start
</code></pre>
<p>Buka aplikasi Expo Go melalui perangkat mobile lalu scan qrcode yang muncul pada terminal.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struktur-proyek-react-native"><a class="header" href="#struktur-proyek-react-native">Struktur Proyek React Native</a></h1>
<p>Setelah membuat project baru, struktur folder akan sedikit berbeda tergantung apakah kita menggunakan React Native CLI atau Expo. Dengan memahami struktur proyek, kita bisa tahu mana bagian yang sering kita edit dan mana yang biasanya tidak perlu disentuh.</p>
<ol>
<li>
<p>Struktur Proyek (React Native CLI)</p>
<p>Contoh hasil dari <code>npx @react-native-community/cli@latest init MyFirstApp</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── android/            # kode native untuk Android (Java/Kotlin)
├── ios/                # kode native untuk iOS (Objective-C/Swift)
├── node_modules/       # dependency project (otomatis dibuat oleh npm/yarn)
├── App.js              # file utama aplikasi (entry point React)
├── index.js            # entry point aplikasi ke native (registrasi root component)
├── package.json        # daftar dependency &amp; script project
└── metro.config.js     # konfigurasi Metro bundler
</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (tempat kita menulis kode React Native).</li>
<li><code>index.js</code>: menghubungkan komponen React Native (<code>App</code>) ke aplikasi native (Android/iOS).</li>
<li><code>android/</code>: kode native untuk Android (bisa edit langsung kalau perlu modul custom).</li>
<li><code>ios/</code>: kode native untuk iOS.</li>
<li><code>package.json</code>: daftar library &amp; script seperti <code>npm start</code>, <code>npm run android</code>.</li>
<li><code>metro.config.js</code>: konfigurasi Metro bundler.</li>
</ul>
</li>
<li>
<p>Struktur Proyek (Expo)</p>
<p>Contoh hasil dari <code>npx create-expo-app@latest</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── node_modules/       # dependency project
├── App.js              # file utama aplikasi
├── package.json        # daftar dependency &amp; script project
└── app.json            # konfigurasi Expo (nama app, icon, splash screen, dsb.)

</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (entry point React).</li>
<li><code>app.json</code>: konfigurasi Expo (nama app, ikon, orientasi layar, dll).</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komponen-react-native"><a class="header" href="#komponen-react-native">Komponen React Native</a></h1>
<p>Ketika kita membuat sebuah aplikasi, sebenarnya kita sedang menyusun potongan-potongan kecil yang bersama-sama membentuk satu kesatuan tampilan. Potongan kecil ini dalam React Native disebut komponen. Bisa dibilang, komponen adalah "building blocks" dari aplikasi mobile.</p>
<p>Hal menarik lainnya, React Native tidak hanya menyediakan komponen bawaan, tapi kita juga dapat membuat komponen buatan sendiri (custom component). Ini membuat kode kita lebih terstruktur, lebih mudah digunakan ulang, dan tentu saja lebih rapi.</p>
<p>Dalam <strong>React Native</strong>, <code>App.tsx</code> merupakan file utama yang pertama kali dijalankan ketika aplikasi dibuka. Kalau di web, mirip seperti <code>index.html</code> + <code>index.js</code>.</p>
<h3 id="struktur-dasar-apptsx-react-native-cli"><a class="header" href="#struktur-dasar-apptsx-react-native-cli">Struktur dasar <code>App.tsx</code> (React Native CLI)</a></h3>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={styles.container}&gt;
      &lt;NewAppScreen
        templateFileName="App.tsx"
        safeAreaInsets={safeAreaInsets}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default App;
</code></pre>
<p>Template default React Native CLI memang terlihat cukup kompleks bagi yang pertama kali belajar. Silahkan ubah kode di atas menjadi:</p>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={[styles.container,{ paddingTop: safeAreaInsets.top, paddingBottom: safeAreaInsets.bottom }]}&gt;
      &lt;View style={styles.center}&gt;
        &lt;Text style={styles.title}&gt;Hello React Native 🚀&lt;/Text&gt;
        &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya dengan CLI&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
  },
  center: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#666',
    marginTop: 8,
  },
});

export default App;
</code></pre>
<h3 id="struktur-dasar-apptsx-expo"><a class="header" href="#struktur-dasar-apptsx-expo">Struktur dasar <code>App.tsx</code> (Expo)</a></h3>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Open up App.tsx to start working on your app!&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
</code></pre>
<p>Coba ubah bagian <code>&lt;Text&gt;</code> menjadi berikut:</p>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Hello React Native dengan Expo 🚀&lt;/Text&gt;
      &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#555',
    marginTop: 8,
  },
});
</code></pre>
<p>Amati perbedaan sebelum dan sesudah dimodifikasi.</p>
<p>React Native menyediakan sekumpulan komponen bawaan (built-in components) yang digunakan untuk membangun UI aplikasi. Komponen ini mirip dengan elemen HTML di web, tetapi disesuaikan dengan dunia mobile.</p>
<p>Selain komponen bawaan dari React Native, kita juga dapat menggunakan third-party yang sudah terkenal seperti <a href="https://reactnativepaper.com/">React Native Paper</a>, <a href="https://gluestack.io/">GlueStack</a>, <a href="https://reactnativeelements.com/">React Native Elements</a>, <a href="https://akveo.github.io/react-native-ui-kitten/">UI Kitten</a>, dan <a href="https://tamagui.dev/">Tamagui</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>Komponen ini umumnya digunakan sebagai container untuk menampung komponen lain (mirip dengan <code>&lt;div&gt;</code> di HTML). View memiliki sifat fleksibel dan bisa digunakan untuk berbagai kebutuhan seperti layout, styling, hingga wrapper komponen.</p>
<h3 id="view-sebagai-container-pusat"><a class="header" href="#view-sebagai-container-pusat">View sebagai container pusat</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';


&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;Text&gt;Ini berada di dalam View&lt;/Text&gt;
&lt;/View&gt;

</code></pre>
<h3 id="view-dengan-background"><a class="header" href="#view-dengan-background">View dengan Background</a></h3>
<pre><code class="language-ts">import { View } from 'react-native';

&lt;View style={{ flex: 1, backgroundColor: '#87cefa' }} /&gt;
</code></pre>
<h3 id="view-untuk-layout-vertikal"><a class="header" href="#view-untuk-layout-vertikal">View untuk Layout Vertikal</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, padding: 20 }}&gt;
  &lt;Text style={{ marginBottom: 10 }}&gt;Atas&lt;/Text&gt;
  &lt;Text&gt;Tengah&lt;/Text&gt;
  &lt;Text&gt;Bawah&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-untuk-layout-horizontal-row"><a class="header" href="#view-untuk-layout-horizontal-row">View untuk Layout Horizontal (Row)</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View
  style={{
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 50,
  }}
&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-dengan-nested-view"><a class="header" href="#view-dengan-nested-view">View dengan Nested View</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, padding: 20 }}&gt;
  &lt;Text style={{ marginBottom: 10 }}&gt;Header&lt;/Text&gt;

  &lt;View style={{ flex: 1, backgroundColor: '#f0f0f0', padding: 10 }}&gt;
    &lt;Text&gt;Konten utama di dalam nested View&lt;/Text&gt;
  &lt;/View&gt;

  &lt;Text style={{ marginTop: 10 }}&gt;Footer&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="view-sebagai-card"><a class="header" href="#view-sebagai-card">View Sebagai Card</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;View
    style={{
      width: 200,
      padding: 20,
      borderRadius: 10,
      backgroundColor: '#fff',
      elevation: 3, // Android shadow
      shadowColor: '#000', // iOS shadow
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    }}
  &gt;
    &lt;Text style={{ fontSize: 18, fontWeight: 'bold' }}&gt;Card Title&lt;/Text&gt;
    &lt;Text&gt;Ini isi card dengan styling View&lt;/Text&gt;
  &lt;/View&gt;
&lt;/View&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p><code>Text</code> digunakan untuk menampilkan tulisan di layar. Hampir semua teks di aplikasi React Native harus dibungkus dengan komponen ini.</p>
<h3 id="text-sederhana"><a class="header" href="#text-sederhana">Text Sederhana</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;Text&gt;Hello React Native!&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h3 id="text-dengan-styling"><a class="header" href="#text-dengan-styling">Text dengan Styling</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text style={{ fontSize: 24, fontWeight: 'bold', color: 'blue' }}&gt;
  Teks dengan styling
&lt;/Text&gt;
</code></pre>
<h3 id="multiline-text"><a class="header" href="#multiline-text">Multiline Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text&gt;
  Baris pertama{"\n"}
  Baris kedua{"\n"}
  Baris ketiga
&lt;/Text&gt;
</code></pre>
<h3 id="nested-text"><a class="header" href="#nested-text">Nested Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

&lt;Text&gt;
  Ini &lt;Text style={{ fontWeight: 'bold' }}&gt;teks tebal&lt;/Text&gt; di dalam kalimat.
&lt;/Text&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>Komponen <strong><code>Image</code></strong> digunakan untuk menampilkan gambar di aplikasi React Native.<br />
Gambar dapat berasal dari <strong>lokal</strong> (disimpan di dalam project) maupun dari <strong>URL</strong>.</p>
<hr />
<h2 id="1-menampilkan-image-dari-lokal"><a class="header" href="#1-menampilkan-image-dari-lokal">1. Menampilkan Image dari Lokal</a></h2>
<p>Simpan file gambar, misalnya <code>logo.png</code>, di dalam folder <code>assets/</code>.</p>
<pre><code class="language-ts">import { Image, View } from 'react-native';

&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Image
    source={require('./assets/logo.png')}
    style={{ width: 100, height: 100 }}
    /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="menampilkan-image-dari-url"><a class="header" href="#menampilkan-image-dari-url">Menampilkan Image dari URL</a></h3>
<pre><code class="language-ts">import { Image, View } from 'react-native';

&lt;Image
    source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
    style={{ width: 100, height: 100 }}
/&gt;
</code></pre>
<h3 id="mengatur-ukuran-dan-styling"><a class="header" href="#mengatur-ukuran-dan-styling">Mengatur Ukuran dan Styling</a></h3>
<pre><code class="language-ts">&lt;Image
  source={require('./assets/logo.png')}
  style={{
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 2,
    borderColor: 'blue',
  }}
/&gt;
</code></pre>
<h3 id="resizemode"><a class="header" href="#resizemode">ResizeMode</a></h3>
<p><code>Image</code> memiliki properti resizeMode untuk mengatur cara gambar ditampilkan:</p>
<ul>
<li><code>cover</code> (default) → gambar memenuhi container dengan cropping jika perlu.</li>
<li><code>contain</code> → gambar menyesuaikan agar seluruh gambar terlihat.</li>
<li><code>stretch</code> → gambar diregangkan agar sesuai dengan ukuran container.</li>
<li><code>repeat</code> → gambar diulang-ulang.</li>
<li><code>center</code> → gambar ditampilkan sesuai ukuran asli di tengah.</li>
</ul>
<pre><code class="language-ts">&lt;Image
  source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
  style={{ width: 200, height: 100 }}
  resizeMode="contain"
/&gt;
</code></pre>
<h3 id="background-image-dengan-imagebackground"><a class="header" href="#background-image-dengan-imagebackground">Background Image dengan <code>ImageBackground</code></a></h3>
<pre><code class="language-ts">import { ImageBackground, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ImageBackground
      source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
      style={styles.background}
    &gt;
      &lt;Text style={styles.text}&gt;Teks di atas gambar&lt;/Text&gt;
    &lt;/ImageBackground&gt;
  );
}

const styles = StyleSheet.create({
  background: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textinput"><a class="header" href="#textinput">TextInput</a></h1>
<p>Komponen <strong><code>TextInput</code></strong> digunakan untuk menerima input teks dari pengguna, mirip dengan <code>&lt;input type="text"&gt;</code> di HTML.<br />
<code>TextInput</code> adalah bagian penting dalam membangun form, pencarian, login, dan interaksi berbasis teks lainnya.</p>
<hr />
<h3 id="textinput-dasar"><a class="header" href="#textinput-dasar">TextInput Dasar</a></h3>
<pre><code class="language-ts">import { TextInput, View, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik sesuatu..."
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    width: 200,
    borderRadius: 5,
  },
});
</code></pre>
<h3 id="mengatur-keyboard"><a class="header" href="#mengatur-keyboard">Mengatur Keyboard</a></h3>
<p><code>TextInput</code> bisa menyesuaikan jenis keyboard dengan properti <code>keyboardType</code>.</p>
<p>Beberapa nilai yang sering digunakan:</p>
<ul>
<li><code>default</code> → keyboard standar.</li>
<li><code>numeric</code> → angka.</li>
<li><code>email-address</code> → untuk email.</li>
<li><code>phone-pad</code> → untuk nomor telepon.</li>
</ul>
<pre><code class="language-ts">&lt;TextInput
  style={styles.input}
  placeholder="Masukkan email"
  keyboardType="email-address"
/&gt;
</code></pre>
<h3 id="textinput-dengan-password-secure-text-entry"><a class="header" href="#textinput-dengan-password-secure-text-entry">TextInput dengan Password (Secure Text Entry)</a></h3>
<pre><code class="language-ts">&lt;TextInput
  style={styles.input}
  placeholder="Masukkan password"
  secureTextEntry={true}
/&gt;
</code></pre>
<h3 id="multiline-input"><a class="header" href="#multiline-input">Multiline Input</a></h3>
<pre><code class="language-ts">&lt;TextInput
  style={[styles.input, { height: 100 }]}
  placeholder="Tulis komentar..."
  multiline
  numberOfLines={4}
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<p>Komponen <strong><code>Button</code></strong> digunakan untuk menangani aksi sederhana dari pengguna, misalnya mengirim form atau menavigasi ke halaman lain.<br />
<code>Button</code> bawaan React Native cukup mudah digunakan, tapi terbatas dalam hal kustomisasi tampilan.</p>
<hr />
<h3 id="button-dasar"><a class="header" href="#button-dasar">Button Dasar</a></h3>
<pre><code class="language-ts">import { Button, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Button
        title="Klik Saya"
        onPress={() =&gt; alert('Tombol ditekan!')}
      /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<ul>
<li><code>title</code> → teks yang ditampilkan pada tombol.</li>
<li><code>onPress</code> → fungsi yang dijalankan ketika tombol ditekan.</li>
</ul>
<h3 id="mengubah-warna-button"><a class="header" href="#mengubah-warna-button">Mengubah Warna Button</a></h3>
<pre><code class="language-ts">&lt;Button
  title="Tombol Hijau"
  onPress={() =&gt; console.log('Hijau')}
  color="green"
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="touchable"><a class="header" href="#touchable">Touchable</a></h1>
<p>Komponen <code>Touchable</code> di React Native digunakan untuk membuat area yang bisa ditekan (pressable area).
Berbeda dengan <a href="component-button.html"><code>Button</code></a> bawaan yang terbatas dalam kustomisasi, <code>Touchable</code> memberikan fleksibilitas penuh untuk membuat tombol dengan gaya dan isi sesuai kebutuhan (misalnya teks, ikon, atau gambar).</p>
<p>React Native menyediakan beberapa varian Touchable seperti:</p>
<ul>
<li><code>TouchableOpacity</code></li>
<li><code>TouchableHighlight</code></li>
<li><code>TouchableWithoutFeedback</code></li>
</ul>
<h2 id="touchableopacity"><a class="header" href="#touchableopacity">TouchableOpacity</a></h2>
<pre><code class="language-javascript">import { Text, View, TouchableOpacity, Alert } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;TouchableOpacity
        onPress={() =&gt; Alert.alert('Tombol ditekan!')}
        style={{
          backgroundColor: '#4CAF50',
          paddingVertical: 12,
          paddingHorizontal: 20,
          borderRadius: 8,
        }}
      &gt;
        &lt;Text style={{ color: 'white', fontSize: 16 }}&gt;Klik Saya&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<ul>
<li><code>onPress</code>: fungsi yang dijalankan ketika tombol ditekan.</li>
<li><code>style</code> → bisa bebas dikustomisasi, tidak seperti Button.</li>
<li><code>Text</code> atau komponen lain bisa dimasukkan sebagai isi tombol.</li>
</ul>
<h2 id="touchablehighlight"><a class="header" href="#touchablehighlight">TouchableHighlight</a></h2>
<p>Memberikan efek highlight saat tombol ditekan.</p>
<pre><code class="language-javascript">import { Text, View, TouchableHighlight } from 'react-native';
export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;TouchableHighlight onPress={() =&gt; console.log('Highlight!')}
        underlayColor="#DDDDDD"
        style={{
            backgroundColor: '#2196F3',
            padding: 12,
            borderRadius: 8,
        }}
      &gt;
        &lt;Text style={{ color: 'white', textAlign: 'center' }}&gt;Tombol Highlight&lt;/Text&gt;
      &lt;/TouchableHighlight&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h2 id="touchablewithoutfeedback"><a class="header" href="#touchablewithoutfeedback">TouchableWithoutFeedback</a></h2>
<p>Tidak memberikan efek visual, cocok jika ingin mendapatkan kontrol penuh terhadap tampilan.</p>
<pre><code class="language-javascript">import { Text, View, TouchableWithoutFeedback } from 'react-native';
export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
        &lt;TouchableWithoutFeedback onPress={() =&gt; console.log('Tanpa efek')}&gt;
            &lt;View style={{ backgroundColor: '#FF5722', padding: 12, borderRadius: 8 }}&gt;
                &lt;Text style={{ color: 'white' }}&gt;Tanpa Efek&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt; 
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrollview"><a class="header" href="#scrollview">ScrollView</a></h1>
<p>Komponen <strong><code>ScrollView</code></strong> digunakan untuk membuat area yang dapat digulir (scroll), baik secara <strong>vertikal</strong> maupun <strong>horizontal</strong>.<br />
Berbeda dengan <code>FlatList</code> (yang lebih efisien untuk data besar), <code>ScrollView</code> cocok digunakan ketika jumlah elemen <strong>relatif sedikit</strong>.</p>
<hr />
<h3 id="scrollview-vertikal-dasar"><a class="header" href="#scrollview-vertikal-dasar">ScrollView Vertikal Dasar</a></h3>
<pre><code class="language-ts">import { ScrollView, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ScrollView style={styles.container}&gt;
      {Array.from({ length: 20 }, (_, i) =&gt; (
        &lt;Text key={i} style={styles.item}&gt;
          Item {i + 1}
        &lt;/Text&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginTop: 40,
    padding: 10,
  },
  item: {
    fontSize: 18,
    marginVertical: 10,
  },
});
</code></pre>
<h3 id="scrollview-horizontal"><a class="header" href="#scrollview-horizontal">ScrollView Horizontal</a></h3>
<pre><code class="language-ts">&lt;ScrollView horizontal style={{ marginTop: 40 }}&gt;
  {Array.from({ length: 10 }, (_, i) =&gt; (
    &lt;Text key={i} style={{ fontSize: 18, marginHorizontal: 20 }}&gt;
      Item {i + 1}
    &lt;/Text&gt;
  ))}
&lt;/ScrollView&gt;
</code></pre>
<h3 id="menambahkan-konten-yang-kompleks"><a class="header" href="#menambahkan-konten-yang-kompleks">Menambahkan Konten yang Kompleks</a></h3>
<pre><code class="language-ts">import { ScrollView, View, Text, Image, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;ScrollView contentContainerStyle={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Galeri Gambar&lt;/Text&gt;
      {Array.from({ length: 5 }, (_, i) =&gt; (
        &lt;Image
          key={i}
          source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
          style={styles.image}
        /&gt;
      ))}
    &lt;/ScrollView&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  image: {
    width: 100,
    height: 100,
    marginVertical: 10,
  },
});
</code></pre>
<h3 id="properti-penting-scrollview"><a class="header" href="#properti-penting-scrollview">Properti Penting ScrollView</a></h3>
<ul>
<li><code>horizontal</code> → menggulir secara horizontal.</li>
<li><code>contentContainerStyle</code> → styling untuk isi konten.</li>
<li><code>showsVerticalScrollIndicator</code> &amp; <code>showsHorizontalScrollIndicator</code> → menampilkan/menyembunyikan scrollbar.</li>
<li><code>refreshControl</code> → menambahkan fitur pull-to-refresh.</li>
</ul>
<pre><code class="language-ts">&lt;ScrollView showsVerticalScrollIndicator={false}&gt;
  {/* konten */}
&lt;/ScrollView&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatlist"><a class="header" href="#flatlist">FlatList</a></h1>
<p>Komponen <strong><code>FlatList</code></strong> digunakan untuk menampilkan daftar data dalam jumlah banyak secara <strong>efisien</strong>.<br />
Berbeda dengan <code>ScrollView</code> (yang merender semua item sekaligus), <code>FlatList</code> hanya merender item yang terlihat di layar, sehingga lebih hemat memori dan performa.</p>
<hr />
<h3 id="flatlist-dasar"><a class="header" href="#flatlist-dasar">FlatList Dasar</a></h3>
<pre><code class="language-ts">import { FlatList, Text, StyleSheet, View } from 'react-native';

const DATA = Array.from({ length: 20 }, (_, i) =&gt; ({
  id: i.toString(),
  title: `Item ${i + 1}`,
}));

export default function App() {
  return (
    &lt;FlatList
      data={DATA}
      keyExtractor={(item) =&gt; item.id}
      renderItem={({ item }) =&gt; (
        &lt;View style={styles.item}&gt;
          &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
        &lt;/View&gt;
      )}
    /&gt;
  );
}

const styles = StyleSheet.create({
  item: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  text: {
    fontSize: 18,
  },
});
</code></pre>
<h3 id="flatlist-horizontal"><a class="header" href="#flatlist-horizontal">FlatList Horizontal</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  horizontal
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={{ margin: 10, padding: 20, backgroundColor: '#eee' }}&gt;
      &lt;Text&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
/&gt;
</code></pre>
<h3 id="menambahkan-header--footer"><a class="header" href="#menambahkan-header--footer">Menambahkan Header &amp; Footer</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
  ListHeaderComponent={&lt;Text style={styles.header}&gt;Daftar Item&lt;/Text&gt;}
  ListFooterComponent={&lt;Text style={styles.footer}&gt;Akhir List&lt;/Text&gt;}
/&gt;
</code></pre>
<h3 id="menambahkan-separator"><a class="header" href="#menambahkan-separator">Menambahkan Separator</a></h3>
<pre><code class="language-ts">&lt;FlatList
  data={DATA}
  keyExtractor={(item) =&gt; item.id}
  renderItem={({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Text style={styles.text}&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  )}
  ItemSeparatorComponent={() =&gt; &lt;View style={{ height: 1, backgroundColor: '#ccc' }} /&gt;}
/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress"><a class="header" href="#progress">Progress</a></h1>
<p>Komponen Progress Bar digunakan untuk menampilkan kemajuan proses (misalnya loading data, upload file, atau download). React Native tidak menyediakan progress bar bawaan di semua platform, tapi kita dapat menggunakan <code>ProgressBar</code> dari <code>react-native-progress</code>.</p>
<h2 id="instalasi-1"><a class="header" href="#instalasi-1">Instalasi</a></h2>
<p>Untuk menggunakan Progress, kita perlu meng-install library third party</p>
<pre><code class="language-bash">npm install react-native-progress
</code></pre>
<h2 id="contoh"><a class="header" href="#contoh">Contoh</a></h2>
<pre><code class="language-javascript">import { StatusBar } from 'expo-status-bar';
import { useEffect, useState } from 'react';
import { StyleSheet, Text, View } from 'react-native';
import * as Progress from 'react-native-progress';

export default function App() {
  const [progress, setProgress] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setProgress((prev) =&gt; (prev &gt;= 1 ? 0 : prev + Math.random() * (0.5 - 0.01) + 0.01))
    }, 1000);
    return () =&gt; clearInterval(interval);
  }, []);

  return (
    &lt;View style={styles.container}&gt;
      &lt;Progress.Bar progress={progress} width={200} /&gt; // bar progress
      &lt;Progress.Circle progress={progress} size={80} showsText={true} /&gt;  // circle progress
      &lt;Progress.Bar indeterminate={true} width={200} /&gt;  // intermediate progress (durasi tidak diketahui)
      &lt;Progress.Bar
        progress={progress}
        width={250}
        color="green"
        unfilledColor="#ddd"
        borderWidth={2}
        borderColor="black"
      /&gt;  // custom style progress
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 15
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modal-dialog"><a class="header" href="#modal-dialog">Modal Dialog</a></h1>
<p>Komponen <code>Modal</code> di React Native digunakan untuk menampilkan konten sementara yang muncul di atas layar utama. Biasanya dipakai untuk popup, konfirmasi, form input, atau pesan penting.</p>
<h2 id="modal-dasar"><a class="header" href="#modal-dasar">Modal Dasar</a></h2>
<pre><code class="language-javascript">import React, { useState } from 'react';
import { Modal, View, Text, Button } from 'react-native';

export default function App() {
  const [visible, setVisible] = useState(false);

  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Button title="Tampilkan Modal" onPress={() =&gt; setVisible(true)} /&gt;

      &lt;Modal
        visible={visible}
        transparent={true}
        animationType="slide"
        onRequestClose={() =&gt; setVisible(false)} // untuk Android back button
      &gt;
        &lt;View style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: 'rgba(0,0,0,0.5)'
        }}&gt;
          &lt;View style={{
            width: 300,
            padding: 20,
            backgroundColor: 'white',
            borderRadius: 10
          }}&gt;
            &lt;Text style={{ fontSize: 18, marginBottom: 20 }}&gt;Halo, ini modal!&lt;/Text&gt;
            &lt;Button title="Tutup" onPress={() =&gt; setVisible(false)} /&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/Modal&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Komponen ini memiliki beberapa property penting:</p>
<ul>
<li><code>visible</code>: kontrol apakah modal muncul atau tidak.</li>
<li><code>transparent</code>: jika true, background luar modal bisa transparan.</li>
<li><code>animationType</code>: animasi saat modal muncul/hilang (none, slide, fade).</li>
<li><code>onRequestClose</code>: dipanggil ketika user tekan back button di Android.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style--layout"><a class="header" href="#style--layout">Style &amp; Layout</a></h1>
<p>Di React Native, styling dilakukan menggunakan <strong>JavaScript</strong>.<br />
Kita menggunakan <strong><code>StyleSheet</code></strong> atau <strong>inline style</strong> untuk mengatur tampilan komponen.</p>
<hr />
<h2 id="inline-style"><a class="header" href="#inline-style">Inline Style</a></h2>
<p>Cara paling sederhana adalah menuliskan style langsung di properti <code>style</code>:</p>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text style={{ color: 'blue', fontSize: 24 }}&gt;Halo, dunia!&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Cara ini efektif jika komponen tidak memerlukan banyak style.</p>
<h3 id="menggunakan-stylesheet"><a class="header" href="#menggunakan-stylesheet">Menggunakan StyleSheet</a></h3>
<p>Gunakan StyleSheet.create() untuk menggunakan style yang lebih rapi dan terstruktur.</p>
<pre><code class="language-ts">import { Text, View, StyleSheet } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.text}&gt;Halo, dunia!&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f2f2f2',
  },
  text: {
    color: 'blue',
    fontSize: 24,
    fontWeight: 'bold',
  },
});
</code></pre>
<h3 id="styling-text"><a class="header" href="#styling-text">Styling Text</a></h3>
<pre><code class="language-ts">&lt;Text style={{
  fontSize: 20,
  fontWeight: 'bold',
  fontStyle: 'italic',
  textAlign: 'center',
  textDecorationLine: 'underline',
}}&gt;
  Ini contoh teks
&lt;/Text&gt;
</code></pre>
<h3 id="styling-dengan-array"><a class="header" href="#styling-dengan-array">Styling dengan Array</a></h3>
<pre><code class="language-ts">&lt;Text style={[styles.text, { color: 'red' }]}&gt;
  Warna teks ini di-override jadi merah
&lt;/Text&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style--layout-lanjutan"><a class="header" href="#style--layout-lanjutan">Style &amp; Layout Lanjutan</a></h1>
<p>React Native menggunakan <strong>Flexbox</strong> untuk mengatur tata letak.<br />
Bedanya dengan web:</p>
<ul>
<li>Default <code>flexDirection</code> di web = <strong>row</strong></li>
<li>Default <code>flexDirection</code> di React Native = <strong>column</strong></li>
</ul>
<p>Artinya, secara default komponen disusun <strong>dari atas ke bawah</strong>.</p>
<hr />
<h2 id="flexbox-untuk-layout"><a class="header" href="#flexbox-untuk-layout">Flexbox untuk Layout</a></h2>
<p>React Native menggunakan Flexbox untuk mengatur tata letak.
Secara default, <code>flexDirection</code> di React Native adalah column (berbeda dengan web yang default-nya <code>row</code>).</p>
<p><strong>Flex direction</strong></p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', justifyContent: 'space-around' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<p><strong>Flex Grow</strong></p>
<pre><code class="language-ts">&lt;View style={{ flex: 1, flexDirection: 'row' }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ flex: 2, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ flex: 3, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="justifycontent"><a class="header" href="#justifycontent">justifyContent</a></h3>
<p>Mengatur posisi sepanjang main axis (sumbu utama = flexDirection).</p>
<ul>
<li><code>flex-start</code></li>
<li><code>center</code></li>
<li><code>flex-end</code></li>
<li><code>space-between</code></li>
<li><code>space-around</code></li>
<li><code>space-evenly</code></li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', justifyContent: 'space-between' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="alignitems"><a class="header" href="#alignitems">alignItems</a></h3>
<p>Mengatur posisi sepanjang cross axis (sumbu berlawanan dengan main axis).</p>
<ul>
<li><code>flex-start</code></li>
<li><code>center</code></li>
<li><code>flex-end</code></li>
<li><code>stretch</code></li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 100, backgroundColor: 'green' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="alignself"><a class="header" href="#alignself">alignSelf</a></h3>
<p>Digunakan pada child component untuk override <code>alignItems</code>.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', alignItems: 'flex-start' }}&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ width: 50, height: 50, backgroundColor: 'green', alignSelf: 'flex-end' }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="flex"><a class="header" href="#flex">flex</a></h3>
<p>Properti <code>flex</code> menentukan seberapa banyak ruang yang diambil relatif terhadap sibling-nya.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', flex: 1 }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'red' }} /&gt;
  &lt;View style={{ flex: 2, backgroundColor: 'green' }} /&gt;
  &lt;View style={{ flex: 3, backgroundColor: 'blue' }} /&gt;
&lt;/View&gt;
</code></pre>
<ul>
<li><code>flex: 1</code> → isi ruang secara proporsional.</li>
<li><code>flex: 0</code> → ukurannya tetap sesuai width/height.</li>
</ul>
<h3 id="flexwrap"><a class="header" href="#flexwrap">flexWrap</a></h3>
<p>Membungkus elemen jika ruang tidak cukup.</p>
<pre><code class="language-ts">&lt;View style={{ flexDirection: 'row', flexWrap: 'wrap' }}&gt;
  {Array.from({ length: 10 }).map((_, i) =&gt; (
    &lt;View
      key={i}
      style={{ width: 80, height: 80, backgroundColor: i % 2 ? 'tomato' : 'skyblue', margin: 4 }}
    /&gt;
  ))}
&lt;/View&gt;
</code></pre>
<p><strong>Contoh Kombinasi</strong></p>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ flex: 1, backgroundColor: 'tomato' }} /&gt;     {/* Header */}
  &lt;View style={{ flex: 4, backgroundColor: 'skyblue' }} /&gt;   {/* Content */}
  &lt;View style={{ flex: 1, backgroundColor: 'limegreen' }} /&gt; {/* Footer */}
&lt;/View&gt;
</code></pre>
<h2 id="positioning"><a class="header" href="#positioning">Positioning</a></h2>
<p>Selain Flexbox, React Native juga mendukung <strong>positioning</strong> untuk mengatur letak komponen.<br />
Prinsipnya mirip dengan CSS di web.</p>
<h3 id="relative-default"><a class="header" href="#relative-default">relative (default)</a></h3>
<ul>
<li>Semua komponen secara default memiliki <code>position: "relative"</code>.</li>
<li>Artinya posisinya ditentukan oleh layout Flexbox.</li>
<li>Jika kita menambahkan <code>top</code>, <code>left</code>, <code>right</code>, atau <code>bottom</code>, maka komponen akan bergeser relatif terhadap posisi normalnya.</li>
</ul>
<pre><code class="language-tsx">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} /&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'skyblue', top: 20, left: 20 }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="absolute"><a class="header" href="#absolute">absolute</a></h3>
<ul>
<li>Komponen akan dilepaskan dari alur Flexbox.</li>
<li>Posisi ditentukan relatif terhadap parent yang memiliki <code>position: "relative"</code> (atau container utamanya).</li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 200, height: 200, backgroundColor: 'lightgray' }}&gt;
    &lt;View style={{ position: 'absolute', top: 20, left: 20, width: 50, height: 50, backgroundColor: 'tomato' }} /&gt;
    &lt;View style={{ position: 'absolute', bottom: 20, right: 20, width: 50, height: 50, backgroundColor: 'skyblue' }} /&gt;
  &lt;/View&gt;
&lt;/View&gt;
</code></pre>
<h3 id="z-index"><a class="header" href="#z-index">Z-Index</a></h3>
<ul>
<li>Sama seperti CSS, digunakan untuk mengatur lapisan tumpukan.</li>
<li>Semakin besar <code>zIndex</code>, semakin berada di atas.</li>
</ul>
<pre><code class="language-ts">&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato', zIndex: 1, position: 'absolute', top: 50, left: 50 }} /&gt;
  &lt;View style={{ width: 100, height: 100, backgroundColor: 'skyblue', position: 'absolute', top: 70, left: 70 }} /&gt;
&lt;/View&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="props"><a class="header" href="#props">Props</a></h1>
<p>Dalam React Native, terdapat salah satu konsep penting yang perlu dipahami yaitu <code>props</code>. <code>Props</code>, singkatan dari <strong>properties</strong>, merupakan cara untuk mengirimkan data dari satu komponen ke komponen lain. Bayangkan <code>props</code> seperti sebuah "paket data" yang diberikan oleh komponen induk (<em>parent</em>) kepada komponen anak (<em>child</em>). Dengan cara ini, beberapa komponen dapat berinteraksi atau berkomunikasi dengan baik tanpa harus mengubah struktur dasarnya.</p>
<p><code>Props</code> bersifat read-only, artinya data yang dikirim melalui props hanya bisa dibaca oleh komponen penerima, tetapi tidak bisa diubah secara langsung dari dalam komponen tersebut. Hal ini menjadikan <code>props</code> sebagai fondasi utama dalam membangun komponen yang dapat digunakan kembali (<em>reusable components</em>).</p>
<p>Misalkan kita memiliki sebuah komponen bernama <code>Card</code>. Komponen ini dirancang untuk menampilkan nama dan pekerjaan seseorang. Menggunakan <code>props</code>, kita cukup membuat satu komponen <code>Card</code> lalu mengirimkan data yang berbeda melalui <code>props</code>.</p>
<pre><code class="language-jsx">// App.tsx
import { View, StyleSheet } from "react-native";
import Card from "./components/Card";

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Card name="John Petrucci" job="Guitarist" /&gt;
      &lt;Card name="Mike Portnoy" job="Drummer" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#fefefe"
  }
});
</code></pre>
<p>Pada kode di atas, komponen <code>App</code> berperan sebagai parent, sedangkan <code>Card</code> adalah child. Data <code>name</code> dan <code>job</code> dikirim ke dalam <code>Card</code> melalui props.</p>
<pre><code class="language-jsx">// components/Card.tsx
import { View, Text, StyleSheet } from "react-native";

type CardProps = {name:string, job:string}

export default function Card({ name, job }:CardProps) {
  return (
    &lt;View style={styles.card}&gt;
      &lt;Text style={styles.name}&gt;{name}&lt;/Text&gt;
      &lt;Text style={styles.job}&gt;{job}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  card: {
    width: 200,
    padding: 10,
    margin: 8,
    borderRadius: 8,
    backgroundColor: "#e0f7fa",
    alignItems: "center"
  },
  name: {
    fontSize: 18,
    fontWeight: "bold"
  },
  job: {
    fontSize: 14,
    color: "#555"
  }
});
</code></pre>
<p>Pada kode di atas, struktur dari <code>props</code> perlu didefinisikan terlebih dahulu melalui <code>type CardProps</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<p>Hooks adalah fungsi khusus yang memungkinkan kita untuk menggunakan fitur <code>React</code> seperti <code>state</code>, <code>lifecycle</code>, atau <code>context</code> ke dalam <code>function component</code>. Semua hook memiliki aturan yang sama:</p>
<ul>
<li>Selalu dipanggil di level atas <code>function component</code>.</li>
<li>Tidak dapat digunakan di dalam loop atau kondisi.</li>
<li>Selalu diawali dengan kata <code>use</code>.</li>
</ul>
<p>Di dalam hook terdapat beberapa konsep inti yang perlu dipahami:</p>
<ol>
<li>
<p><a href="state.html"><strong>State Management dengan <code>useState</code></strong></a></p>
<ul>
<li>Konsep: menyimpan dan mengubah data di dalam komponen.</li>
<li>Setiap kali state berubah, komponen akan re-<em>render</em>.</li>
<li>Contoh: menyimpan teks input, toggle boolean, counter.</li>
</ul>
</li>
<li>
<p><a href="side-effects.html"><strong>Side Effects dengan <code>useEffect</code></strong></a></p>
<ul>
<li>Konsep: menjalankan efek samping setelah render.</li>
<li>Penting karena React Native sifatnya declarative, dan <code>useEffect</code> dipakai untuk hal yang tidak langsung berhubungan dengan tampilan.</li>
<li>Contoh: memanggil <code>API</code>, mengatur timer, event listener, dan unsubscribe.</li>
</ul>
</li>
<li>
<p><a href="context.html"><strong>Context dengan <code>useContext</code></strong></a></p>
<ul>
<li>Konsep: berbagi data global antar komponen tanpa harus terus menerus menggunakan <code>props</code>.</li>
<li>Misalnya: tema aplikasi (dark/light), autentikasi user, bahasa.</li>
</ul>
</li>
<li>
<p><a href="reference.html"><strong>Reference dengan <code>useRef</code></strong></a></p>
<ul>
<li>Konsep: menyimpan nilai yang tidak memicu re-<em>render</em> ketika berubah.</li>
<li>Contoh: menyimpan nilai sementara (misalnya previous value) dan akses langsung ke komponen (misalnya TextInput focus).</li>
</ul>
</li>
<li>
<p><a href="reducer.html"><strong>Reducer dengan <code>useReducer</code></strong></a></p>
<ul>
<li>Konsep: alternatif dari <code>useState</code> untuk state yang lebih kompleks.</li>
<li>Contoh: cocok untuk logika yang melibatkan banyak aksi (misalnya form dengan banyak field).</li>
</ul>
</li>
<li>
<p><a href="custom-hooks.html"><strong>Custom Hooks</strong></a></p>
<ul>
<li>Konsep: membuat hook sendiri untuk mengabstraksi logika agar dapat digunakan ulang.</li>
<li>Contoh: <code>useAuth()</code>, <code>useFetch()</code>, <code>useOrientation()</code>.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-usestate"><a class="header" href="#state-usestate">State (<code>useState</code>)</a></h1>
<p>Setelah sebelumnya kita mengenal <code>props</code> sebagai cara untuk memberikan data dari luar ke dalam sebuah komponen, kini kita akan membahas konsep penting lainnya, yaitu <code>state</code>. Jika <code>props</code> dapat kita ibaratkan seperti paket data yang dikirim dari luar, maka state adalah data milik komponen itu sendiri yang dapat berubah sepanjang waktu.</p>
<p>Sebuah komponen dapat memiliki <code>state</code> untuk menyimpan informasi yang bersifat dinamis. Misalnya, ketika pengguna menekan tombol, mengetik di dalam sebuah input, atau ketika aplikasi menerima data baru dari server, semua perubahan tersebut bisa dikelola dengan <code>state</code>. Inilah yang membuat aplikasi menjadi interaktif.</p>
<p>Berbeda dengan <code>props</code> yang hanya bisa dibaca (<strong>read-only</strong>), <code>state</code> dapat diperbarui. Ketika <code>state</code> berubah, <strong>React Native</strong> akan secara otomatis melakukan <em>re-render</em> pada bagian komponen yang menggunakan <code>state</code> tersebut. Dengan demikian, tampilan aplikasi akan selalu sesuai dengan data terbaru.</p>
<p>Struktur dasarnya seperti ini:</p>
<pre><code class="language-jsx">const [value, setValue] = useState(initialValue);
</code></pre>
<ul>
<li><code>value</code>: isi <code>state</code> saat ini.</li>
<li><code>setValue</code>: fungsi untuk mengubah isi dari <code>state</code>.</li>
<li><code>initialValue</code>: nilai awal <code>state</code>.</li>
<li><code>useState</code>: hook <strong>React Native</strong>.</li>
</ul>
<h2 id="contoh-state-1-counter-sederhana"><a class="header" href="#contoh-state-1-counter-sederhana">Contoh State 1: Counter Sederhana</a></h2>
<p>Sebagai contoh, kita ingin menampilkan angka yang bertambah setiap kali pengguna menekan tombol "+" dan begitupun sebaliknya untuk tombol "-". Untuk menyimpan angka tersebut, kita menggunakan <code>state</code>. Setiap kali tombol ditekan, <code>state</code> diperbarui, dan tampilan angka pada layar pun langsung ikut berubah.</p>
<pre><code class="language-typescript">// App.tsx
import React, { useState } from "react";
import { View, Text, Button, StyleSheet } from "react-native";

export default function App() {
  // Membuat state bernama "count" dengan nilai awal 0
  const [count, setCount] = useState(0);

  return (
    &lt;View style={styles.container}&gt;
      // Komponen ini akan me-render jika ada perubahan nilai state
      &lt;Text style={[styles.text, count &lt; 0 ? { color: 'red' } : { color: 'black' }]}&gt;Count: {count}&lt;/Text&gt;
      &lt;View style={styles.button_container}&gt;
        &lt;Button 
          title="+" 
          // memanggil fungsi SetCount untuk menambah nilai state ketika button ditekan
          onPress={() =&gt; setCount(count + 1)} 
        /&gt;

        &lt;Button 
          title="-" 
          // memanggil fungsi SetCount untuk mengurangi nilai state ketika button ditekan
          onPress={() =&gt; setCount(count - 1)} 
        /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center"
  },
  text: {
    fontSize: 24,
    marginBottom: 20
  },
  button_container:{
    flexDirection:'row',
    justifyContent:'center',
    alignItems:'center',
    gap: 15
  }
});
</code></pre>
<p>Pada contoh di atas, kita menggunakan <strong><code>useState</code></strong> untuk membuat state <code>count</code>. Setiap kali tombol ditekan, fungsi <code>setCount</code> dipanggil untuk memperbarui nilai <code>count</code>. React Native kemudian secara otomatis memperbarui tampilan teks agar sesuai dengan nilai terbaru.</p>
<h2 id="contoh-state-2-menyimpan-input-teks"><a class="header" href="#contoh-state-2-menyimpan-input-teks">Contoh State 2: Menyimpan Input Teks</a></h2>
<p>Misalnya, kita ingin membuat aplikasi sederhana yang menampilkan teks berdasarkan teks yang diketik pengguna.</p>
<pre><code class="language-typescript">// App.tsx
import React, { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

export default function App() {
  // Membuat state bernama "name" dengan nilai awal empty string
  const [name, setName] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;Masukkan nama Anda:&lt;/Text&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik di sini..."
        value={name}
        // memanggil fungsi setName untuk mengubah nilai state (name) sesuai dengan input user
        onChangeText={(text) =&gt; setName(text)}
      /&gt;

      // Komponen ini akan me-render jika ada perubahan nilai state
      &lt;Text style={styles.greeting}&gt;
        {name ? `Halo, ${name}!` : "Silakan ketik nama Anda"}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  label: {
    fontSize: 18,
    marginBottom: 10,
  },
  input: {
    width: "100%",
    borderWidth: 1,
    borderColor: "#aaa",
    padding: 10,
    marginBottom: 20,
    borderRadius: 5,
  },
  greeting: {
    fontSize: 20,
    fontWeight: "bold",
  },
});
</code></pre>
<h2 id="contoh-state-3-menggunakan-usestate-pada-reusable-component"><a class="header" href="#contoh-state-3-menggunakan-usestate-pada-reusable-component">Contoh State 3: Menggunakan <code>useState</code> pada reusable component</a></h2>
<p>Misalnya kita ingin membuat <code>CustomInput</code> yang bisa dipakai di banyak tempat. Komponen ini memiliki state untuk menyimpan teks lokal, lalu menampilkan hasil ketikan.</p>
<h3 id="apptsx"><a class="header" href="#apptsx">App.tsx</a></h3>
<pre><code class="language-typescript">import React from "react";
import { View, StyleSheet } from "react-native";
import CustomInput from "./components/CustomInput";

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;CustomInput label="Nama" placeholder="Masukkan nama Anda" /&gt;
      &lt;CustomInput label="Email" placeholder="Masukkan email Anda" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    padding: 20,
  },
});
</code></pre>
<h3 id="componentscustominputtsx"><a class="header" href="#componentscustominputtsx">components/CustomInput.tsx</a></h3>
<pre><code class="language-typescript">import React, { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

type CustomInputProps = {
  label: string,
  placeholder: string
};

export default function CustomInput({ label, placeholder }:CustomInputProps) {
  // Membuat state lokal bernama "value" dengan nilai awal empty string
  const [value, setValue] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;{label}&lt;/Text&gt;
      &lt;TextInput
        style={styles.input}
        placeholder={placeholder}
        value={value}
        // memanggil fungsi setValue untuk mengubah nilai state sesuai dengan input user
        onChangeText={(text) =&gt; setValue(text)}
      /&gt;

      // komponen akan di re-render jika nilai state berubah
      &lt;Text style={styles.preview}&gt;
        {value ? `Anda mengetik: ${value}` : "Belum ada input"}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
  },
  input: {
    borderWidth: 1,
    borderColor: "#aaa",
    padding: 10,
    borderRadius: 5,
  },
  preview: {
    marginTop: 5,
    fontSize: 14,
    color: "#555",
  },
});

</code></pre>
<p>Pada contoh program di atas, setiap instance <code>CustomInput</code> (yang ditambahkan ke dalam App()) memiliki state masing-masing (sehingga input nama tidak mengganggu input email).</p>
<h2 id="contoh-state-4-array-state"><a class="header" href="#contoh-state-4-array-state">Contoh State 4: Array State</a></h2>
<h3 id="componentstodolisttsx"><a class="header" href="#componentstodolisttsx">components/TodoList.tsx</a></h3>
<pre><code class="language-typescript">import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';

export default function TodoList() {
  
  const [todos, setTodos] = useState([]);

  const addTodo = () =&gt; {
    // membuat salinan array lama sehingga data yang sudah tersimpan tidak hilang
    setTodos([...todos, `Tugas ${todos.length + 1}`]);
  };

  return (
    &lt;View&gt;
      // memanggil fungsi addTodo untuk menambah data baru ke dalam state
      &lt;Button title="Tambah Tugas" onPress={addTodo} /&gt;
      {todos.map((todo, index) =&gt; (
        &lt;Text key={index}&gt;{todo}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}
</code></pre>
<p>Kalau state berupa array, biasanya perlu membuat salinan array lama lalu tambahkan data baru, agar state tetap immutable (<code>...todos</code>).</p>
<p><code>useState</code> adalah pondasi penting dalam React Native karena hampir semua komponen interaktif butuh state. Tanpa <code>useState</code>, aplikasi cuma hanya berupa sekumpulan teks dan gambar statis.</p>
<p><code>useState</code> memiliki tiga aturan simpel berikut:</p>
<ul>
<li>Mengembalikan sepasang nilai (state saat ini) dan fungsi untuk mengubah state.</li>
<li>Setiap kali state berubah, komponen otomatis merender ulang.</li>
<li>State bisa berupa apa pun: string, number, boolean, array, object, bahkan kombinasi.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="side-effects-useeffect"><a class="header" href="#side-effects-useeffect">Side Effects (<code>useEffect</code>)</a></h1>
<p>Kalau sebelumnya kita belajar tentang state yang bisa menyimpan data dinamis di sebuah komponen, sekarang saatnya masuk ke hal lain yang tidak kalah penting: side effect.</p>
<p>Side effect adalah segala hal yang terjadi di luar proses rendering UI. Contohnya:</p>
<ul>
<li>Memanggil API untuk mengambil data.</li>
<li>Mengatur timer atau interval.</li>
<li>Mengupdate judul aplikasi atau menyimpan data ke storage.</li>
</ul>
<p><code>useEffect</code> adalah hook yang memungkinkan kita menjalankan kode setiap kali komponen selesai di-<em>render</em>. Dengan kata lain, dia seperti lifecycle methods di class component (componentDidMount, componentDidUpdate, dan componentWillUnmount) tapi digabung dalam satu fungsi.</p>
<p>Struktur dasarnya seperti ini:</p>
<pre><code class="language-tsx">useEffect(() =&gt; {
  // kode yang mau dijalankan setelah render

  return () =&gt; {
    // optional: kode cleanup
  };
}, [dependencies]);
</code></pre>
<ul>
<li>Bagian pertama <code>(() =&gt; { ... })</code> adalah efek yang dijalankan.</li>
<li><code>return () =&gt; { ... }</code> adalah cleanup function, dipanggil ketika efek harus dibersihkan (misalnya saat komponen di-unmount atau sebelum efek baru dipasang lagi).</li>
<li><code>[dependencies]</code> adalah array berisi nilai yang diawasi. Efek hanya dijalankan ulang ketika nilai di array ini berubah.</li>
</ul>
<h2 id="contoh-1-dipanggil-setiap-render"><a class="header" href="#contoh-1-dipanggil-setiap-render">Contoh 1: Dipanggil Setiap Render</a></h2>
<pre><code class="language-tsx">import React, { useState, useEffect } from 'react';
import { View, Text, Button } from 'react-native';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Komponen dirender. Nilai count:', count);
  });

  return (
    &lt;View&gt;
      &lt;Text&gt;Count: {count}&lt;/Text&gt;
      &lt;Button title="Tambah" onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Karena kita tidak memberi dependency array, efek ini akan dipanggil setiap kali komponen dirender.</p>
<h2 id="contoh-2-hanya-sekali"><a class="header" href="#contoh-2-hanya-sekali">Contoh 2: Hanya Sekali</a></h2>
<pre><code class="language-tsx">useEffect(() =&gt; {
  console.log('Komponen baru saja muncul di layar');

  // cleanup
  return () =&gt; {
    console.log('Komponen hilang dari layar');
  };
}, []);
</code></pre>
<p>Dengan dependency array kosong <code>[]</code>, efek hanya dijalankan sekali saat komponen pertama kali dipasang, lalu dibersihkan saat komponen dilepas.</p>
<h2 id="contoh-3-bergantung-pada-state-tertentu"><a class="header" href="#contoh-3-bergantung-pada-state-tertentu">Contoh 3: Bergantung Pada State Tertentu</a></h2>
<pre><code class="language-tsx">import React, { useState, useEffect } from 'react';
import { View, Text, Button } from 'react-native';

export default function NameWatcher() {
  const [name, setName] = useState('Mike');
  const [age, setAge] = useState(20);

  useEffect(() =&gt; {
    console.log('Nama berubah:', name);
  }, [name]); // hanya jalan kalau "name" berubah

  return (
    &lt;View&gt;
      &lt;Text&gt;{name} - {age}&lt;/Text&gt;
      &lt;Button title="Ganti Nama" onPress={() =&gt; setName('Portnoy')} /&gt;
      &lt;Button title="Tambah Umur" onPress={() =&gt; setAge(age + 1)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Efek ini cuma jalan kalau nilai <code>name</code> berubah. Kalau <code>age</code> yang berubah, efek tidak akan dijalankan.</p>
<h2 id="contoh-4-memanggil-api"><a class="header" href="#contoh-4-memanggil-api">Contoh 4: Memanggil API</a></h2>
<pre><code class="language-tsx">import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

export default function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) =&gt; res.json())
      .then((data) =&gt; {
        setUsers(data);
        setLoading(false);
      });
  }, []); // hanya sekali dijalankan saat komponen pertama kali render

  if (loading) return &lt;ActivityIndicator /&gt;;

  return (
    &lt;View&gt;
      {users.map((user) =&gt; (
        &lt;Text key={user.id}&gt;{user.name}&lt;/Text&gt;
      ))}
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>useEffect</code> adalah salah satu hook paling penting di React Native. Memungkinkan kita untuk menangani hal-hal yang berhubungan dengan dunia luar render UI seperti API, timer, event listener, dan lain-lain.</p>
<p><code>useEffect</code> memiliki tiga aturan simpel berikut:</p>
<ul>
<li>Tanpa dependency array → jalan setiap render.</li>
<li>Dengan array kosong <code>[]</code> → jalan sekali di awal.</li>
<li>Dengan array berisi state/props → jalan setiap kali nilai itu berubah.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-usecontext"><a class="header" href="#context-usecontext">Context (<code>useContext</code>)</a></h1>
<p>Ketika ukuran aplikasi masih tergolong kecil, komunikasi antar komponen yang umumnya melalui <code>props</code> cukup mudah dilakukan. Bayangkan apabila data yang dikirimkan ke banyak komponen dan berada di hirarki yang cukup dalam. Menggunakan <code>props</code> untuk mengirimkan data ke setiap level tentunya bukan teknik yang efektif karena nantinya akan mempersulit pengelolaan aplikasi.</p>
<p>Dengan <code>context</code>, data dapat disimpan secara global sehingga dapat diakses oleh komponen mana pun tanpa harus melempar data menggunakan <code>props</code>.</p>
<p>Secara sederhana, <code>Context</code> memiliki tiga bagian utama:</p>
<ul>
<li><strong>Membuat Context</strong> → menggunakan <code>React.createContext()</code>.</li>
<li><strong>Provider</strong> → komponen yang membungkus bagian aplikasi, dan isinya adalah data yang akan dibagikan.</li>
<li><strong>Consumer</strong> → komponen yang membaca data dari <code>Context</code>.</li>
</ul>
<h2 id="contoh-theme-context-darklight-mode"><a class="header" href="#contoh-theme-context-darklight-mode">Contoh: Theme Context (Dark/Light Mode)</a></h2>
<p>Struktur folder:</p>
<pre><code class="language-bash">/components
   └── ThemedButton.tsx
/context
   └── ThemeContext.tsx
/screens
   └── HomeScreen.tsx
App.tsx
</code></pre>
<p><strong>ThemeContext.tsx</strong></p>
<pre><code class="language-tsx">import React from "react";
import { createContext, useState } from "react";

type ContextType = {
    theme:string,
    toggleTheme: () =&gt; void
}

type Props = {
    children: ReactNode
}

export const ThemeContext = createContext&lt;ContextType&gt;('light'); // nilai default

export function ThemeProvider({ props }:Props) {
    const [theme, setTheme] = useState('light');
    const toggleTheme = () =&gt; setTheme(theme == 'light' ? 'dark' : 'light');
    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {props.children}
        &lt;/ThemeContext.Provider&gt;
    );
}
</code></pre>
<p><code>createContext('light')</code> bertindak sebagai wadah (context) untuk menyimpan data yang dapat digunakan di seluruh komponen. Di sini context akan menyimpan theme (light/dark) dan fungsi toggleTheme.</p>
<p><code>ThemeProvider</code> adalah komponen pembungkus dengan <code>state</code> awal bernilai light. <code>ThemeContext.Provider</code> membagikan data (<code>theme</code>, <code>toggleTheme</code>) ke semua komponen di dalamnya (<code>children</code>). Artinya, komponen apa pun yang ada di bawah <code>ThemeProvider</code> dapat mengambil <code>theme</code> dan <code>toggleTheme</code>.</p>
<p><strong>ThemedButton.tsx</strong></p>
<pre><code class="language-tsx">import { useContext } from "react";
import { ThemeContext } from "../context/ThemeContext";
import { Text, TouchableOpacity } from "react-native";

type Props = {
    title: string,
    onPress: () =&gt; void
};

export default function ThemedButton({props}:Props) {
    const { theme } = useContext(ThemeContext);

    const backgroundColor = theme === 'light' ? '#007BFF' : '#555';
    const textColor = theme === 'light' ? '#fff' : '#ddd';

    return (
        &lt;TouchableOpacity
            style={{
                backgroundColor,
                padding: 12,
                borderRadius: 8,
                margin: 5,
            }}
            onPress={props.onPress}&gt;
            &lt;Text style={{ color: textColor, fontWeight: 'bold' }}&gt;{props.title}&lt;/Text&gt;
        &lt;/TouchableOpacity&gt;
    );
}
</code></pre>
<p><strong>HomeScreen.tsx</strong></p>
<pre><code class="language-tsx">import { useContext } from "react";
import { ThemeContext } from "../context/ThemeContext";
import { Text, View } from "react-native";
import ThemedButton from "../components/ThemedButton";

export default function HomeScreen() {
    const { theme, toggleTheme } = useContext(ThemeContext);
    return (
        &lt;View style={{
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: theme === 'light' ? '#fff' : '#333',
        }}&gt;
            &lt;Text style={{ color: theme === 'light' ? '#000' : '#fff' }}&gt;
                Tema saat ini: {theme}
            &lt;/Text&gt;
            &lt;ThemedButton title="Ganti Tema" onPress={toggleTheme} /&gt;
            &lt;ThemedButton title="Button Tambahan" onPress={() =&gt; { }} /&gt;

        &lt;/View&gt;
    );
}
</code></pre>
<p><code>useContext(ThemeContext)</code> digunakan untuk mengakses value atau fungsi yang diturunkan oleh <code>ThemeContext</code>.</p>
<p><strong>App.tsx</strong></p>
<pre><code class="language-tsx">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';
import { ThemeProvider } from './context/ThemeContext';
import HomeScreen from './screens/HomeScreen';

export default function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;HomeScreen /&gt;
    &lt;/ThemeProvider&gt;
  );
}
</code></pre>
<h2 id="alur-program"><a class="header" href="#alur-program">Alur Program</a></h2>
<ol>
<li><code>App.tsx</code> → Komponen parent yang membungkus seluruh komponen lainnya dengan <code>ThemeProvider</code> agar seluruh komponen <em>child</em> dapat mengakses <code>ThemeContext</code>.</li>
<li><code>ThemeContext.tsx</code> → Menyimpan state tema (<code>light</code> atau <code>dark</code>) dan menyediakan fungsi <code>toggleTheme</code> untuk mengubah <code>state</code> tema.</li>
<li><code>HomeScreen.tsx</code> → Menampilkan teks sesuai tema + tombol untuk ganti tema.</li>
<li><code>ThemedButton.tsx</code> → Komponen tombol yang mengatur gaya sesuai tema.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-useref"><a class="header" href="#reference-useref">Reference (<code>useRef</code>)</a></h1>
<p><code>useRef</code> adalah salah satu hooks pada React Native yang berguna untuk menyimpan nilai atau mereferensikan elemen tanpa menyebabkan komponen melakukan render ulang. Kalau <code>useState</code> selalu bikin render ulang saat nilainya berubah, <code>useRef</code> tidak. Nilai yang disimpan di <code>useRef</code> tetap ada selama komponen hidup, tapi perubahan nilainya tidak memicu re-<em>render</em>.</p>
<p><code>useRef</code> cocok digunakan pada kasus:</p>
<ol>
<li>Menyimpan nilai lama (previous value).</li>
<li>Mengakses dan mengontrol elemen UI (misalnya TextInput).</li>
<li>Menyimpan variabel yang berubah-ubah tapi tidak perlu re-<em>render</em> misalnya timer.</li>
<li>Membuat animasi</li>
</ol>
<h2 id="contoh-1-menyimpan-nilai-lama"><a class="header" href="#contoh-1-menyimpan-nilai-lama">Contoh 1: Menyimpan Nilai Lama</a></h2>
<p>Kadang kita ingin tahu nilai sebelum <code>state</code> berubah. <code>useRef</code> dapat menyimpan history ini.</p>
<pre><code class="language-tsx">import React, { useState, useEffect, useRef } from "react";
import { View, Text, Button } from "react-native";

export default function App() {
  const [score, setScore] = useState(0);
  const prevScoreRef = useRef(0);

  useEffect(() =&gt; {
    prevScoreRef.current = score; // update setiap kali score berubah
  }, [score]);

  return (
    &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}&gt;
      &lt;Text&gt;Current Score: {score}&lt;/Text&gt;
      &lt;Text&gt;Previous Score: {prevScoreRef.current}&lt;/Text&gt;
      &lt;Button title="Add 10" onPress={() =&gt; setScore(score + 10)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>prevScoreRef.current</code> selalu menyimpan nilai sebelum update.</p>
<h2 id="contoh-2-mengontrol-input"><a class="header" href="#contoh-2-mengontrol-input">Contoh 2: Mengontrol Input</a></h2>
<p>Dengan <code>useRef</code>, kita dapat fokus langsung ke input tanpa perlu <code>state</code> tambahan.</p>
<pre><code class="language-tsx">import React, { useRef } from "react";
import { View, TextInput, Button } from "react-native";

export default function App() {
  const inputRef = useRef(null);

  const focusInput = () =&gt; {
    inputRef.current.focus(); // langsung fokus ke input
  };

  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;TextInput
        ref={inputRef}
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
        placeholder="Type something..."
      /&gt;
      &lt;Button title="Focus Input" onPress={focusInput} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p><code>inputRef</code> dipakai untuk mengakses komponen TextInput langsung.</p>
<h2 id="contoh-3-timer-dengan-useref"><a class="header" href="#contoh-3-timer-dengan-useref">Contoh 3: Timer dengan useRef</a></h2>
<pre><code class="language-tsx">import React, { useRef, useState } from "react";
import { View, Text, Button } from "react-native";

export default function App() {
  const [seconds, setSeconds] = useState(0);
  const timerRef = useRef(null);

  const startTimer = () =&gt; {
    if (timerRef.current) return; // cegah timer ganda
    timerRef.current = setInterval(() =&gt; {
      setSeconds((prev) =&gt; prev + 1);
    }, 1000);
  };

  const stopTimer = () =&gt; {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };

  return (
    &lt;View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}&gt;
      &lt;Text&gt;⏱ {seconds} seconds&lt;/Text&gt;
      &lt;Button title="Start" onPress={startTimer} /&gt;
      &lt;Button title="Stop" onPress={stopTimer} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reducer-usereducer"><a class="header" href="#reducer-usereducer">Reducer (<code>useReducer</code>)</a></h1>
<p><code>useReducer</code> adalah hook di React Native yang digunakan untuk mengelola state yang lebih kompleks dibanding <code>useState</code>. Jika <code>useState</code> cocok untuk perubahan state yang sederhana, <code>useReducer</code> lebih cocok digunakan saat kita memiliki logika update state yang melibatkan banyak kondisi atau aturan.</p>
<pre><code class="language-jsx">const [state, dispatch] = useReducer(reducer, initialState);
</code></pre>
<ul>
<li><strong>state</strong> → nilai state saat ini</li>
<li><strong>dispatch</strong> → fungsi untuk mengirimkan action</li>
<li><strong>reducer</strong> → fungsi yang menentukan bagaimana state berubah</li>
<li><strong>initialState</strong> → nilai awal state</li>
</ul>
<pre><code class="language-jsx">function reducer(state, action) {
  switch (action.type) {
    case "actionType":
      return stateBaru;
    default:
      return state;
  }
}
</code></pre>
<p>Reducer menerima state lama dan sebuah action, lalu mengembalikan state baru.</p>
<h2 id="contoh-1-counter"><a class="header" href="#contoh-1-counter">Contoh 1: Counter</a></h2>
<h3 id="apptsx-1"><a class="header" href="#apptsx-1">App.tsx</a></h3>
<pre><code class="language-jsx">
import { StatusBar } from 'expo-status-bar';
import { useReducer } from 'react';
import { StyleSheet, View } from 'react-native';
import Counter from './components/Counter';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Counter title="Counter" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 20
  }
});
</code></pre>
<h3 id="componentscountertsx"><a class="header" href="#componentscountertsx">components/Counter.tsx</a></h3>
<pre><code class="language-tsx">
import { useReducer } from "react";
import { Button, StyleSheet, Text, View } from "react-native";

type State = {
    count: number
}

const initialState: State = { count: 0 };

type Action = { jenis: "increment" } | { jenis: "decrement" };

const reducer = (state: State, action: Action): State =&gt; {
    switch (action.jenis) {
        case "increment":
            return { count: state.count + 1 };
        case "decrement":
            return { count: state.count - 1 };
        default:
            return state;
    }
}

type CounterProps = { title: string }
export default function Counter({ title }: CounterProps) {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        &lt;View style={styles.card}&gt;
            &lt;Text style={styles.title}&gt;{title}&lt;/Text&gt;
            &lt;Text style={[styles.content, state.count &lt; 0 &amp;&amp; { color: 'red' }]}&gt;{state.count}&lt;/Text&gt;
            &lt;View style={styles.button_container}&gt;
                &lt;Button title="Kurangi" onPress={() =&gt; dispatch({ jenis: "decrement" })} /&gt;
                &lt;Button title="Tambah" onPress={() =&gt; dispatch({ jenis: 'increment' })} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}

const styles = StyleSheet.create({
    card: {
        width: 240,
        padding: 10,
        borderRadius: 8,
        backgroundColor: '#fff',
        elevation: 3,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
    },
    title: {
        fontSize: 18,
        fontWeight: 'bold',
    },
    content: {
        alignSelf: 'center',
        fontSize: 28,
        fontWeight: "600",
    },
    button_container: {
        padding: 8,
        borderTopWidth: 1,
        borderTopColor: '#4b4b4bff',
        flexDirection: 'row',
        gap: 10,
        justifyContent: 'center',
        alignItems: 'center'
    }
});
</code></pre>
<p>Dengan <code>dispatch</code>, kita mengirim action (misalnya <code>{ jenis: "increment" }</code>), lalu reducer mengatur perubahan <code>state</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-hooks"><a class="header" href="#custom-hooks">Custom Hooks</a></h1>
<p>Custom Hook adalah fungsi buatan kita sendiri yang mengikuti aturan Hook (diawali dengan <code>use...</code>) untuk mengenkapsulasi logic tertentu agar dapat digunakan ulang di berbagai komponen.</p>
<p>Jika <code>useState</code>, <code>useEffect</code>, <code>useReducer</code>, dll adalah hook bawaan <strong>React Native</strong>, maka custom hook memungkinkan kita bikin versi sendiri sesuai kebutuhan.</p>
<p>Custom hook memberikan beberapa keuntungan, seperti:</p>
<ol>
<li>Kode lebih bersih &amp; reusable</li>
<li>Logic &amp; UI terpisah</li>
<li>Lebih mudah testing</li>
</ol>
<h2 id="contoh-1-hook-untuk-input-text"><a class="header" href="#contoh-1-hook-untuk-input-text">Contoh 1: Hook untuk Input Text</a></h2>
<pre><code class="language-tsx">// hooks/UseInput.ts
import { useState } from "react";

// custom hook
function useInput(initialValue = "") {
  const [value, setValue] = useState(initialValue);

  const onChangeText = (text) =&gt; setValue(text);
  const reset = () =&gt; setValue("");

  return { value, onChangeText, reset };
}

export default useInput;
</code></pre>
<pre><code class="language-tsx">// App.tsx
import React from "react";
import { View, TextInput, Button, Text } from "react-native";
import useInput from "./hooks/UseInput";

export default function App() {
  const name = useInput("");
  const email = useInput("");

  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;TextInput
        placeholder="Nama"
        value={name.value}
        onChangeText={name.onChangeText}
        style={{ borderWidth: 1, marginBottom: 10, padding: 5 }}
      /&gt;
      &lt;TextInput
        placeholder="Email"
        value={email.value}
        onChangeText={email.onChangeText}
        style={{ borderWidth: 1, marginBottom: 10, padding: 5 }}
      /&gt;
      &lt;Button title="Submit" onPress={() =&gt; {
        console.log("Nama:", name.value, "Email:", email.value);
        name.reset();
        email.reset();
      }} /&gt;
      &lt;Text style={{ marginTop: 10 }}&gt;
        Nama: {name.value} | Email: {email.value}
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<p>Pada dasarnya, event handling adalah mekanisme untuk menangani aksi yang dilakukan pengguna, seperti menekan tombol, mengetik teks, atau melakukan scroll. Di React Native, event handling dilakukan dengan cara menghubungkan sebuah event handler (fungsi) dengan properti event dari suatu komponen. Secara umum, ada beberapa kategori event yang sering dipakai:</p>
<p><strong>1. Event pada komponen interaktif (tombol, touchable)</strong></p>
<ul>
<li><code>onPress</code> → saat komponen ditekan (Button, TouchableOpacity, Pressable).</li>
<li><code>onLongPress</code> → saat ditekan lama.</li>
<li><code>onPressIn</code> dan <code>onPressOut</code> → saat jari menyentuh &amp; melepas.</li>
</ul>
<p><strong>2. Event pada input teks</strong></p>
<ul>
<li><code>onChangeText</code> → saat teks berubah.</li>
<li><code>onFocus</code> → saat input aktif (fokus).</li>
<li><code>onBlur</code> → saat input kehilangan fokus.</li>
<li><code>onSubmitEditing</code> → saat user menekan tombol submit/enter.</li>
</ul>
<p><strong>3. Event pada list / scroll</strong></p>
<ul>
<li><code>onScroll</code> → saat daftar/scrollview digulir.</li>
<li><code>onEndReached</code> (FlatList/SectionList) → saat mendekati akhir daftar.</li>
<li><code>onRefresh</code> → saat user menarik ke bawah (pull to refresh).</li>
</ul>
<p><strong>4. Event gesture / sentuhan</strong></p>
<ul>
<li><code>onTouchStart</code>, <code>onTouchMove</code>, <code>onTouchEnd</code> → event dasar sentuhan.</li>
<li>Jika pakai <code>PanResponder</code> atau library react-native-gesture-handler, bisa dapat event lebih kompleks seperti swipe, drag, fling.</li>
</ul>
<p><strong>5. Event pada image &amp; media</strong></p>
<ul>
<li><code>onLoad</code> dan <code>onError</code> (Image) → saat gambar berhasil/gagal dimuat.</li>
<li><code>onLoadStart</code> dan <code>onLoadEnd</code> → progres load gambar.</li>
</ul>
<h2 id="contoh-event-handling-1"><a class="header" href="#contoh-event-handling-1">Contoh Event Handling 1</a></h2>
<pre><code class="language-jsx">// App.tsx
import { useState } from "react";
import { View, Text, Button, StyleSheet } from "react-native";

export default function App() {
  const [count, setCount] = useState(0);

  const handlePress = () =&gt; {
    setCount(count + 1); // setiap kali tombol ditekan, count bertambah
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.text}&gt;Jumlah klik: {count}&lt;/Text&gt;
      &lt;Button title="Klik Saya" onPress={handlePress} /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
</code></pre>
<p>Pada contoh di atas, event <code>onPress</code> dari komponen <code>Button</code> dipasangkan dengan fungsi <code>handlePress</code>. Setiap kali tombol ditekan, state <code>count</code> akan bertambah satu, dan perubahan state ini akan langsung di-<em>rerender</em> pada teks yang ditampilkan.</p>
<h2 id="contoh-event-handling-2"><a class="header" href="#contoh-event-handling-2">Contoh Event Handling 2</a></h2>
<pre><code class="language-jsx">// App.tsx
import { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

export default function App() {
  const [name, setName] = useState("");

  return (
    &lt;View style={styles.container}&gt;
      &lt;TextInput
        style={styles.input}
        placeholder="Ketik nama Anda"
        onChangeText={(text) =&gt; setName(text)}
      /&gt;
      &lt;Text style={styles.text}&gt;Halo, {name}!&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    padding: 10,
    width: 200,
    marginBottom: 20,
  },
  text: {
    fontSize: 18,
  },
});
</code></pre>
<p>Di sini, setiap kali pengguna mengetik, event <code>onChangeText</code> akan dijalankan dan memperbarui state name. Tampilan pun otomatis menyesuaikan dengan isi teks terbaru.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation"><a class="header" href="#navigation">Navigation</a></h1>
<p>Saat membuat aplikasi mobile, biasanya tidak hanya terdiri atas satu halaman saja. Misalnya aplikasi belanja online: ada halaman beranda, halaman detail produk, halaman keranjang belanja, hingga halaman profil pengguna. Semua halaman ini harus bisa saling terhubung agar pengalaman pengguna berjalan mulus. Bayangkan kalau aplikasi hanya menampilkan satu halaman statis, pengguna pasti akan kesulitan, karena tidak bisa berpindah ke informasi lain. Inilah alasan mengapa navigasi menjadi bagian yang sangat penting dalam pengembangan aplikasi mobile.</p>
<p>Di React Native sendiri, <strong>tidak terdapat navigasi bawaan</strong>. Artinya, diperlukan library tambahan untuk menangani navigasi antar halaman. Library yang paling populer dan direkomendasikan adalah <strong>React Navigation</strong>.</p>
<p>Dengan React Navigation, kita dapat:</p>
<ul>
<li>Membuat alur berpindah antar layar dengan Stack Navigation.</li>
<li>Membuat menu bawah dengan Tab Navigation.</li>
<li>Membuat menu samping dengan Drawer Navigation.</li>
</ul>
<h2 id="instalasi-2"><a class="header" href="#instalasi-2">Instalasi</a></h2>
<p>Setelah membuat project baru, tambahkan atau install dependencies berikut:</p>
<pre><code class="language-bash">npm install @react-navigation/native
</code></pre>
<p><strong>Expo</strong></p>
<pre><code class="language-bash">npx expo install react-native-screens react-native-safe-area-context react-native-gesture-handler react-native-reanimated
</code></pre>
<p><strong>React Native CLI</strong></p>
<pre><code class="language-bash">npm install react-native-screens react-native-safe-area-context react-native-gesture-handler react-native-reanimated
</code></pre>
<p>iOS</p>
<pre><code class="language-bash">npx pod-install ios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-navigation"><a class="header" href="#stack-navigation">Stack Navigation</a></h1>
<h2 id="konsep-dasar"><a class="header" href="#konsep-dasar">Konsep Dasar</a></h2>
<ul>
<li>Stack navigation mirip tumpukan kartu.</li>
<li>Setiap kali pindah ke layar baru → layar ditaruh di atas stack.</li>
<li>Ketika kembali → layar di atas dihapus, dan kita kembali ke layar sebelumnya.</li>
<li>Ini cocok untuk alur seperti: <code>Home → Detail → Settings</code></li>
<li>Mekanismenya mirip riwayat browser:
<ul>
<li><code>navigate()</code> = buka halaman baru dan <code>push</code> stack.</li>
<li><code>goBack()</code> = kembali ke halaman sebelumnya <code>pop</code> stack.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi"><a class="header" href="#struktur-implementasi">Struktur Implementasi</a></h2>
<p>Sebenarnya, navigasi jenis ini dapat diinisialisasi langsung pada file main yaitu <code>App.tsx</code>. Struktur modular lebih disukai karena kemudahannya dalam proyek jangka panjang yang selalu berkembang.</p>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── StackNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    └── DetailScreen.tsx
</code></pre>
<h2 id="instalasi-3"><a class="header" href="#instalasi-3">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/native-stack
</code></pre>
<h2 id="contoh-1"><a class="header" href="#contoh-1">Contoh</a></h2>
<h3 id="screenshomescreentsx"><a class="header" href="#screenshomescreentsx">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { View, Text, Button } from 'react-native';
import { RootStackParamList } from '../navigations/StackNavigator';

type Props = NativeStackScreenProps&lt;RootStackParamList, 'Home'&gt;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button
                title="Lihat Detail"
                onPress={() =&gt; navigation.navigate('Detail', { id: 101, barang: "Laptop" })}
            /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = NativeStackScreenProps&lt;RootStackParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home. Strukturnya dapat dilihat pada <a href="stack-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Detail', { id: 101, barang: "Laptop" })</code>: pindah ke halaman Detail, sekaligus mengirim data id = 101 dan barang = "Laptop".</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman detail dengan parameter.</p>
<h3 id="screensdetailscreentsx"><a class="header" href="#screensdetailscreentsx">screens/DetailScreen.tsx</a></h3>
<pre><code class="language-javascript">import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { View, Text, Button } from 'react-native';
import { RootStackParamList } from '../navigations/StackNavigator';

type Props = NativeStackScreenProps&lt;RootStackParamList, 'Detail'&gt;

export default function DetailScreen({ route, navigation }: Props) {
    const { id, barang } = route.params || {};

    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Detail Screen&lt;/Text&gt;
            &lt;Text&gt;ID: {id}&lt;/Text&gt;
            &lt;Text&gt;Barang: {barang}&lt;/Text&gt;
            &lt;Button title="Kembali" onPress={() =&gt; navigation.goBack()} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = NativeStackScreenProps&lt;RootStackParamList, 'Detail'&gt;</code>: tipe props khusus untuk halaman Detail. Strukturnya dapat dilihat pada <a href="stack-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>route.params</code>: berisi data yang dikirim dari Home.</li>
<li><code>navigation</code>: digunakan untuk kembali atau pindah ke halaman lain.</li>
<li><code>const { id, barang } = route.params</code>: mengambil parameter id dan barang.</li>
</ul>
<p>Jadi, <code>DetailScreen.tsx</code> adalah halaman kedua yang menerima data dari Home dan bisa kembali ke halaman sebelumnya.</p>
<h3 id="TabNavigator.tsx"><a class="header" href="#TabNavigator.tsx">navigations/StackNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import HomeScreen from '../screens/HomeScreen';
import DetailScreen from '../screens/DetailScreen';

export type RootStackParamList = {
    Home: undefined,
    Detail: { id: number, barang: string }
}

const Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();

export default function StackNavigator() {
    return (
        &lt;Stack.Navigator initialRouteName="Home"
            screenOptions={{
                headerStyle: {
                    backgroundColor: '#f4511e',
                },
                headerTintColor: '#fff',
                headerTitleStyle: {
                    fontWeight: 'bold',
                },
            }}
        &gt;
            &lt;Stack.Screen
                name="Home"
                component={HomeScreen}
                options={{
                    title: 'Halaman Utama',
                }}
            /&gt;
            &lt;Stack.Screen
                name="Detail"
                component={DetailScreen}
                options={{ title: 'Detail Item' }}
            /&gt;
        &lt;/Stack.Navigator&gt;
    );
}
</code></pre>
<ul>
<li><code>RootStackParamList</code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Detail: { id: number, barang: string }</code>: Detail wajib menerima parameter id bertipe number dan barang bertipe string.</li>
</ul>
</li>
<li><code>createNativeStackNavigator&lt;RootStackParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Stack.Navigator</code>: mendefinisikan kumpulan screen.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/native-stack-navigator#options" target="_blank">halaman ini</a></li>
<li><code>Stack.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>options</code>: properti tambahan (misalnya judul di header).</li>
<li>API lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/stack-navigator/#api-definition" target="_blank">halaman ini</a></li>
</ul>
</li>
</ul>
<p>Jadi, <code>StackNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-2"><a class="header" href="#apptsx-2">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import StackNavigator from './navigations/StackNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;StackNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}

</code></pre>
<ul>
<li><code>NavigationContainer</code>: komponen utama dari React Navigation yang membungkus seluruh aplikasi. Tanpa ini, navigasi tidak dapat berjalan.</li>
<li><code>StackNavigator</code>: definisi struktur navigasi.</li>
</ul>
<p>Jadi, <code>App.tsx</code> adalah pintu masuk aplikasi yang menghubungkan navigasi dengan seluruh halaman.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bottom-tabs-navigation"><a class="header" href="#bottom-tabs-navigation">Bottom Tabs Navigation</a></h1>
<h2 id="konsep-dasar-1"><a class="header" href="#konsep-dasar-1">Konsep Dasar</a></h2>
<ul>
<li>Bottom Tabs navigation menampilkan menu tab di bawah layar.</li>
<li>Setiap tab adalah sebuah halaman (atau bahkan bisa berupa navigator lain seperti Stack).</li>
<li>Cocok untuk aplikasi dengan menu utama seperti: Home, Profile, Settings.</li>
<li>Karakteristiknya:
<ul>
<li>Tab yang aktif akan menampilkan screen terkait.</li>
<li>Navigasi antar tab tidak tumpukan (stack), jadi berpindah tab tidak menyimpan riwayat antar tab.</li>
<li>Bisa diberi ikon dan label untuk tiap tab.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi-1"><a class="header" href="#struktur-implementasi-1">Struktur Implementasi</a></h2>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── TabNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    ├── SearchScreen.tsx
    └── ProfileScreen.tsx
</code></pre>
<p>Struktur project di atas bukanlah aturan yang wajib diikuti. Struktur di atas menggunakan pendekatan modular karena:</p>
<ul>
<li>Maintainable: mudah diatur jika screen semakin banyak.</li>
<li>Scalable: mudah menambahkan jenis navigasi lainnya seperti Stack atau Drawer.</li>
<li>Clean code: App.tsx tetap terlihat ringkas.</li>
</ul>
<h2 id="instalasi-4"><a class="header" href="#instalasi-4">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/bottom-tabs
npx expo install @expo/vector-icons
</code></pre>
<h2 id="contoh-2"><a class="header" href="#contoh-2">Contoh</a></h2>
<h3 id="screenshomescreentsx-1"><a class="header" href="#screenshomescreentsx-1">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Button, Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Home'&gt;;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: "center", alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button title="Ke Profil" onPress={() =&gt; navigation.navigate('Profile')} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Profile')</code>: pindah ke halaman Profile.</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman Profile.</p>
<h3 id="screensprofilescreentsx"><a class="header" href="#screensprofilescreentsx">screens/ProfileScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Profile'&gt;;

export default function ProfileScreen({ }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Profil Screen&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Profile'&gt;</code>: mendefinisikan props khusus untuk halaman Profile, namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="bottom-tabs-navigation.html#TabNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="screenssettingscreentsx"><a class="header" href="#screenssettingscreentsx">screens/SettingScreen.tsx</a></h3>
<pre><code class="language-javascript">import { BottomTabScreenProps } from "@react-navigation/bottom-tabs";
import { RootParamList } from "../navigations/TabNavigator";
import { Text, View } from "react-native";

type Props = BottomTabScreenProps&lt;RootParamList, 'Setting'&gt;;

export default function SettingScreen() {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;Ini Setting Screen&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = BottomTabScreenProps&lt;RootParamList, 'Setting'&gt;</code>: mendefinisikan props khusus untuk halaman Profile, namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="bottom-tabs-navigation.html#TabNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="TabNavigator.tsx"><a class="header" href="#TabNavigator.tsx">navigations/TabNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import HomeScreen from "../screens/HomeScreen";
import ProfileScreen from "../screens/ProfileScreen";
import SettingScreen from "../screens/SettingScreen";
import { Ionicons } from "@expo/vector-icons";


export type RootParamList = {
    Home: undefined,
    Profile: undefined,
    Setting: undefined
};

const Tab = createBottomTabNavigator&lt;RootParamList&gt;();

export default function TabNavigator() {
    return (
        &lt;Tab.Navigator initialRouteName="Home"
            screenOptions={{
                headerShown: true,
                tabBarActiveTintColor: '#f4511e',
                tabBarInactiveTintColor: 'gray',
            }}
        &gt;
            &lt;Tab.Screen name="Home" component={HomeScreen} options={{
                title: "Halaman Utama",
                tabBarLabel: 'Home',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'home' : 'home-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
            &lt;Tab.Screen name="Profile" component={ProfileScreen} options={{
                title: "Halaman Profil",
                tabBarLabel: 'Profile',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'person' : 'person-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
            &lt;Tab.Screen name="Setting" component={SettingScreen} options={{
                title: "Halaman Setting",
                tabBarLabel: 'Home',
                tabBarIcon: ({ focused, color, size }) =&gt; (
                    &lt;Ionicons name={focused ? 'settings' : 'settings-outline'}
                        color={color}
                        size={size} /&gt;
                )
            }} /&gt;
        &lt;/Tab.Navigator&gt;
    )
}
</code></pre>
<ul>
<li><code>RootParamList </code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Profile: undefined</code>: Profile tidak menerima parameter.</li>
<li><code>Setting: undefined</code>: Setting tidak menerima parameter.</li>
</ul>
</li>
<li><code>createBottomTabNavigator&lt;RootParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Tab.Navigator</code>: mendefinisikan kumpulan tab.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/bottom-tab-navigator/" target="_blank">halaman ini</a></li>
<li><code>Tab.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>options</code>: properti tambahan (misalnya judul di header dan icon tab).</li>
</ul>
</li>
</ul>
<p>Jadi, <code>TabNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-3"><a class="header" href="#apptsx-3">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import TabNavigator from './navigations/TabNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;TabNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawer-navigation"><a class="header" href="#drawer-navigation">Drawer Navigation</a></h1>
<h2 id="konsep-dasar-2"><a class="header" href="#konsep-dasar-2">Konsep Dasar</a></h2>
<ul>
<li>Drawer navigation menampilkan menu geser dari sisi kiri layar (kadang kanan).</li>
<li>Setiap item di drawer mengarah ke sebuah halaman atau bahkan ke navigator lain (Stack / Tabs).</li>
<li>Cocok untuk aplikasi dengan banyak menu yang tidak cukup untuk dimuat pada bottom tab, misalnya: <code>Home</code>, <code>Profile</code>, <code>Settings</code>, <code>About</code>.</li>
<li>Karakteristiknya:
<ul>
<li>Drawer dapat dimunculkan melalui gesture swipe atau tombol hamburger menu.</li>
<li>Drawer dapat dikustomisasi dengan menambahkan ikon, avatar, atau section.</li>
</ul>
</li>
</ul>
<h2 id="struktur-implementasi-2"><a class="header" href="#struktur-implementasi-2">Struktur Implementasi</a></h2>
<pre><code class="language-bash">project/
│ App.tsx
│
├── navigations/
│   └── TabNavigator.tsx
│
└── screens/
    ├── HomeScreen.tsx
    ├── SearchScreen.tsx
    ├── SettingScreen.tsx
    └── ProfileScreen.tsx
</code></pre>
<p>Struktur project di atas bukanlah aturan yang wajib diikuti. Struktur di atas menggunakan pendekatan modular karena:</p>
<ul>
<li>Maintainable: mudah diatur jika screen semakin banyak.</li>
<li>Scalable: mudah menambahkan jenis navigasi lainnya seperti Stack atau Drawer.</li>
<li>Clean code: App.tsx tetap terlihat ringkas.</li>
</ul>
<h2 id="instalasi-5"><a class="header" href="#instalasi-5">Instalasi</a></h2>
<pre><code class="language-bash">npm install @react-navigation/drawer
npx expo install @expo/vector-icons
</code></pre>
<h2 id="contoh-3"><a class="header" href="#contoh-3">Contoh</a></h2>
<h3 id="screenshomescreentsx-2"><a class="header" href="#screenshomescreentsx-2">screens/HomeScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Button, Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Home'&gt;;

export default function HomeScreen({ navigation }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini Home Screen&lt;/Text&gt;
            &lt;Button title="Profile" onPress={() =&gt; navigation.navigate('Profile', { id: 666, nama: 'John Doe' })} /&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Home'&gt;</code>: mendefinisikan props khusus untuk halaman Home.</li>
<li><code>navigation</code>: digunakan untuk berpindah ke halaman lain.</li>
<li><code>navigation.navigate('Profile')</code>: pindah ke halaman Profile sekaligus mengirim data id = 666 dan barang = "John Doe".</li>
</ul>
<p>Jadi, <code>HomeScreen.tsx</code> adalah halaman awal aplikasi yang dapat mengarahkan user ke halaman Profile dengan parameter.</p>
<h3 id="screensprofilescreentsx-1"><a class="header" href="#screensprofilescreentsx-1">screens/ProfileScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Profile'&gt;;

export default function ProfileScreen({ route, navigation }: Props) {
    const { id, nama } = route.params || {};
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', gap: 15 }}&gt;
            &lt;Text style={{ fontSize: 22 }}&gt;Ini adalah halaman profil, halo&lt;/Text&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;id: {id}&lt;/Text&gt;
            &lt;Text style={{ fontSize: 18 }}&gt;nama: {nama}&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Profile'&gt;</code>: tipe props khusus untuk halaman Profile. Strukturnya dapat dilihat pada <a href="drawer-navigation.html#TabNavigator.tsx">bagian ini</a>.</li>
<li><code>route.params</code>: berisi data yang dikirim dari Home.</li>
<li><code>navigation</code>: digunakan untuk kembali atau pindah ke halaman lain.</li>
<li><code>const { id, nama } = route.params</code>: mengambil parameter id dan nama.</li>
</ul>
<h3 id="screenssearchscreentsx"><a class="header" href="#screenssearchscreentsx">screens/SearchScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Search'&gt;;
export default function SearchScreen({ }: Props) {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini adalah halaman search&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Search'&gt;</code>: tipe props khusus untuk halaman Profile. Namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="drawer-navigation.html#DrawerNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="screenssearchscreentsx-1"><a class="header" href="#screenssearchscreentsx-1">screens/SearchScreen.tsx</a></h3>
<pre><code class="language-javascript">import { DrawerScreenProps } from "@react-navigation/drawer";
import { RootParamList } from "../navigations/DrawerNavigator";
import { Text, View } from "react-native";

type Props = DrawerScreenProps&lt;RootParamList, 'Setting'&gt;;

export default function SettingScreen() {
    return (
        &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
            &lt;Text style={{ fontSize: 20 }}&gt;Ini adalah halaman setting&lt;/Text&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<ul>
<li><code>Props = DrawerScreenProps&lt;RootParamList, 'Setting'&gt;</code>: tipe props khusus untuk halaman Profile. Namun karena type data untuk <code>prop</code> didefinisikan dengan <code>undefined</code> <a href="drawer-navigation.html#DrawerNavigator.tsx">lihat disini</a>, maka tidak ada parameter pada halaman ini.</li>
</ul>
<h3 id="DrawerNavigator.tsx"><a class="header" href="#DrawerNavigator.tsx">navigations/DrawerNavigator.tsx</a></h3>
<pre><code class="language-javascript">import { createDrawerNavigator } from "@react-navigation/drawer";
import HomeScreen from "../screens/HomeScreen";
import ProfileScreen from "../screens/ProfileScreen";
import SearchScreen from "../screens/SearchScreen";
import SettingScreen from "../screens/SettingScreen";

export type RootParamList = {
    Home: undefined,
    Profile: { id: number, nama: string },
    Search: undefined,
    Setting: undefined
};

const Drawer = createDrawerNavigator&lt;RootParamList&gt;();
export default function DrawerNavigator() {
    return (
        &lt;Drawer.Navigator
            initialRouteName="Home"
            screenOptions={{
                headerStyle: { backgroundColor: '#f4511e' },
                headerTintColor: '#fff',
                drawerActiveTintColor: '#f4511e',
                drawerInactiveTintColor: 'gray',
            }}
        &gt;
            &lt;Drawer.Screen name="Home" component={HomeScreen} /&gt;
            &lt;Drawer.Screen name="Profile" component={ProfileScreen} initialParams={{ id: 666, nama: "John Doe" }} /&gt;
            &lt;Drawer.Screen name="Search" component={SearchScreen} /&gt;
            &lt;Drawer.Screen name="Setting" component={SettingScreen} /&gt;
        &lt;/Drawer.Navigator&gt;
    );
}
</code></pre>
<ul>
<li><code>RootParamList </code>: mendefinisikan semua screen dan parameter yang boleh dipassing.
<ul>
<li><code>Home: undefined</code>: Home tidak menerima parameter.</li>
<li><code>Profile: { id: number, nama: string }</code>: Profile wajib menerima parameter id bertipe number dan nama bertipe string.</li>
<li><code>Search: undefined</code>: Search tidak menerima parameter.</li>
<li><code>Setting: undefined</code>: Setting tidak menerima parameter.</li>
</ul>
</li>
<li><code>createDrawerNavigator&lt;RootParamList&gt;()</code>: membuat navigator dengan dukungan type checking TypeScript.</li>
<li><code>Drawer.Navigator</code>: mendefinisikan kumpulan halaman.</li>
<li><code>initialRouteName="Home"</code>: halaman pertama.</li>
<li><code>screenOptions</code>: konfigurasi header dan <code>options</code> lainnya dapat dilihat pada <a href="https://reactnavigation.org/docs/drawer-navigator/" target="_blank">halaman ini</a></li>
<li><code>Drawer.Screen</code>: tiap layar didaftarkan di sini dengan:
<ul>
<li><code>name</code>: nama route.</li>
<li><code>component</code>: file halaman.</li>
<li><code>initialParams</code>: definisi parameter default</li>
</ul>
</li>
</ul>
<p>Jadi, <code>DrawerNavigator.tsx</code> adalah peta aplikasi yang mengatur halaman apa saja yang ada dan bagaimana rutenya.</p>
<h3 id="apptsx-4"><a class="header" href="#apptsx-4">App.tsx</a></h3>
<pre><code class="language-javascript">import { NavigationContainer } from '@react-navigation/native';
import DrawerNavigator from './navigations/DrawerNavigator';

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;DrawerNavigator /&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation"><a class="header" href="#animation">Animation</a></h1>
<p>Animasi merupakan salah satu aspek penting dalam memberikan nuansa hidup pada aplikasi. Dengan animasi, transisi antar komponen terasa lebih alami, interaksi lebih nyata, dan pengalaman pengguna meningkat.</p>
<p>React Native menyediakan dua pendekatan utama untuk membuat animasi:</p>
<ol>
<li><a href="animated-api.html">Animated API (built-in)</a> cocok untuk animasi sederhana &amp; state-driven.</li>
<li><a href="reanimated-gesture-handler.html">Reanimated library (eksternal)</a> lebih efisien &amp; mendukung gesture interaktif (digunakan di banyak app modern seperti Instagram).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animated-api"><a class="header" href="#animated-api">Animated API</a></h1>
<p><code>Animated</code> adalah API bawaan (tidak butuh instalasi tambahan) React Native untuk mengubah nilai tampilan secara halus dari satu keadaan ke keadaan lainnya. Cocok untuk animasi sederhana berbasis state, seperti:</p>
<ul>
<li>Fade in / fade out</li>
<li>Translasi (geser)</li>
<li>Skala (zoom)</li>
<li>Rotasi</li>
</ul>
<p><code>Animated</code> memiliki beberapa konsep utama yang perlu diketahui:</p>
<ul>
<li>
<p>Tidak seluruh komponen bawaan dari react native dapat menggunakan Animasi. Beberapa komponen yang dapat diberikan animasi adalah: <code>Animated.View</code>, <code>Animated.Text</code>, <code>Animated.Image</code>, <code>Animated.ScrollView</code>, <code>Animated.FlatList</code>, <code>Animated.SectionList</code>.</p>
<pre><code class="language-tsx">&lt;Animated.View style={{
    opacity: opacityAnim,
    width: 150,
    height: 150,
    backgroundColor: 'skyblue',
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
}}&gt;
</code></pre>
</li>
<li>
<p><code>Animated.Value()</code>: Menyimpan nilai numerik yang berubah seiring waktu. Nilai ini bisa dihubungkan ke properti <code>style</code> seperti <code>opacity</code>, <code>transform</code>, atau <code>position</code>. Biasanya disimpan menggunakan <code>hook</code> <code>useRef</code>.</p>
<pre><code class="language-tsx">const anim = useRef(new Animated.Value(0)).current;
</code></pre>
<p><code>Animated.Value</code> dapat dianggap seperti “state khusus animasi”. Nilainya bisa berubah secara bertahap oleh sistem animasi tanpa menyebabkan re-render React.</p>
</li>
<li>
<p><code>Animated.timing()</code>: Mengubah nilai dalam durasi tertentu. Method ini juga dapat kita berikan <code>delay</code> maupun <code>easing</code>. <code>Easing</code> merupakan kurva animasi yang dimulai dan diakhiri dengan perlahan, namun bergerak cepat di bagian tengahnya. Ini menghasilkan gerakan yang lebih halus dan natural, mirip dengan bagaimana objek di dunia nyata bergerak</p>
<pre><code class="language-tsx">Animated.timing(anim, {
    toValue: 1,        // nilai akhir animasi
    duration: 1000,    // dalam milidetik
    easing: Easing.bounce,  // kurva animasi
    delay:100,         // dalam milidetik
    useNativeDriver: true // untuk performa lebih baik
}).start();           // wajib agar animasi dijalankan
</code></pre>
<p>Konfigurasi lengkapnya dapat dilihat pada halaman <a href="https://reactnative.dev/docs/animated#timing">ini</a>. Sedangkan untuk jenis <code>easing</code> dapat dilihat pada halaman <a href="https://reactnative.dev/docs/easing">ini</a></p>
</li>
<li>
<p><code>Animated.decay()</code>: Membuat animasi yang dimulai dengan kecepatan awal yang diberikan, lalu melambat secara bertahap hingga berhenti sepenuhnya, meniru efek seperti gesekan.</p>
<pre><code class="language-tsx">Animated.decay(anim, {
    velocity: 0.5,          // kecepatan awal
    deceleration: 0.997,    // semakin kecil, semakin cepat berhenti
    useNativeDriver: true
}).start();

</code></pre>
</li>
<li>
<p><code>Animated.spring()</code>: Menciptakan efek pegas realistis seperti pantulan dan ayunan.</p>
<pre><code class="language-tsx">Animated.spring(anim, {
    toValue: 1,
    friction: 4,     // gesekan (semakin besar → lebih lambat)
    tension: 60,     // ketegangan pegas (semakin besar → lebih cepat)
    useNativeDriver: true
}).start();
</code></pre>
</li>
</ul>
<p>Beberapa Animasi dapat dikombinasikan menggunakan:</p>
<ul>
<li>
<p><code>Animated.sequence()</code>: Menyusun dan menjalankan animasi secara berurutan. Animasi dijalankan satu-persatu.</p>
<pre><code class="language-tsx">Animated.sequence([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.delay()</code>: Menciptakan jeda antar animasi.</p>
<pre><code class="language-tsx">Animated.sequence([
    Animated.decay()
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay()
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.parallel()</code>: Menjalankan beberapa animasi secara bersamaan.</p>
<pre><code class="language-tsx">Animated.parallel([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
<li>
<p><code>Animated.stagger()</code>: Menjalankan rangkaian animasi dengan durasi jeda yang sama.</p>
<pre><code class="language-tsx">Animated.stagger(
    200, // delay antar animasi
    [
        Animated.timing(anim, {
            toValue: 1,
            duration: 1000,
            easing: Easing.bounce,
            useNativeDriver: true
        }),
        Animated.decay(anim, {
            velocity: 0.5,
            deceleration: 0.997,
            useNativeDriver: true
        })
    ]
).start();
</code></pre>
</li>
<li>
<p><code>Animated.loop()</code>: Mengulangi animasi secara terus menerus.</p>
<pre><code class="language-tsx">Animated.loop([
    Animated.timing(anim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.bounce,
        useNativeDriver: true
    }),
    Animated.decay(anim, {
        velocity: 0.5,
        deceleration: 0.997,
        useNativeDriver: true
    })
]).start();
</code></pre>
</li>
</ul>
<h2 id="contoh-animasi"><a class="header" href="#contoh-animasi">Contoh: Animasi</a></h2>
<p>Struktur folder:</p>
<pre><code class="language-bash">/components
   ├── FadeBox.tsx
   ├── ScaleBox.tsx
   └── TranslateBox.tsx
/screens
   └── HomeScreen.tsx
App.tsx
</code></pre>
<p><strong>FadeBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, Text, View, Button } from "react-native";

export default function FadeBox() {
    const fadeAnim = useRef(new Animated.Value(0)).current;

    const fadeIn = () =&gt; {
        Animated.timing(fadeAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true
        }).start();
    }

    const fadeOut = () =&gt; {
        Animated.timing(fadeAnim, {
            toValue: 0,
            duration: 1000,
            useNativeDriver: true
        }).start()
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                opacity: fadeAnim,
                width: 150,
                height: 150,
                backgroundColor: 'skyblue',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Fade Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Fade In" onPress={fadeIn} /&gt;
                &lt;Button title="Fade Out" onPress={fadeOut} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const fadeAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>fadeAnim</code>, dan nantinya akan diubah oleh fungsi <code>fadeIn()</code> dan <code>fadeOut()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai fadeAnim tidak di-reset setiap kali komponen di-render ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini opacity) adalah 0, artinya komponen dimulai dalam keadaan transparan.</li>
</ul>
<p><code>fadeIn()</code> memiliki beberapa property, yaitu:</p>
<ul>
<li><code>Animated.timing()</code> mengatur perubahan nilai animasi secara bertahap.</li>
<li><code>toValue: 1</code> artinya fadeAnim akan meningkat dari 0 → 1, membuat komponen semakin terlihat.</li>
<li><code>duration: 1000</code> menunjukkan animasi berlangsung selama 1 detik (1000 ms).</li>
<li><code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</li>
</ul>
<p><code>fadeOut()</code> memiliki beberapa property yang serupa dengan fungsi fadeIn(). Perbedaan terletak pada nilai dari property <code>toValue: 1</code> yang menunjukkan <code>opacity</code> akan turun dari 1 → 0.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>opacity</code> dihubungkan langsung ke <code>fadeAnim</code>. Saat <code>fadeAnim</code> berubah, React Native akan otomatis menyesuaikan opacity komponen atau membuat efek fade in dan fade out.</p>
<p><strong>ScaleBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, View, EasingFunction, Text, Button, Easing } from "react-native";

export default function ScaleBox() {
    const scaleAnim = useRef(new Animated.Value(0)).current;

    const zoomIn = () =&gt; {
        Animated.spring(scaleAnim, {
            toValue: 1,
            friction: 2,
            tension: 40,
            useNativeDriver: true
        }).start()
    }

    const zoomOut = () =&gt; {
        Animated.spring(scaleAnim, {
            toValue: 0,
            friction: 4,
            tension: 60,
            useNativeDriver: true
        }).start()
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                transform: [
                    { scale: scaleAnim }
                ],
                width: 150,
                height: 150,
                backgroundColor: '#87eba2',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Slide Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Zoom In" onPress={zoomIn} /&gt;
                &lt;Button title="Zoom Out" onPress={zoomOut} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const scaleAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>scaleAnim</code>, dan nantinya akan diubah oleh fungsi <code>zoomIn()</code> dan <code>zoomOut()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai scaleAnim tidak di-reset setiap kali komponen di-render ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini scale) adalah 0, artinya komponen dimulai dalam ukuran (scale) yang kecil.</li>
</ul>
<p><code>zoomIn()</code> memiliki beberapa property, yaitu:
- <code>Animated.spring()</code> untuk menghasilkan efek pegas (spring motion).
- <code>toValue: 1</code> artinya sacleAnim akan meningkat dari 0 → 1, membuat komponen kembali ke ukuran normal.
- <code>friction</code> mengontrol gesekan. Semakin tinggi nilainya, maka semakin cepat animasi berhenti.
- <code>tension</code> mengontrol daya tarik pegas. Semakin besar nilainya, semakin cepat pergerakan awal animasi.
- <code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</p>
<p><code>zoomOut()</code> memiliki beberapa property yang serupa dengan fungsi zoomIn(). Perbedaan terletak pada nilai dari property <code>toValue: 1</code> yang menunjukkan <code>scale</code> akan turun dari 1 → 0.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>transform</code> dengan <code>{scale: scaleAnim}</code> dihubungkan langsung ke <code>scaleAnim</code>. Saat <code>sacleAnim</code> berubah, React Native akan otomatis menyesuaikan ukuran (<code>scale</code>) komponen.</p>
<p><strong>TranslateBox.tsx</strong></p>
<pre><code class="language-tsx">import { useRef } from "react";
import { Animated, Text, View, Button } from "react-native";

export default function TranslatedBox() {
    const slideAnim = useRef(new Animated.Value(0)).current;

    const startDecay = () =&gt; {
        Animated.decay(slideAnim, {
            velocity: 1.5,
            deceleration: 0.997,
            useNativeDriver: true
        }).start();
    }

    return (
        &lt;View style={{ alignItems: 'center', padding: 10, borderColor: '#fdfd', borderWidth: 1, borderRadius: 7, width: '30%' }}&gt;
            &lt;Animated.View style={{
                transform: [
                    { translateY: slideAnim }
                ],
                width: 150,
                height: 150,
                backgroundColor: '#87eba2',
                borderRadius: 10,
                justifyContent: 'center',
                alignItems: 'center',
            }}&gt;
                &lt;Text style={{ fontWeight: 'bold' }}&gt;Slide Box&lt;/Text&gt;
            &lt;/Animated.View&gt;
            &lt;View style={{ marginTop: 20, flexDirection: 'row', gap: 10 }}&gt;
                &lt;Button title="Start deacy" onPress={startDecay} /&gt;
                &lt;Button title="Reset deacy" onPress={() =&gt; slideAnim.setValue(0)} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
}
</code></pre>
<p><em><strong>Penjelasan</strong></em></p>
<p><code>const slideAnim = useRef(new Animated.Value(0)).current;</code> membuat nilai animasi awal dengan nilai 0. Nilai tersebut disimpan dalam <code>slideAnim</code>, dan nantinya akan diubah oleh fungsi <code>startDecay()</code>.</p>
<ul>
<li><code>useRef()</code> digunakan agar nilai <code>slideAnim</code> tidak di-<em>reset</em> setiap kali komponen di-<em>render</em> ulang.</li>
<li><code>Animated.Value(0)</code> berarti nilai awal untuk properti animasi (dalam hal ini posisi) adalah 0, artinya komponen dimulai dalam posisi awal yaitu 0.</li>
</ul>
<p><code>startDecay()</code> memiliki beberapa property, yaitu:
- <code>Animated.decay()</code> untuk menghasilkan animasi yang berhenti secara alami seperti benda yang bergerak lalu melambat karena gaya gesek.
- <code>velocity: 1</code> konfigurasi kecepatan awal animasi. Semakin tinggi nilainya, maka semakin cepat animasi bergerak.
- <code>deceleration</code> mengontrol laju perlambatan. Semakin tinggi nilainya (mendekati 1), maka gerakan berhenti lebih lambat.
- <code>useNativeDriver: true</code> membuat animasi dijalankan di native thread, sehingga lebih halus dan efisien.</p>
<p><code>Animated.View</code> digunakan agar properti style bisa dianimasikan. Properti <code>transform</code> dengan <code>{translateY: scaleAnim}</code> dihubungkan langsung ke <code>slideAnim</code>. Saat <code>slideAnim</code> berubah, React Native akan otomatis menyesuaikan posisi (<code>translateY</code>) komponen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reanimated-api"><a class="header" href="#reanimated-api">Reanimated API</a></h1>
<p>Merupakan library pihak ketiga untuk membuat animasi dengan performa tinggi di React Native. Reanimated memungkinkan kita untuk menjalankan logika animasi langsung di native thread, sehingga animasi tetap halus bahkan ketika JavaScript thread sibuk. <code>Reanimated</code> sangat cocok digunakan untuk animasi interaktif dan kompleks seperti:</p>
<ul>
<li>Drag &amp; drop</li>
<li>Gesture-based animations (dengan <code>react-native-gesture-handler</code>)</li>
<li>Scroll animations</li>
<li>Transition antar halaman</li>
</ul>
<p>Sebelum menggunakan <a href="https://docs.swmansion.com/react-native-reanimated/"><code>Reanimated</code></a>, terdapat beberapa hal yang perlu dilakukan yaitu instalasi dependency dan melakukan rebuild plugin.</p>
<h2 id="instalasi-6"><a class="header" href="#instalasi-6">Instalasi</a></h2>
<pre><code class="language-bash">npm install react-native-reanimated react-native-worklets
</code></pre>
<h2 id="rebuild"><a class="header" href="#rebuild">Rebuild</a></h2>
<p><strong>Expo</strong></p>
<p>Jalankan perintah berikut pada terminal</p>
<pre><code class="language-bash">npx expo prebuild
</code></pre>
<p><strong>React Native CLI</strong></p>
<p>Tambahkan plugin <code>react-native-worklets/plugin</code> secara manual pada file <code>babel.config.js</code>. Pastikan <code>react-native-worklets/</code> berada di baris paling akhir.</p>
<pre><code class="language-js">module.exports = {
presets: [
    ... // don't add it here :)
],
plugins: [
    ...
    'react-native-worklets/plugin',
],
};
</code></pre>
<p>Khusus penggunaan <code>web</code> yang dibangun menggunakan React native CLI, selain wajib menambahkan <code>react-native-web</code> dan <code>react-dom</code>, kita perlu menambahkan plugin <code>@babel/plugin-proposal-export-namespace-from</code> lalu rebuild dengan cara menambahkan plugin tersebut ke <code>babel.config.js</code>.</p>
<pre><code class="language-bash">npm install @babel/plugin-proposal-export-namespace-from
</code></pre>
<pre><code class="language-js">module.exports = {
    presets: [
    ... // don't add it here :)
    ],
    plugins: [
        ...
        '@babel/plugin-proposal-export-namespace-from',
        'react-native-worklets/plugin',
    ],
};
</code></pre>
<p><code>Reanimated</code> memiliki beberapa konsep dasar yang perlu diketahui:</p>
<h3 id="usesharedvalue"><a class="header" href="#usesharedvalue"><code>useSharedValue</code></a></h3>
<p>Digunakan untuk menginisialisasi nilai numerik yang bisa berubah tanpa menyebabkan re-<em>render</em> React. Mirip seperti <code>Animated.Value()</code>, tapi lebih efisien karena berjalan di native thread. Untuk mengakses data pada <em>shared value</em>, kita dapat menggunakan property <code>value</code>.</p>
<pre><code class="language-tsx">const animation_value = useSharedValue(0);  // inisialisasi shared value
animation_value.value = 1; // mengubah shared value

const animation_value = useSharedValue({x: 0, y: 0});  // inisialisasi shared value
animation_value.value = {x: 50, y: -20}; // mengubah shared value

const animation_value = useSharedValue([1, 2, 3]);  // inisialisasi shared value
animation_value.value.push(4);
animation_value.value = [...animation_value.value, 1000]
</code></pre>
<h3 id="useanimatedstyle"><a class="header" href="#useanimatedstyle"><code>useAnimatedStyle</code></a></h3>
<p>Digunakan untuk membuat <code>object style</code> animasi. Mirip seperti <code>StyleSheet</code> namun, nilainya diambil dari <em>shared value</em>. Setiap kali nilai berubah, style akan diperbarui otomatis di native layer.</p>
<pre><code class="language-tsx">const animatedStyle = useAnimatedStyle(() =&gt; {
  return { opacity: opacity.value };
});
</code></pre>
<h3 id="useanimatedprops"><a class="header" href="#useanimatedprops"><code>useAnimatedProps</code></a></h3>
<p>Memiliki fungsi yang mirip seperti <code>useAnimatedStyle</code>, tetapi bukan untuk style melainkan untuk <code>props</code> dari komponen yang dapat dianimasikan seperti <code>progress</code> pada <code>Animated.ProgressBar</code>, <code>strokeDashoffset</code> pada <code>SVG</code>, atau <code>text</code> pada <code>Animated.TextInput</code>. Artinya, kita dapat memberikan animasi pada suatu komponen jika property yang ingin dianimasikan bukan bagian dari style. Reanimated akan mengupdate props tersebut secara langsung dari native thread sehingga komponen react tidak mengalami re-<em>render</em>.</p>
<pre><code class="language-tsx">const animatedProps = useAnimatedProps(() =&gt; {
  return {
    propertyName: someSharedValue.value,
  };
});
</code></pre>
<p>Kemudian digunakan di komponen Animated.<Component> seperti ini (misalnya pada komponen View):</p>
<pre><code class="language-tsx">&lt;Animated.View animatedProps={animatedProps} /&gt;
</code></pre>
<h3 id="withtiming"><a class="header" href="#withtiming"><code>withTiming</code></a></h3>
<p>Merupakan fungsi animasi yang dimiliki oleh Reanimated dan berfungsi untuk membuat nilai <code>shared value</code> berubah secara bertahap dari nilai awal ke nilai target selama periode tertentu. Selain itu, kita juga dapat mengatur kecepatan animasi melalui <code>Easing</code>.</p>
<pre><code class="language-tsx">import { Easing, ReduceMotion } from 'react-native-reanimated';

withTiming(shared_value.value, {
    duration: 1000,  // dalam milisecond
    easing: Easing.inOut(Easing.quad),  
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<h3 id="withspring"><a class="header" href="#withspring"><code>withSpring</code></a></h3>
<p>Merupakan fungsi yang digunakan untuk membuat animasi yang meniru gerakan pegas. Artinya, nilai akan bergerak menuju target (toValue), namun dengan sedikit pantulan (overshoot) dan perlambatan alami di akhir.</p>
<pre><code class="language-tsx">withSpring(sv.value, {
    stiffness: 900,
    damping: 120,
    mass: 4,
    overshootClamping: false,
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li><code>stiffness</code>: Kekuatan pegas (semakin besar = gerakan lebih cepat dan kuat) (default = 900)</li>
<li><code>damping</code>: Mengatur seberapa cepat gerakan melambat (semakin besar = lebih cepat berhenti) (default = 120)</li>
<li><code>mass</code>: Berat objek (semakin besar = gerakan lebih lambat) (default = 4)</li>
<li><code>overshootClamping</code>: Jika true, tidak akan memantul melewati target (default = false)</li>
</ul>
<p>Konfigurasi lainnya dari fungsi <code>withSpring</code> dapat dilihat pada <a href="https://docs.swmansion.com/react-native-reanimated/docs/animations/withSpring">laman resmi</a></p>
<h3 id="withdecay"><a class="header" href="#withdecay"><code>withDecay</code></a></h3>
<p>Digunakan untuk membuat animasi yang terus bergerak ke arah tertentu dengan kecepatan awal, lalu melambat hingga berhenti secara alami.</p>
<pre><code class="language-tsx">withDecay({
    velocity: event.velocityX,
    deceleration: 0.998,
    clamp: [-300, 300],
    velocityFactor: 1,
    rubberBandEffect: true,
    rubberBandFactor: 0.6,
    reduceMotion: ReduceMotion.System,
})
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li><code>velocity</code>: kecepatan awal gerakan (default = 0).</li>
<li><code>deceleration</code>: Nilai mendekati 1 membuat animasi melambat dengan lembut dan berjalan lebih lama, sedangkan nilai kecil (misal 0.95) membuat animasi cepat berhenti (default = 0.998).</li>
<li><code>clamp</code>: Batas minimum dan maksimum posisi. Ketika posisi hasil decay melewati nilai ini, maka animasi akan berhenti di batas tersebut. Contoh [-300, 300] artinya posisi hanya boleh di antara -300 hingga 300.</li>
<li><code>velocityFactor</code>: Faktor pengali untuk kecepatan awal (<code>velocity</code>). Gunanya untuk mengatur seberapa jauh atau seberapa cepat gerakan decay dimulai tanpa harus mengubah velocity langsung (default = 1).</li>
<li><code>rubberBandEffect</code>: menambahkan efek pantulan yang lembut seperti "karet" (default = false)</li>
<li><code>rubberBandFactor</code>: Mengatur seberapa kuat efek pantulan pada <code>rubberBandEffect</code>. Semakin kecil maka pantulan lebih kuat sedangkan semakin besar (lebih elastis) maka pantulan lebih kaku (cepat berhenti) (default = 0.6).</li>
</ul>
<h3 id="withsequence"><a class="header" href="#withsequence"><code>withSequence</code></a></h3>
<p>Digunakan untuk menjalankan beberapa animasi satu per satu (secara berurutan) bukan bersamaan. Umumnya digunakan bersama <code>withTiming()</code>, <code>withSpring()</code>, dan <code>withDecay()</code> untuk membentuk efek kompleks.</p>
<pre><code class="language-tsx">withSequence(animation1, animation2, animation3, ...)
</code></pre>
<p><em>Penjelasan</em>
Setiap <code>animation</code> bisa berupa <code>withTiming()</code>, <code>withSpring()</code>, <code>withDecay()</code> atau bahkan <code>withDelay()</code> jika ingin memiliki jeda waktu di antaranya.</p>
<pre><code class="language-tsx">translateX.value = withSequence(
  withTiming(100, { duration: 500 }),
  withTiming(-100, { duration: 500 }),
  withTiming(0, { duration: 500 })
);
</code></pre>
<h3 id="withrepeat"><a class="header" href="#withrepeat"><code>withRepeat</code></a></h3>
<p>Digunakan untuk menjalankan animasi secara berulang, baik dalam jumlah tertentu maupun tanpa batas (infinite loop). Biasanya digunakan untuk membuat animasi loading atau spinner.</p>
<pre><code class="language-tsx">withRepeat(animation, numberOfReps?, reverse?, callback?)
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li>animation: animasi yang akan diulang (biasanya menggunakan <code>withTiming</code> atau <code>withSpring</code>)</li>
<li>numberOfReps: jumlah pengulangan animasi. Gunakan -1 untuk infinite loop. (default = 2)</li>
<li>reverse: jika <code>true</code>, animasi akan membalik arah setiap kali mengulang. (default = <code>false</code>)</li>
<li>callback: fungsi yang dipanggil ketika animasi selesai (jika finite)</li>
</ul>
<pre><code class="language-tsx">withRepeat(
    withTiming(200, { duration: 1000 }),
    2,
    false,
    () =&gt; {},
    ReduceMotion.System,
)
</code></pre>
<h3 id="withdelay"><a class="header" href="#withdelay"><code>withDelay</code></a></h3>
<p>Digunakan untuk memberikan penundaan (delay) pada animasi sebelum dijalankan. Bisanya dipakai untuk menjalankan animasi yang berurutan atau bisa juga digunakan untuk memberi jeda antar efek.</p>
<pre><code class="language-tsx">withDelay(delay, animation)
</code></pre>
<p><em>Penjelasan</em></p>
<ul>
<li>delay: durasi penundaan dalam milidetik sebelum animasi dimulai</li>
<li>animation: animasi yang ingin dijalankan setelah delay (biasanya <code>withTiming</code>, <code>withSpring</code>, dll)</li>
</ul>
<pre><code class="language-tsx">opacity.value = withDelay(
    1000, // tunggu 1 detik
    withTiming(1, { duration: 1000 })
);
</code></pre>
<p>Konsep penting lainnya dari Reanimated dapat diakses pada <a href="https://docs.swmansion.com/react-native-reanimated">laman resmi</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
