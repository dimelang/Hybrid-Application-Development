<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hybrid Application Development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hybrid Application Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pendahuluan"><a class="header" href="#pendahuluan">Pendahuluan</a></h1>
<h2 id="apa-itu-react-native"><a class="header" href="#apa-itu-react-native">Apa itu React Native?</a></h2>
<p>React Native adalah <strong>framework open-source</strong> yang dikembangkan oleh <strong>Meta (Facebook)</strong> untuk membangun aplikasi mobile <strong>Android</strong> dan <strong>iOS</strong> menggunakan bahasa pemrograman <strong>JavaScript</strong> atau <strong>TypeScript</strong>.<br />
Dengan React Native, developer dapat menulis satu basis kode dan menjalankannya di berbagai platform tanpa harus menulis kode terpisah untuk Android (Java/Kotlin) dan iOS (Objective-C/Swift).</p>
<hr />
<h2 id="mengapa-react-native"><a class="header" href="#mengapa-react-native">Mengapa React Native?</a></h2>
<p>Beberapa alasan mengapa React Native populer di kalangan developer:</p>
<ol>
<li>
<p><strong>Cross-Platform</strong><br />
Satu kode bisa berjalan di Android dan iOS.</p>
</li>
<li>
<p><strong>Performance Lebih Baik dibanding Hybrid Webview</strong><br />
React Native menggunakan komponen native, bukan sekadar membungkus aplikasi web.</p>
</li>
<li>
<p><strong>Hot Reloading &amp; Fast Refresh</strong><br />
Mempercepat proses pengembangan karena perubahan kode bisa langsung dilihat tanpa build ulang penuh.</p>
</li>
<li>
<p><strong>Ekosistem &amp; Komunitas Besar</strong><br />
Banyak library, tutorial, dan komunitas aktif.</p>
</li>
<li>
<p><strong>Dukungan TypeScript</strong><br />
Menjadikan aplikasi lebih aman dan maintainable.</p>
</li>
</ol>
<hr />
<h2 id="arsitektur-dasar-react-native"><a class="header" href="#arsitektur-dasar-react-native">Arsitektur Dasar React Native</a></h2>
<p>Secara garis besar, arsitektur React Native terdiri dari:</p>
<ul>
<li><strong>JavaScript Layer</strong> → tempat kode aplikasi ditulis (JS/TS).</li>
<li><strong>Bridge</strong> → penghubung antara JavaScript dan kode native.</li>
<li><strong>Native Layer</strong> → komponen asli Android/iOS (misalnya <code>View</code>, <code>Text</code>, <code>Button</code>).</li>
</ul>
<hr />
<h2 id="perbedaan-react-native-dengan-framework-lain"><a class="header" href="#perbedaan-react-native-dengan-framework-lain">Perbedaan React Native dengan Framework Lain</a></h2>
<ul>
<li><strong>Flutter</strong> → menggunakan bahasa Dart dan rendering engine sendiri.</li>
<li><strong>Ionic / Cordova</strong> → berbasis WebView.</li>
<li><strong>React Native</strong> → menggunakan komponen asli (native component) sehingga performa lebih dekat ke aplikasi native.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-script-intro"><a class="header" href="#type-script-intro">Pengenalan TypeScript</a></h1>
<h2 id="apa-itu-typescript"><a class="header" href="#apa-itu-typescript">Apa itu TypeScript?</a></h2>
<p>TypeScript adalah superset dari JavaScript yang artinya seluruh kode JavaScript valid bisa dijalankan di TypeScript, tapi TypeScript menambahkan fitur baru, yang paling penting adalah static typing.</p>
<p>Dengan TypeScript, kita bisa menentukan tipe data untuk variabel, fungsi, maupun objek, sehingga kesalahan bisa dicegah sejak proses pengembangan (compile time), bukan saat aplikasi sudah berjalan (runtime).</p>
<h2 id="mengapa-typescript-dibutuhkan"><a class="header" href="#mengapa-typescript-dibutuhkan">Mengapa TypeScript Dibutuhkan?</a></h2>
<p>JavaScript sangat fleksibel (loosely typed), tapi justru karena itu sering menimbulkan bug yang sulit dilacak. Misalnya:</p>
<pre><code class="language-js">let age = 25;
age = "dua puluh lima"; // JavaScript tidak error
</code></pre>
<p>Kalau kode di atas berjalan di aplikasi besar, bisa menimbulkan error tidak terduga.
Dengan TypeScript:</p>
<pre><code class="language-ts">let age: number = 25;
age = "dua puluh lima"; // ❌ Error saat compile
</code></pre>
<p>Dengan demikian, menggunakan typescript, kesalahan dapat terdeteksi lebih awal.</p>
<h3 id="keunggulan-yang-dimiliki-oleh-typescript"><a class="header" href="#keunggulan-yang-dimiliki-oleh-typescript">Keunggulan yang dimiliki oleh TypeScript:</a></h3>
<ol>
<li><strong>Type safety</strong>, kode lebih aman karena ada pemeriksaan tipe.</li>
<li><strong>Autocompletion</strong>, beberap editor bisa memberi saran kode yang lebih akurat.</li>
<li><strong>Lebih mudah dipelihara</strong>, terutama di proyek besar dengan banyak developer.</li>
<li><strong>Mendukung fitur modern JavaScript</strong>, TypeScript selalu up-to-date dengan ECMAScript terbaru.</li>
<li><strong>Kompatibel dengan JavaScript</strong>, kode JS bisa langsung dipakai di TS.</li>
</ol>
<h2 id="instalasi"><a class="header" href="#instalasi">Instalasi</a></h2>
<p>Sebelum menggunakan TypeScript, pastikan di komputer teman-teman sudah menginstal <a href="https://nodejs.org/en/download">Node.js</a>. Untuk memastikan <strong>Node.js</strong> sudah berhasil diinstal, silahkan jalankan perintah berikut di dalam terminal/CMD.</p>
<pre><code>node -v
</code></pre>
<p>Hasilnya adalah versi dari <strong>Node.js</strong> yang diinstal. Selanjutnya, lakukan instalasi TypeScript melalui <em>npm</em>. Jalankan perintah berikut untuk menginstal TypeScript secara <em>global</em>.</p>
<pre><code>npm install -g typescript
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membuat-dan-menjalankan-program-typescript"><a class="header" href="#membuat-dan-menjalankan-program-typescript">Membuat dan Menjalankan Program TypeScript</a></h1>
<p>Sekarang mari buat file TypeScript pertama kita. TypeScript dapat ditulis dalam file <code>.ts</code> yang nantinya akan dikompilasi ke JavaScript lalu jalankan menggunakan <strong>Node.js</strong>.</p>
<h2 id="langkah-langkah"><a class="header" href="#langkah-langkah">Langkah-langkah</a></h2>
<ol>
<li>
<p>Buat file <code>hello.ts</code></p>
<pre><code class="language-ts">let word: string = "World";
console.log(`Hello, ${word}!`);
</code></pre>
</li>
<li>
<p>Kompilasi file <code>hello.ts</code> ke JavaScript menggunakan perintah berikut di terminal/CMD.</p>
<pre><code class="language-bash">tsc hello.ts
</code></pre>
<p>Nantinya, akan tercipta sebuah file baru yaitu <code>hello.js</code></p>
</li>
<li>
<p>Jalankan dengan Node.js menggunakan perintah termnial/CMD berikut</p>
<pre><code>node hello.js
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar"><a class="header" href="#konsep-typescript-1-tipe-data-dasar">Konsep TypeScript 1: Tipe Data Dasar</a></h1>
<p>Di JavaScript, kita bebas memberikan nilai apapun ke sebuah variabel. Ini tentunya sangat fleksibel, tapi berpotensi menyebabkan bug. Seperti yang telah dijelaskan <a href="./typescript.html">di awal</a>. TypeScript hadir dengan sistem tipe yang ketat: kita bisa mendefinisikan sejak awal bahwa variabel hanya boleh menyimpan data dengan tipe tertentu. Dengan cara ini, kesalahan dapat dideteksi lebih awal, bahkan sebelum program dijalankan. TypeScript memiliki beberapa tipe data dasar, yaitu</p>
<ol>
<li>
<p><strong>String</strong></p>
<p>Digunakan untuk menyimpan data string yang menggunakan <code>"</code> atau <code>'</code></p>
<pre><code class="language-ts">let word: string = "World";
let greeting: string = `Hello, ${word}!`;
</code></pre>
</li>
</ol>
<hr />
<ol start="2">
<li>
<p><strong>Number</strong></p>
<p>Digunakan untuk menyimpan data numerik seperti (integer, float/pecahan, heksadesimal, oktal)</p>
<pre><code class="language-ts">let age: number = 25;
let pi: number = 3.14;
let hex: number = 0xff;   // 255
let binary: number = 0b1010; // 10
let octal: number = 0o744; // 484
</code></pre>
</li>
</ol>
<hr />
<ol start="3">
<li><strong>Boolean</strong>
Digunakan untuk menyimpan data yang bernilai <code>true</code> atau <code>false</code>
<pre><code class="language-ts">let isActive: boolean = true;
let isAdmin: boolean = false;
</code></pre>
</li>
</ol>
<hr />
<ol start="4">
<li>
<p><strong>Null dan Undefined</strong></p>
<p><code>null</code> merupakan nilai kosong yang diberikan secara eksplisit. Akan dikonversi menjadi 0 dalam operasi aritmatika.
<code>undefined</code> merupakan nilai default ketika suatu variable belum diberi nilai. Akan menghasilkan NaN (Not a Number) dalam operasi aritmatika.</p>
<pre><code class="language-ts">let emptyValue: null = null;
let notAssigned: undefined = undefined;
</code></pre>
</li>
</ol>
<hr />
<p>Selain tipe data dasar di atas, TypeScript juga memiliki beberapa tipe data khusus seperti</p>
<ol>
<li>
<p><strong>Any</strong></p>
<p>Tipe data yang menonaktifkan pemeriksaan tipe sehingga memperbolehkan variable atau fungsi menerima dan menampung nilai dari tipe data apapun. Tapi ini menghilangkan manfaat TypeScript, jadi gunakan hanya jika perlu.</p>
<pre><code class="language-ts">let randomValue: any = 10;
randomValue = "Hello"; // tidak error
randomValue = true;    // tidak error
</code></pre>
</li>
<li>
<p><strong>Unknown</strong></p>
<p>Tipe data yang merepresentasikan nilai yang tipenya tidak diketahui atau tidak pasti pada saat kompilasi. Mirip <code>any</code>, tapi lebih aman. Kita harus cek tipe sebelum digunakan.</p>
<pre><code class="language-ts">let input: unknown = "Hello";
if (typeof input === "string") {
    console.log(input.toUpperCase()); // HELLO
}

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar-lanjutan"><a class="header" href="#konsep-typescript-1-tipe-data-dasar-lanjutan">Konsep TypeScript 1: Tipe Data Dasar Lanjutan</a></h1>
<ol>
<li>
<p><strong>Array</strong></p>
<p>TypeScript juga memiliki beberapa struktur data yang juga terdapat dalam JavaScript. Array digunakan untuk menyimpan sekumpulan nilai dengan urutan tertentu. Bedanya, di TypeScript kita bisa menentukan tipe data yang boleh ada di dalam array. Hal ini membuat array kita lebih konsisten, karena semua elemennya punya tipe yang sama."</p>
<pre><code class="language-ts">let numbers: number[] = [1, 2, 3, 4];
let names: string[] = ["Ani", "Budi", "Citra"];
</code></pre>
<p>Atau dengan generics</p>
<pre><code class="language-ts">let scores: Array&lt;number&gt; = [90, 80, 100];
</code></pre>
</li>
<li>
<p><strong>Tuple</strong></p>
<p>Jenis struktur data seperti array yang memiliki panjang tetap dan tipe data yang ditentukan untuk setiap posisinya. Ini berbeda dari array biasa karena tuple menjamin jumlah elemen dan urutan tipenya. Tuple cocok digunakan untuk merepresentasikan kumpulan nilai yang terstruktur, seperti koordinat (x, y) atau nilai RGB (merah, hijau, biru), di mana setiap posisi memiliki arti yang jelas</p>
<pre><code class="language-ts">let person: [string, number] = ["Alice", 25]; // Di sini, elemen pertama wajib diisi dengan string dan elemen kedua adalah numerik
console.log(person[0]); // Alice
console.log(person[1]); // 25
</code></pre>
</li>
<li>
<p><strong>Enum</strong></p>
<p>Sekumpulan nilai konstan yang lebih mudah dibaca. Pada TypeScript <code>Enum</code> disediakan dalam bentuk numeric dan string atau bahkan keduanya. Untuk mendefiniskan <code>Enum</code> kita menggunakan keyword <code>enum</code>.</p>
<pre><code class="language-ts">enum NameOfEnum {
   member: constantValue // constantValue is optional
}
</code></pre>
<p><strong>Numeric Enums</strong>
Artinya adalah kita melakukan inisiasi pada member dengan tipe data Number.</p>
<pre><code class="language-ts">enum Direction {
    Up=1,
    Down,
    Left,
    Right
}

let move_up: Direction = Direction.Up;
let move_down: Direction = Direction.Down;
let move_left: Direction = Direction.Left;
let move_right: Direction = Direction.Right;

console.log(move_up); // 1
console.log(move_down); // 2
console.log(move_left); // 3
console.log(move_right); // 4
</code></pre>
<p>Enum pada TypeScript menganut sistem Auto Incerement dari setelah member yand diberi inisiasi</p>
<p><strong>String Enums</strong>
Pada dasarnya sama dengan Numeric Enums hanya saja perbedaanya adalah ketika kita assign pada member tipenya adalah String. Dan satu hal lagi tidak ada konsep Auto Increment pada String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up="UP",
    Down="DOWN",
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
<p><strong>Heterogeneous Enums</strong>
Enum jenis ini adalah gabungan dari Numeric Enums dan String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up=0,
    Down=1,
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
</li>
<li>
<p><strong>Union</strong>
Fitur yang memungkinkan sebuah variabel memiliki salah satu dari beberapa tipe data yang berbeda atau lebih sederhananya bisa menyimpan lebih dari satu tipe.</p>
<pre><code class="language-ts">let id: string | number;
id = "ABC123"; // ✅
id = 101;      // ✅
id = true;     // ❌ Error

</code></pre>
</li>
<li>
<p><strong>Literal</strong>
Variable yang membatasi nilai hanya ke konstanta tertentu.</p>
<pre><code class="language-ts">let direction: "up" | "down";
direction = "up";   // ✅
direction = "down"; // ✅
direction = "left"; // ❌ Error

</code></pre>
</li>
</ol>
<p>Sebenarnya, TypeScript memiliki mekanisme untuk menentukan tipe data dari suatu variable berdasarkan nilainya (type inference).</p>
<pre><code class="language-ts">let city = "Semarang"; // otomatis string
city = 123; // ❌ Error
</code></pre>
<p>Jika deklarasi tanpa nilai</p>
<pre><code class="language-ts">let data; // otomatis any
data = "Hello";
data = 123;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-2-function--parameter"><a class="header" href="#konsep-typescript-2-function--parameter">Konsep TypeScript 2: Function &amp; Parameter</a></h1>
<p>Dalam JavaScript, function bisa menerima argumen apa saja dan mengembalikan apapun. Ini tentunya sangat fleksibel, tapi rawan error. Dengan TypeScript, kita bisa menentukan tipe parameter dan tipe return value, sehingga function lebih jelas dan aman.</p>
<p>Contoh JavaScript:</p>
<pre><code class="language-js">function add(a, b) {
  return a + b;
}

console.log(add(10, "20")); // "1020" → salah paham jadi string
</code></pre>
<p>Contoh TypeScript</p>
<pre><code class="language-ts">function add(a: number, b: number): number {
  return a + b;
}

console.log(add(10, 20)); // 30
console.log(add(10, "20")); // ❌ Error

</code></pre>
<pre><code class="language-ts">function full_name(first_name: string, last_name: string): string {
  return first_name + last_name;
}

console.log(full_name("Georgy", "Adelson")); // Georgy Adelson
console.log(full_name("Georgy", 62)); // ❌ Error

</code></pre>
<p>Jika function tidak mengembalikan nilai, gunakan <code>void</code> sebagai return type</p>
<pre><code class="language-ts">function logMessage(message: string): void {
  console.log(message);
}
</code></pre>
<h2 id="optional-parameter-"><a class="header" href="#optional-parameter-">Optional Parameter (?)</a></h2>
<p>Parameter dalam TypeScript dapat dibuat opsional dengan tanda <code>?</code>, sehingga boleh tidak diisi.</p>
<pre><code class="language-ts">function sayHello(name?: string): string {
    return name ? `Hello, ${name}` : "Hello, stranger!";
}

console.log(sayHello("Georgy")); // Hello, Georgy
console.log(sayHello());        // Hello, stranger!
</code></pre>
<h2 id="deafult-parameter"><a class="header" href="#deafult-parameter">Deafult Parameter</a></h2>
<p>Kita juga dapat memberi nilai default pada parameter.</p>
<pre><code class="language-ts">function greetUser(name: string = "Guest"): string {
  return `Welcome, ${name}!`;
}

console.log(greetUser());       // Welcome, Guest!
console.log(greetUser("Georgy"));  // Welcome, Ani!
</code></pre>
<h2 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h2>
<p>Jika jumlah parameter tidak menentu, kita dapat menggunakan <code>...</code></p>
<pre><code class="language-ts">function sumAll(...numbers: number[]): number {
  return numbers.reduce((acc, curr) =&gt; acc + curr, 0);
}

console.log(sumAll(1, 2, 3, 4, 5)); // 15
</code></pre>
<h2 id="function-expression"><a class="header" href="#function-expression">Function Expression</a></h2>
<p>Selain deklarasi biasa, kita juga bisa menuliskan function sebagai ekspresi</p>
<pre><code class="language-ts">const multiply = function (a: number, b: number): number {
  return a * b;
};
</code></pre>
<h2 id="arrow-function-"><a class="header" href="#arrow-function-">Arrow Function (=&gt;)</a></h2>
<p>Arrow function disediakan untuk meringkas penulisa sebuah function sederhana</p>
<pre><code class="language-ts">const divide = (a: number, b: number): number =&gt; a / b;

console.log(divide(10, 2)); // 5
</code></pre>
<h2 id="overloading-function"><a class="header" href="#overloading-function">Overloading Function</a></h2>
<p>TypeScript mendukung overloading yaitu function dengan bentuk parameter berbeda tapi memiliki nama yang sama</p>
<pre><code class="language-ts">function combine(a: string, b: string): string;
function combine(a: number, b: number): number;
function combine(a: any, b: any): any {
  return a + b;
}

console.log(combine(10, 20));     // 30
console.log(combine("Hello, ", "World")); // Hello, World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-3-object--interface"><a class="header" href="#konsep-typescript-3-object--interface">Konsep TypeScript 3: Object &amp; Interface</a></h1>
<h2 id="objek"><a class="header" href="#objek">Objek</a></h2>
<p>Dalam JavaScript, objek adalah kumpulan properti yang menyimpan berbagai data. Pada TypeScript, kita bisa menentukan tipe properti dalam sebuah objek sehingga lebih jelas struktur datanya.</p>
<p>Contoh sederhana:</p>
<pre><code class="language-ts">let user: { name: string; age: number; isAdmin: boolean } = {
  name: "Max",
  age: 25,
  isAdmin: true
};

console.log(user.name); // Max
</code></pre>
<p>Pastikan ketika memberikan nilai untuk setiap properti sudah sesuai dengan tipe data yang didefinisikan.</p>
<p>Selain pada function, operator optional <code>?</code> juga dapat digunakan pada objek.</p>
<pre><code class="language-ts">let product: { id: number; name: string; description?: string } = {
  id: 101,
  name: "Laptop"
};

console.log(product.description); // undefined
</code></pre>
<h4 id="readonly-property"><a class="header" href="#readonly-property">Readonly Property</a></h4>
<p>Dalam TypeScript, properti dapat dibuat tidak bisa diubah. Caranya adalah menambahkan syntax <code>readonly</code> sebelum nama properti.</p>
<pre><code class="language-ts">let car: { readonly band: string; year: number } = {
  brand: "Dream Theater",
  year: 1985
};

car.year = 1968;     // ✅ Bisa diubah
car.brand = "Led Zeppelin"; // ❌ Error
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Interface adalah cara mendefinisikan bentuk dari sebuah objek dengan lebih rapi dan bisa digunakan berulang kali. Kalau tadi kita mendefinisikan tipe objek langsung di variabel, sekarang kita bisa memisahkan definisinya agar lebih mudah dibaca.</p>
<p>Contoh interface sederhana</p>
<pre><code class="language-ts">interface User {
  name: string;
  age: number;
  isAdmin: boolean;
}

let admin: User = {
  name: "Ani",
  age: 30,
  isAdmin: true
};
</code></pre>
<p>Fitur opsional <code>?</code> dan <code>readonly</code> juga dapat diterapkan pada interface.</p>
<pre><code class="language-ts">interface Product {
  readonly id: number;
  name: string;
  description?: string;
}

let item: Product = {
  id: 123,
  name: "Smartphone"
};

item.name = "Tablet";   // ✅
item.id = 456;          // ❌ Error
</code></pre>
<p>Selain menggunakan properti dengan nilai tunggal, properti pada interface juga bisa mendefinisikan bentuk function.</p>
<pre><code class="language-ts">interface Person {
  name: string;
  greet(): void;
}

let user1: Person = {
  name: "John",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

user1.greet(); // Hello, my name is John
</code></pre>
<p>Interface juga bisa mewarisi (extend) sifat ke interface lainnya.</p>
<pre><code class="language-ts">interface Animal {
  name: string;
  sound(): void;
}

interface Dog extends Animal {
  breed: string;
}

let myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
  sound() {
    console.log("Woof woof!");
  }
};

myDog.sound(); // Woof woof!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-4-union--intersection"><a class="header" href="#konsep-typescript-4-union--intersection">Konsep TypeScript 4: Union &amp; Intersection</a></h1>
<p>Dalam pemrograman nyata, kadang sebuah variabel bisa menampung lebih dari satu tipe data. Misalnya, ID user bisa berupa number atau string.</p>
<h2 id="union-types-"><a class="header" href="#union-types-">Union Types (<code>|</code>)</a></h2>
<p>Union <code>|</code> berarti salah satu dari beberapa tipe.
Contoh sederhana</p>
<pre><code class="language-ts">let userId: number | string;

userId = 101;       // ✅ number
userId = "A102";    // ✅ string
userId = true;      // ❌ Error: Type 'boolean' is not assignable
</code></pre>
<p>Selain digunakan dalam variable, union (<code>|</code>) juga dapat digunakan pada function
contoh union pada function</p>
<pre><code class="language-ts">function printId(id: number | string) {
  console.log("User ID:", id);
}

printId(123);     // ✅
printId("ABC");   // ✅
</code></pre>
<p>Union sangat berguna ketika kita berhadapan dengan data yang fleksibel tapi masih terkontrol. Namun, ketika menggunakan union, kita harus hati-hati. TypeScript memaksa kita untuk memastikan operasi yang dilakukan valid untuk semua tipe dalam union.</p>
<h3 id="narrowing-mempersempit-union"><a class="header" href="#narrowing-mempersempit-union">Narrowing (Mempersempit Union)</a></h3>
<p>Ketika menggunakan union, kita sering perlu memeriksa tipe data sebelum mengaksesnya. Proses ini disebut type narrowing.</p>
<p>Contoh narrowing sederhana:</p>
<pre><code class="language-ts">function formatId(id: number | string) {
  if (typeof id === "string") {
    return id.toUpperCase(); // ✅ aman karena pasti string
  } else {
    return id.toFixed(2);    // ✅ aman karena pasti number
  }
}

console.log(formatId(123));     // "123.00"
console.log(formatId("abc"));   // "ABC"
</code></pre>
<h2 id="intersection-"><a class="header" href="#intersection-">Intersection (<code>&amp;</code>)</a></h2>
<p>Fitur yang memungkinkan kita untuk menggabungkan beberapa tipe data menjadi satu tipe baru yang memiliki semua properti dan anggota dari setiap tipe yang digabungkan. Fitur ini sangat berguna untuk membuat tipe yang kompleks dari tipe-tipe yang lebih sederhana, di mana objek yang menggunakan tipe interseksi ini harus memenuhi semua persyaratan dari setiap tipe yang termasuk di dalamnya.
Contoh sederhana:</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Employee {
  company: string;
}

interface Worker = Person &amp; Employee;

let staff: Worker = {
  name: "Max",
  company: "Microsoft"
};
</code></pre>
<p><code>Worker</code> adalah seseorang yang sekaligus seorang karyawan, sehingga harus punya properti dari <code>Person</code> dan <code>Employee</code></p>
<p>Selain pada interface, kita juga dapat menggunakan intersection pada tipe data dasar.</p>
<pre><code class="language-ts">type A = { x: number };
type B = { y: string };

type AB = A &amp; B;

let obj: AB = { x: 10, y: "hello" }; // ✅ harus punya keduanya
</code></pre>
<pre><code class="language-ts">type C = { id: number };
type D = { id: string };

type CD = C &amp; D; // ❌ Tidak mungkin, karena 'id' tidak bisa number sekaligus string
</code></pre>
<h2 id="menggabungkan-union--intersection"><a class="header" href="#menggabungkan-union--intersection">Menggabungkan Union &amp; Intersection</a></h2>
<p>Terkadang, kita perlu mengombinasikan union dan intersection untuk membentuk tipe yang lebih kompleks. Teknik ini sering digunakan dalam aplikasi nyata, misalnya ketika mendesain model data yang fleksibel.</p>
<pre><code class="language-ts">interface Admin {
  role: "admin";
  accessLevel: number;
}

interface User {
  role: "user";
  email: string;
}

interface Account = (Admin | User) &amp; { id: number };

let acc1: Account = {
  id: 1,
  role: "admin",
  accessLevel: 5
};

let acc2: Account = {
  id: 2,
  role: "user",
  email: "test@mail.com"
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-5-generics"><a class="header" href="#konsep-typescript-5-generics">Konsep TypeScript 5: Generics</a></h1>
<p>Sebelumnya kita sudah membahas Union &amp; Intersection yang memberi fleksibilitas pada tipe. Terkadang terdapat sebuah kondisi yang membuat kita untuk membuat fungsi atau class yang bisa bekerja dengan banyak tipe tanpa kehilangan informasi tipe aslinya. Walaupun TypeScript memiliki operator <code>any</code>, namun hal ini akan membuat kebingungan karena kehilangan identitas. Di sinilah Generics sangat berguna. Generics memungkinkan kita menulis kode yang dapat digunakan kembali untuk berbagai tipe, tapi tetap memberikan jaminan tipe yang kuat.</p>
<h2 id="generics-pada-function"><a class="header" href="#generics-pada-function">Generics pada Function</a></h2>
<p>Dengan generics, kita bisa membuat fungsi yang menerima parameter dengan tipe yang bisa berubah-ubah.</p>
<p>Tanpa generics:</p>
<pre><code class="language-ts">function identity(arg: any): any {
  return arg;
}

let a = identity(5);      // a: any
let b = identity("Hello"); // b: any
</code></pre>
<p>Masalah: hasilnya selalu any, sehingga kita kehilangan informasi tipe.</p>
<p>Dengan generics:</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  return arg;
}

let num = identity&lt;number&gt;(10);   // num: number
let str = identity("Halo");       // str: string (infer otomatis)
</code></pre>
<p>Dengan generics, kita mendefinisikan tipe sebagai parameter <code>&lt;T&gt;</code>. Hasilnya, TypeScript tahu bahwa input dan output punya tipe yang sama.</p>
<h2 id="penamaan-parameter-generics"><a class="header" href="#penamaan-parameter-generics">Penamaan Parameter Generics</a></h2>
<p>Kalau diperhatikan, kenapa kita sering melihat <T>, <K>, <V> di kode TypeScript?
Sebenarnya itu hanyalah nama variabel tipe, sama seperti kita memberi nama variabel biasa.
Namun, ada konvensi umum agar lebih mudah dibaca.</p>
<div class="table-wrapper"><table><thead><tr><th>Nama</th><th>Makna Umum</th><th>Contoh Penggunaan</th></tr></thead><tbody>
<tr><td><code>T</code></td><td>Type (umum)</td><td><code>identity&lt;T&gt;(arg: T): T</code></td></tr>
<tr><td><code>U</code>,<code>S</code></td><td>Type tambahan / second</td><td><code>pair&lt;T, U&gt;(a: T, b: U)</code></td></tr>
<tr><td><code>K</code></td><td>Key dari sebuah object</td><td><code>getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K)</code></td></tr>
<tr><td><code>V</code></td><td>Value dari sebuah object</td><td><code>Record&lt;K, V&gt; (objek dengan key K dan value V)</code></td></tr>
</tbody></table>
</div>
<p>Kita bisa pakai nama lain (<code>&lt;MyType&gt;</code>, <code>&lt;Foo&gt;</code>), tapi <code>&lt;T&gt;</code>, <code>&lt;K&gt;</code>, <code>&lt;V&gt;</code> sudah jadi kebiasaan.</p>
<p>Contoh:</p>
<pre><code class="language-ts">function pair&lt;K, V&gt;(key: K, value: V): [K, V] {
  return [key, value];
}

let result = pair("id", 101); 
// result: [string, number]
</code></pre>
<p><strong>Generics pada function expression/arrow function:</strong></p>
<pre><code class="language-ts">const getFirstElement = &lt;T&gt;(arr: T[]): T =&gt; {
  return arr[0];
};

let numbers = [1, 2, 3];
let first = getFirstElement(numbers); // first: number

let names = ["Ani", "Budi", "Cici"];
let firstName = getFirstElement(names); // firstName: string
</code></pre>
<p><strong>Generics dengan multi parameter:</strong></p>
<pre><code class="language-ts">function merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {
  return { ...obj1, ...obj2 };
}

let person = merge({ name: "Max" }, { age: 25 });
console.log(person); // { name: "Max", age: 25 }
</code></pre>
<p>**Constraint pada Generics</p>
<p>Kadang kita ingin membatasi tipe generics agar hanya tipe tertentu yang bisa digunakan.
Gunakan <code>extends</code>.</p>
<pre><code class="language-ts">function getLength&lt;T extends { length: number }&gt;(arg: T): number {
  return arg.length;
}

console.log(getLength("Hello"));    // ✅ string punya length
console.log(getLength([1, 2, 3]));  // ✅ array punya length
// console.log(getLength(123));     // ❌ number tidak punya length
</code></pre>
<h2 id="interface-dengan-generics"><a class="header" href="#interface-dengan-generics">Interface dengan Generics</a></h2>
<p>Generics juga bisa digunakan dalam interface.</p>
<pre><code class="language-ts">interface Repository&lt;T&gt; {
  data: T[];
  add(item: T): void;
  getAll(): T[];
}

class MemoryRepository&lt;T&gt; implements Repository&lt;T&gt; {
  data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

let userRepo = new MemoryRepository&lt;string&gt;();
userRepo.add("Jordan");
userRepo.add("Ani");
console.log(userRepo.getAll()); // ["Jordan", "Ani"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class--oop-dasar"><a class="header" href="#class--oop-dasar">Class &amp; OOP Dasar</a></h1>
<p>JavaScript sudah mengenalkan konsep class sejak ES6. Di TypeScript, class mendapatkan kekuatan tambahan berupa static typing, access modifier, dan interface/class inheritance. Dengan class, kita bisa membuat blueprint untuk objek, sehingga kode lebih terstruktur dan mudah dikelola.</p>
<h3 id="membuat-class-dasar"><a class="header" href="#membuat-class-dasar">Membuat Class Dasar</a></h3>
<p>Class adalah cetak biru (blueprint) untuk membuat objek.</p>
<pre><code class="language-ts">class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Halo, nama saya ${this.name} dan saya berusia ${this.age} tahun.`);
  }
}

let user = new Person("Ryo", 35);
user.greet();
// Output: Halo, nama saya Ryo dan saya berusia 35 tahun.
</code></pre>
<p>Contoh di atas, kita membuat class Person dengan properti name dan age. Constructor digunakan untuk menginisialisasi properti, dan method greet menampilkan data. Dengan ini, kita bisa membuat banyak objek Person tanpa menulis ulang struktur yang sama.</p>
<h3 id="access-modifier"><a class="header" href="#access-modifier">Access Modifier</a></h3>
<p>TypeScript menambahkan access modifier untuk mengatur visibilitas properti dan method.</p>
<pre><code class="language-ts">class Car {
  public brand: string;       // Bisa diakses dari mana saja
  private engineNumber: string; // Hanya bisa diakses dari dalam class
  protected year: number;     // Bisa diakses oleh class ini &amp; turunannya

  constructor(brand: string, engineNumber: string, year: number) {
    this.brand = brand;
    this.engineNumber = engineNumber;
    this.year = year;
  }

  getInfo() {
    return `${this.brand} (${this.year})`;
  }
}

let car = new Car("Toyota", "EN12345", 2020);
console.log(car.brand);          // ✅ Toyota
// console.log(car.engineNumber); // ❌ Error: private
</code></pre>
<ul>
<li><code>public</code>: default, bisa diakses dari mana saja.</li>
<li><code>private</code>: hanya bisa diakses di dalam class itu sendiri.</li>
<li><code>protected</code>: bisa diakses dari class dan subclass (turunan).</li>
</ul>
<h3 id="getter--setter"><a class="header" href="#getter--setter">Getter &amp; Setter</a></h3>
<p>Kita bisa membuat method khusus untuk mengambil dan mengubah nilai dengan kontrol lebih.</p>
<pre><code class="language-ts">class Account {
  private _balance: number = 0;

  get balance(): number {
    return this._balance;
  }

  set balance(amount: number) {
    if (amount &lt; 0) throw new Error("Balance tidak boleh negatif");
    this._balance = amount;
  }
}

let acc = new Account();
acc.balance = 1000;        // Setter
console.log(acc.balance);  // Getter -&gt; 1000
</code></pre>
<p>Getter &amp; Setter memberi kontrol penuh atas cara data diakses dan dimodifikasi.
Misalnya, kita bisa menolak nilai negatif untuk <code>balance</code>.</p>
<h3 id="inheritance-pewarisan"><a class="header" href="#inheritance-pewarisan">Inheritance (Pewarisan)</a></h3>
<p>Class bisa mewarisi dari class lain dengan <code>extends</code>.</p>
<pre><code class="language-ts">class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move() {
    console.log(`${this.name} bergerak.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} menggonggong.`);
  }
}

let dog = new Dog("Buddy");
dog.move();  // Buddy bergerak.
dog.bark();  // Buddy menggonggong.
</code></pre>
<p>Dengan inheritance, kita bisa membuat class baru yang mewarisi properti dan method dari class lain.
Ini memungkinkan reuse kode dan membuat struktur hierarki yang lebih natural.</p>
<h3 id="method-overriding"><a class="header" href="#method-overriding">Method Overriding</a></h3>
<p>Subclass bisa menimpa (override) method dari superclass.</p>
<pre><code class="language-ts">class Bird extends Animal {
  move() {
    console.log(`${this.name} terbang.`);
  }
}

let bird = new Bird("Garuda");
bird.move(); // Garuda terbang.
</code></pre>
<h3 id="abstract-class"><a class="header" href="#abstract-class">Abstract Class</a></h3>
<p>Abstract class tidak bisa dibuat instance langsung. Biasanya digunakan sebagai blueprint untuk class lain. Abstract class seperti kontrak: class turunan wajib mengimplementasikan method yang abstrak.</p>
<pre><code class="language-ts">abstract class Shape {
  abstract area(): number;
}

class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super();
  }

  area(): number {
    return this.width * this.height;
  }
}

let rect = new Rectangle(10, 5);
console.log(rect.area()); // 50
</code></pre>
<h3 id="static-member"><a class="header" href="#static-member">Static Member</a></h3>
<p>Kita bisa membuat properti dan method yang dimiliki oleh class itu sendiri, bukan oleh objeknya.</p>
<pre><code class="language-ts">class MathUtil {
  static PI: number = 3.14159;

  static circleArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtil.PI);               // 3.14159
console.log(MathUtil.circleArea(10));   // 314.159
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module--importexport"><a class="header" href="#module--importexport">Module &amp; Import/Export</a></h1>
<p>Di JavaScript (sejak ES6) dan TypeScript, modul digunakan untuk membagi kode ke dalam file-file terpisah sehingga kode lebih mudah dibaca &amp; dikelola dan bisa dipakai ulang di file lain.</p>
<h3 id="export"><a class="header" href="#export">Export</a></h3>
<p>Sebuah file TypeScript dianggap sebagai modul ketika memiliki <code>export</code> atau <code>import</code>.</p>
<p>Contoh:</p>
<p><code>mathUtils.ts</code></p>
<pre><code class="language-ts">// export variabel
export const PI = 3.14159;

// export fungsi
export function add(a: number, b: number): number {
  return a + b;
}

// export class
export class Calculator {
  multiply(x: number, y: number): number {
    return x * y;
  }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Kita bisa mengimpor apa yang diekspor dari file lain.</p>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { PI, add, Calculator } from "./mathUtils";

console.log(PI); // 3.14159
console.log(add(10, 5)); // 15

const calc = new Calculator();
console.log(calc.multiply(4, 3)); // 12
</code></pre>
<p>Dengan kurung kurawal <code>{}</code> kita bisa mengambil item-item spesifik dari modul. TypeScript memastikan hanya yang diekspor yang bisa diimpor.</p>
<h3 id="export-default"><a class="header" href="#export-default">Export Default</a></h3>
<p>Kadang sebuah modul hanya punya satu hal utama. Untuk kasus ini kita bisa pakai default export.
Contoh:</p>
<p>logger.ts</p>
<pre><code class="language-ts">export default function log(message: string): void {
  console.log("[LOG]:", message);
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import log from "./logger";

log("Halo dari default export!");
</code></pre>
<h3 id="alias-import--export"><a class="header" href="#alias-import--export">Alias Import &amp; Export</a></h3>
<p>Kita bisa mengganti nama saat export atau import menggunakan <code>as</code>. Alias sering dipakai untuk menghindari konflik nama atau membuat kode lebih singkat.</p>
<p><code>shapes.ts</code></p>
<pre><code class="language-ts">export function areaRectangle(w: number, h: number): number {
  return w * h;
}

export function areaCircle(r: number): number {
  return Math.PI * r * r;
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { areaRectangle as rect, areaCircle as circle } from "./shapes";

console.log(rect(10, 5)); // 50
console.log(circle(7));   // 153.938...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment"><a class="header" href="#setup-environment">Setup Environment</a></h1>
<p>Sebelum mulai membuat aplikasi React Native, kita perlu menyiapkan <strong>environment</strong> terlebih dahulu.<br />
Ada dua cara utama untuk menjalankan React Native:</p>
<ol>
<li><a href="./react-native-cli.html"><strong>React Native CLI</strong></a> → lebih fleksibel, cocok untuk aplikasi production dengan native module.</li>
<li><a href="./expo-go.html"><strong>Expo Go</strong></a> → lebih mudah, cocok untuk belajar dan prototyping.</li>
</ol>
<h2 id="1-prasyarat"><a class="header" href="#1-prasyarat">1. Prasyarat</a></h2>
<h3 id="nodejs--package-manager"><a class="header" href="#nodejs--package-manager">Node.js &amp; Package Manager</a></h3>
<p>React Native membutuhkan <strong>Node.js</strong>. Disarankan menggunakan versi <strong>LTS</strong>.<br />
Unduh di <a href="https://nodejs.org/">nodejs.org</a>.</p>
<p>Cek instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<p>Opsional: gunakan Yarn atau pnpm sebagai pengganti npm.</p>
<pre><code class="language-bash">npm install -g yarn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli"><a class="header" href="#react-native-cli">React Native CLI</a></h1>
<p>Untuk menggunakan <strong>React Native CLI</strong>, kita perlu menyiapkan lingkungan pengembangan (development environment).</p>
<p>Karena React Native berjalan di Android dan iOS, maka langkah setup dibedakan berdasarkan sistem operasi target:</p>
<ul>
<li><a href="./react-native-cli-android.html">Setup Android</a></li>
<li><a href="./react-native-cli-ios.html">Setup iOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--android"><a class="header" href="#setup-environment-react-native-cli--android">Setup Environment React Native CLI – Android</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<ol>
<li>Install Node.js dan Java
<ul>
<li>Unduh <strong>Node.js</strong> (versi LTS) dari <a href="https://nodejs.org/">nodejs.org</a>.</li>
<li>Install <strong>Java JDK</strong> (disarankan versi 11 atau lebih baru).</li>
</ul>
</li>
</ol>
<p>Cek instalasi java:</p>
<pre><code class="language-bash">node -v
java -version
</code></pre>
<ol start="2">
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Konfigurasi ANDROID_HOME environment variable</p>
<ul>
<li>Buka <strong>Window Control Panel</strong></li>
<li>Klik <strong>User Accounts</strong>, lalu pilih <strong>Change my environment variables</strong></li>
<li>Klik <strong>New...</strong> untuk membuat user variable baru. Masukkan Variable name <strong>ANDROID_HOME</strong> dan Variable value <strong>Lokasi SDK Android</strong></li>
</ul>
<p><img src="./assets/env%20variable%20windows.png" alt="Ilustrasi menambahkan environment variable" title="Ilustrasi menambahkan environment variable" /></p>
<p>Untuk menemukan lokasi SDK dapat dilakukan melalui <strong>Android Studio</strong>. Pilih <strong>Settings</strong> → <strong>Languages &amp; Frameworks</strong> → <strong>Android SDK</strong></p>
</li>
<li>
<p>Menjalankan Emulator Android</p>
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>
<p>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>
<p>Install JDK menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a></p>
<pre><code class="language-bash">brew install --cask zulu@17
brew info --cask zulu@17
open /opt/homebrew/Caskroom/zulu@17/&lt;version number&gt;
</code></pre>
<p>Setelah Finder terbuka, Klik double untuk menginstal Azul Zulu JDK 17.pkg.</p>
<p>Tambahkan atau update JAVA_HOME environment variable di ~/.zshrc (or in ~/.bash_profile).</p>
<p>JDK umunya berada di /Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home. Lalu jalankan command berikut pada terminal</p>
<pre><code class="language-bash">export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
</code></pre>
</li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
</li>
</ol>
<ul>
<li>
<p>Unduh <a href="developer.android.com/studio">Android Studio</a></p>
</li>
<li>
<p>Saat instalasi, pastikan mencentang:</p>
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
<li>
<p>Setelah instalasi, buka Android Studio → SDK Manager → install:</p>
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install <a href="https://nodejs.org/en/download"><strong>Node</strong></a></li>
<li>Install <a href="https://openjdk.org/"><strong>JDK</strong></a></li>
</ul>
</li>
<li>
<p>Install Android Studio</p>
<ul>
<li>Unduh <a href="developer.android.com/studio">Android Studio</a></li>
<li>Saat instalasi, pastikan mencentang:
<ul>
<li>Android SDK</li>
<li>Android SDK Platform</li>
<li>Android Virtual Device (AVD)</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>Setelah instalasi, buka Android Studio → SDK Manager → install:
<ul>
<li>Android SDK Platform 33 atau terbaru</li>
<li>Google APIs Intel x86 Atom System Image</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Konfigurasi ANDROID_HOME environment variable
<ul>
<li>Jalankan command terminal berikut
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Android/Sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
</li>
</ul>
</li>
<li>Menjalankan Emulator Android
<ul>
<li>Buka Android Studio → AVD Manager → buat emulator baru (jika belum membuat emulator).</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native-cli--ios"><a class="header" href="#setup-environment-react-native-cli--ios">Setup Environment React Native CLI – iOS</a></h1>
<p>Setup React Native CLI untuk target Android akan dipisahkan ke dalam beberapa jenis Sistem Operasi:</p>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<ol>
<li>
<p>Install Node.js dan Java</p>
<ul>
<li>Install Node dan Watchman menggunakan <a href="https://brew.sh/"><strong>Homebrew</strong></a>
<pre><code class="language-bash">brew install node
brew install watchman
</code></pre>
</li>
<li>Install <a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12"><strong>Xcode</strong></a></li>
<li>Install Xcode Command Line Tools
Buka Xcode lalu pilih <strong>Settings... (atau Preferences...)</strong> pada menu Xcode.
Pilih panel <strong>Locations</strong> lalu pilih versi Command line tools terbaru
<img src="./assets/install%20command%20line%20tools.png" alt="Ilustrasi install command line tool Xcode" title="Ilustrasi install command line tool Xcode" /></li>
</ul>
</li>
<li>
<p>Install iOS simulator</p>
<ul>
<li>Buka Xcode → Settings... → tab Platforms.</li>
<li>Pilih "+" dan pilih opsi iOS…</li>
<li>Jalankan emulator</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-environment-react-native--expo"><a class="header" href="#setup-environment-react-native--expo">Setup Environment React Native – Expo</a></h1>
<p>Expo adalah framework dan platform untuk React Native yang memudahkan pengembangan aplikasi mobile tanpa perlu konfigurasi native (Android Studio / Xcode).<br />
Dengan Expo, kita bisa langsung membuat aplikasi, menjalankan di perangkat fisik dengan <strong>Expo Go</strong>, atau di emulator.</p>
<hr />
<h2 id="1-install-nodejs"><a class="header" href="#1-install-nodejs">1. Install Node.js</a></h2>
<p>Unduh <strong>Node.js LTS</strong> dari <a href="https://nodejs.org/">nodejs.org</a>.<br />
Verifikasi instalasi:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<h2 id="2-install-expo-go"><a class="header" href="#2-install-expo-go">2. Install Expo Go</a></h2>
<p>Unduh aplikasi Expo Go di <a href="https://apps.apple.com/us/app/expo-go/id982107779">App Store</a> atau <a href="https://play.google.com/store/apps/details?id=host.exp.exponent&amp;referrer=www">Google Play</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-native-cli-1"><a class="header" href="#react-native-cli-1">React Native CLI</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan React Native CLI.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx @react-native-community/cli@latest init MyFirstApp
</code></pre>
<p>Jika sebelumnya sudah pernah menginstal react-native-cli secara global, jalankan command terminal berikut unutk mencegah kesalahan</p>
<pre><code class="language-bash">npm uninstall -g react-native-cli @react-native-community/cli
</code></pre>
</li>
<li>
<p>Start Metro
<a href="https://metrobundler.dev/">Metro</a> merupakan tool build berbasis JavaScript. Jalankan terminal command berikut untuk menjalankan Metro</p>
<pre><code class="language-bash">npm start
</code></pre>
</li>
<li>
<p>Jalankan Aplikasi
Buka terminal baru lalu jalankan terminal command berikut untuk menjalankan aplikasi React Native</p>
<pre><code class="language-bash">npm run android
</code></pre>
<p>atau</p>
<pre><code class="language-bash">npm run ios // hanya pada macOS
</code></pre>
<p>Aplikasi akan berjalan di emulator</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expo"><a class="header" href="#expo">Expo</a></h1>
<p>Setelah environment selesai di-setup, mari kita coba membuat aplikasi pertama kita menggunakan Framework Expo.</p>
<ol>
<li>
<p>Membuat Project Baru</p>
<pre><code class="language-bash">npx create-expo-app --template blank-typescript
</code></pre>
<p><code>blank-typescript</code> merupakan salah satu opsi <a href="https://docs.expo.dev/more/create-expo/#--template">template</a> yang tersedia. Opsi ini akan memberikan template kosong (tanpa navigasi dengan basisnya adalah typescript)</p>
</li>
<li>
<p>Menjalankan Aplikasi
Jalankan terminal command berikut pada directory project.</p>
<pre><code class="language-bash">npx expo start
</code></pre>
<p>Buka aplikasi Expo Go melalui perangkat mobile lalu scan qrcode yang muncul pada terminal.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struktur-proyek-react-native"><a class="header" href="#struktur-proyek-react-native">Struktur Proyek React Native</a></h1>
<p>Setelah membuat project baru, struktur folder akan sedikit berbeda tergantung apakah kita menggunakan React Native CLI atau Expo. Dengan memahami struktur proyek, kita bisa tahu mana bagian yang sering kita edit dan mana yang biasanya tidak perlu disentuh.</p>
<ol>
<li>
<p>Struktur Proyek (React Native CLI)</p>
<p>Contoh hasil dari <code>npx @react-native-community/cli@latest init MyFirstApp</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── android/            # kode native untuk Android (Java/Kotlin)
├── ios/                # kode native untuk iOS (Objective-C/Swift)
├── node_modules/       # dependency project (otomatis dibuat oleh npm/yarn)
├── App.js              # file utama aplikasi (entry point React)
├── index.js            # entry point aplikasi ke native (registrasi root component)
├── package.json        # daftar dependency &amp; script project
└── metro.config.js     # konfigurasi Metro bundler
</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (tempat kita menulis kode React Native).</li>
<li><code>index.js</code>: menghubungkan komponen React Native (<code>App</code>) ke aplikasi native (Android/iOS).</li>
<li><code>android/</code>: kode native untuk Android (bisa edit langsung kalau perlu modul custom).</li>
<li><code>ios/</code>: kode native untuk iOS.</li>
<li><code>package.json</code>: daftar library &amp; script seperti <code>npm start</code>, <code>npm run android</code>.</li>
<li><code>metro.config.js</code>: konfigurasi Metro bundler.</li>
</ul>
</li>
<li>
<p>Struktur Proyek (Expo)</p>
<p>Contoh hasil dari <code>npx create-expo-app@latest</code></p>
<pre><code class="language-bash">HelloWorldApp/
├── node_modules/       # dependency project
├── App.js              # file utama aplikasi
├── package.json        # daftar dependency &amp; script project
└── app.json            # konfigurasi Expo (nama app, icon, splash screen, dsb.)

</code></pre>
<p>Penjelasan singkat file/folder penting:</p>
<ul>
<li><code>App.tsx</code>: komponen utama aplikasi (entry point React).</li>
<li><code>app.json</code>: konfigurasi Expo (nama app, ikon, orientasi layar, dll).</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komponen-react-native"><a class="header" href="#komponen-react-native">Komponen React Native</a></h1>
<p>Dalam <strong>React Native</strong>, <code>App.tsx</code> merupakan file utama yang pertama kali dijalankan ketika aplikasi dibuka. Kalau di web, mirip seperti <code>index.html</code> + <code>index.js</code>.</p>
<h3 id="struktur-dasar-apptsx-react-native-cli"><a class="header" href="#struktur-dasar-apptsx-react-native-cli">Struktur dasar <code>App.tsx</code> (React Native CLI)</a></h3>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={styles.container}&gt;
      &lt;NewAppScreen
        templateFileName="App.tsx"
        safeAreaInsets={safeAreaInsets}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default App;
</code></pre>
<p>Template default React Native CLI memang terlihat cukup kompleks bagi yang pertama kali belajar. Silahkan ubah kode di atas menjadi:</p>
<pre><code class="language-ts">import { NewAppScreen } from '@react-native/new-app-screen';
import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
import {
  SafeAreaProvider,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';

function App() {
  const isDarkMode = useColorScheme() === 'dark';

  return (
    &lt;SafeAreaProvider&gt;
      &lt;StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} /&gt;
      &lt;AppContent /&gt;
    &lt;/SafeAreaProvider&gt;
  );
}

function AppContent() {
  const safeAreaInsets = useSafeAreaInsets();

  return (
    &lt;View style={[styles.container,{ paddingTop: safeAreaInsets.top, paddingBottom: safeAreaInsets.bottom }]}&gt;
      &lt;View style={styles.center}&gt;
        &lt;Text style={styles.title}&gt;Hello React Native 🚀&lt;/Text&gt;
        &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya dengan CLI&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
  },
  center: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#666',
    marginTop: 8,
  },
});

export default App;
</code></pre>
<h3 id="struktur-dasar-apptsx-expo"><a class="header" href="#struktur-dasar-apptsx-expo">Struktur dasar <code>App.tsx</code> (Expo)</a></h3>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Open up App.tsx to start working on your app!&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
</code></pre>
<p>Coba ubah bagian <code>&lt;Text&gt;</code> menjadi berikut:</p>
<pre><code class="language-ts">import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.title}&gt;Hello React Native dengan Expo 🚀&lt;/Text&gt;
      &lt;Text style={styles.subtitle}&gt;Aplikasi pertama saya&lt;/Text&gt;
      &lt;StatusBar style="auto" /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 18,
    color: '#555',
    marginTop: 8,
  },
});
</code></pre>
<p>Amati perbedaan sebelum dan sesudah dimodifikasi.</p>
<p>React Native menyediakan sekumpulan komponen bawaan (built-in components) yang digunakan untuk membangun UI aplikasi. Komponen ini mirip dengan elemen HTML di web, tetapi disesuaikan dengan dunia mobile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>Komponen ini umumnya digunakan sebagai container untuk menampung komponen lain (mirip dengan <code>&lt;div&gt;</code> di HTML). View memiliki sifat fleksibel dan bisa digunakan untuk berbagai kebutuhan seperti layout, styling, hingga wrapper komponen.</p>
<h3 id="view-sebagai-container-pusat"><a class="header" href="#view-sebagai-container-pusat">View sebagai container pusat</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Ini berada di dalam View&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="view-dengan-background"><a class="header" href="#view-dengan-background">View dengan Background</a></h3>
<pre><code class="language-ts">import { View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, backgroundColor: '#87cefa' }} /&gt;
  );
}
</code></pre>
<h3 id="view-untuk-layout-vertikal"><a class="header" href="#view-untuk-layout-vertikal">View untuk Layout Vertikal</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, padding: 20 }}&gt;
      &lt;Text style={{ marginBottom: 10 }}&gt;Atas&lt;/Text&gt;
      &lt;Text&gt;Tengah&lt;/Text&gt;
      &lt;Text&gt;Bawah&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="view-untuk-layout-horizontal-row"><a class="header" href="#view-untuk-layout-horizontal-row">View untuk Layout Horizontal (Row)</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

export default function App() {
  return (
    &lt;View
      style={{
        flexDirection: 'row',
        justifyContent: 'space-around',
        marginTop: 50,
      }}
    &gt;
      &lt;View style={{ width: 50, height: 50, backgroundColor: 'red' }} /&gt;
      &lt;View style={{ width: 50, height: 50, backgroundColor: 'green' }} /&gt;
      &lt;View style={{ width: 50, height: 50, backgroundColor: 'blue' }} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="view-dengan-nested-view"><a class="header" href="#view-dengan-nested-view">View dengan Nested View</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, padding: 20 }}&gt;
      &lt;Text style={{ marginBottom: 10 }}&gt;Header&lt;/Text&gt;

      &lt;View style={{ flex: 1, backgroundColor: '#f0f0f0', padding: 10 }}&gt;
        &lt;Text&gt;Konten utama di dalam nested View&lt;/Text&gt;
      &lt;/View&gt;

      &lt;Text style={{ marginTop: 10 }}&gt;Footer&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="view-sebagai-card"><a class="header" href="#view-sebagai-card">View Sebagai Card</a></h3>
<pre><code class="language-ts">import { View, Text } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;View
        style={{
          width: 200,
          padding: 20,
          borderRadius: 10,
          backgroundColor: '#fff',
          elevation: 3, // Android shadow
          shadowColor: '#000', // iOS shadow
          shadowOffset: { width: 0, height: 2 },
          shadowOpacity: 0.25,
          shadowRadius: 3.84,
        }}
      &gt;
        &lt;Text style={{ fontSize: 18, fontWeight: 'bold' }}&gt;Card Title&lt;/Text&gt;
        &lt;Text&gt;Ini isi card dengan styling View&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p><code>Text</code> digunakan untuk menampilkan tulisan di layar. Hampir semua teks di aplikasi React Native harus dibungkus dengan komponen ini.</p>
<h3 id="text-sederhana"><a class="header" href="#text-sederhana">Text Sederhana</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Hello React Native!&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="text-dengan-styling"><a class="header" href="#text-dengan-styling">Text dengan Styling</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text style={{ fontSize: 24, fontWeight: 'bold', color: 'blue' }}&gt;
        Teks dengan styling
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="multiline-text"><a class="header" href="#multiline-text">Multiline Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;Text&gt;
        Baris pertama{"\n"}
        Baris kedua{"\n"}
        Baris ketiga
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="nested-text"><a class="header" href="#nested-text">Nested Text</a></h3>
<pre><code class="language-ts">import { Text, View } from 'react-native';

export default function App() {
  return (
    &lt;View style={{ padding: 20 }}&gt;
      &lt;Text&gt;
        Ini &lt;Text style={{ fontWeight: 'bold' }}&gt;teks tebal&lt;/Text&gt; di dalam kalimat.
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
