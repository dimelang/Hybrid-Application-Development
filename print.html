<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hybrid Application Development</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hybrid Application Development</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pendahuluan"><a class="header" href="#pendahuluan">Pendahuluan</a></h1>
<h2 id="apa-itu-react-native"><a class="header" href="#apa-itu-react-native">Apa itu React Native?</a></h2>
<p>React Native adalah <strong>framework open-source</strong> yang dikembangkan oleh <strong>Meta (Facebook)</strong> untuk membangun aplikasi mobile <strong>Android</strong> dan <strong>iOS</strong> menggunakan bahasa pemrograman <strong>JavaScript</strong> atau <strong>TypeScript</strong>.<br />
Dengan React Native, developer dapat menulis satu basis kode dan menjalankannya di berbagai platform tanpa harus menulis kode terpisah untuk Android (Java/Kotlin) dan iOS (Objective-C/Swift).</p>
<hr />
<h2 id="mengapa-react-native"><a class="header" href="#mengapa-react-native">Mengapa React Native?</a></h2>
<p>Beberapa alasan mengapa React Native populer di kalangan developer:</p>
<ol>
<li>
<p><strong>Cross-Platform</strong><br />
Satu kode bisa berjalan di Android dan iOS.</p>
</li>
<li>
<p><strong>Performance Lebih Baik dibanding Hybrid Webview</strong><br />
React Native menggunakan komponen native, bukan sekadar membungkus aplikasi web.</p>
</li>
<li>
<p><strong>Hot Reloading &amp; Fast Refresh</strong><br />
Mempercepat proses pengembangan karena perubahan kode bisa langsung dilihat tanpa build ulang penuh.</p>
</li>
<li>
<p><strong>Ekosistem &amp; Komunitas Besar</strong><br />
Banyak library, tutorial, dan komunitas aktif.</p>
</li>
<li>
<p><strong>Dukungan TypeScript</strong><br />
Menjadikan aplikasi lebih aman dan maintainable.</p>
</li>
</ol>
<hr />
<h2 id="arsitektur-dasar-react-native"><a class="header" href="#arsitektur-dasar-react-native">Arsitektur Dasar React Native</a></h2>
<p>Secara garis besar, arsitektur React Native terdiri dari:</p>
<ul>
<li><strong>JavaScript Layer</strong> → tempat kode aplikasi ditulis (JS/TS).</li>
<li><strong>Bridge</strong> → penghubung antara JavaScript dan kode native.</li>
<li><strong>Native Layer</strong> → komponen asli Android/iOS (misalnya <code>View</code>, <code>Text</code>, <code>Button</code>).</li>
</ul>
<hr />
<h2 id="perbedaan-react-native-dengan-framework-lain"><a class="header" href="#perbedaan-react-native-dengan-framework-lain">Perbedaan React Native dengan Framework Lain</a></h2>
<ul>
<li><strong>Flutter</strong> → menggunakan bahasa Dart dan rendering engine sendiri.</li>
<li><strong>Ionic / Cordova</strong> → berbasis WebView.</li>
<li><strong>React Native</strong> → menggunakan komponen asli (native component) sehingga performa lebih dekat ke aplikasi native.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-script-intro"><a class="header" href="#type-script-intro">Pengenalan TypeScript</a></h1>
<h2 id="apa-itu-typescript"><a class="header" href="#apa-itu-typescript">Apa itu TypeScript?</a></h2>
<p>TypeScript adalah superset dari JavaScript yang artinya seluruh kode JavaScript valid bisa dijalankan di TypeScript, tapi TypeScript menambahkan fitur baru, yang paling penting adalah static typing.</p>
<p>Dengan TypeScript, kita bisa menentukan tipe data untuk variabel, fungsi, maupun objek, sehingga kesalahan bisa dicegah sejak proses pengembangan (compile time), bukan saat aplikasi sudah berjalan (runtime).</p>
<h2 id="mengapa-typescript-dibutuhkan"><a class="header" href="#mengapa-typescript-dibutuhkan">Mengapa TypeScript Dibutuhkan?</a></h2>
<p>JavaScript sangat fleksibel (loosely typed), tapi justru karena itu sering menimbulkan bug yang sulit dilacak. Misalnya:</p>
<pre><code class="language-js">let age = 25;
age = "dua puluh lima"; // JavaScript tidak error
</code></pre>
<p>Kalau kode di atas berjalan di aplikasi besar, bisa menimbulkan error tidak terduga.
Dengan TypeScript:</p>
<pre><code class="language-ts">let age: number = 25;
age = "dua puluh lima"; // ❌ Error saat compile
</code></pre>
<p>Dengan demikian, menggunakan typescript, kesalahan dapat terdeteksi lebih awal.</p>
<h3 id="keunggulan-yang-dimiliki-oleh-typescript"><a class="header" href="#keunggulan-yang-dimiliki-oleh-typescript">Keunggulan yang dimiliki oleh TypeScript:</a></h3>
<ol>
<li><strong>Type safety</strong>, kode lebih aman karena ada pemeriksaan tipe.</li>
<li><strong>Autocompletion</strong>, beberap editor bisa memberi saran kode yang lebih akurat.</li>
<li><strong>Lebih mudah dipelihara</strong>, terutama di proyek besar dengan banyak developer.</li>
<li><strong>Mendukung fitur modern JavaScript</strong>, TypeScript selalu up-to-date dengan ECMAScript terbaru.</li>
<li><strong>Kompatibel dengan JavaScript</strong>, kode JS bisa langsung dipakai di TS.</li>
</ol>
<h2 id="instalasi"><a class="header" href="#instalasi">Instalasi</a></h2>
<p>Sebelum menggunakan TypeScript, pastikan di komputer teman-teman sudah menginstal <a href="https://nodejs.org/en/download">Node.js</a>. Untuk memastikan <strong>Node.js</strong> sudah berhasil diinstal, silahkan jalankan perintah berikut di dalam terminal/CMD.</p>
<pre><code>node -v
</code></pre>
<p>Hasilnya adalah versi dari <strong>Node.js</strong> yang diinstal. Selanjutnya, lakukan instalasi TypeScript melalui <em>npm</em>. Jalankan perintah berikut untuk menginstal TypeScript secara <em>global</em>.</p>
<pre><code>npm install -g typescript
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membuat-dan-menjalankan-program-typescript"><a class="header" href="#membuat-dan-menjalankan-program-typescript">Membuat dan Menjalankan Program TypeScript</a></h1>
<p>Sekarang mari buat file TypeScript pertama kita. TypeScript dapat ditulis dalam file <code>.ts</code> yang nantinya akan dikompilasi ke JavaScript lalu jalankan menggunakan <strong>Node.js</strong>.</p>
<h2 id="langkah-langkah"><a class="header" href="#langkah-langkah">Langkah-langkah</a></h2>
<ol>
<li>
<p>Buat file <code>hello.ts</code></p>
<pre><code class="language-ts">let word: string = "World";
console.log(`Hello, ${word}!`);
</code></pre>
</li>
<li>
<p>Kompilasi file <code>hello.ts</code> ke JavaScript menggunakan perintah berikut di terminal/CMD.</p>
<pre><code class="language-bash">tsc hello.ts
</code></pre>
<p>Nantinya, akan tercipta sebuah file baru yaitu <code>hello.js</code></p>
</li>
<li>
<p>Jalankan dengan Node.js menggunakan perintah termnial/CMD berikut</p>
<pre><code>node hello.js
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar"><a class="header" href="#konsep-typescript-1-tipe-data-dasar">Konsep TypeScript 1: Tipe Data Dasar</a></h1>
<p>Di JavaScript, kita bebas memberikan nilai apapun ke sebuah variabel. Ini tentunya sangat fleksibel, tapi berpotensi menyebabkan bug. Seperti yang telah dijelaskan <a href="./typescript.html">di awal</a>. TypeScript hadir dengan sistem tipe yang ketat: kita bisa mendefinisikan sejak awal bahwa variabel hanya boleh menyimpan data dengan tipe tertentu. Dengan cara ini, kesalahan dapat dideteksi lebih awal, bahkan sebelum program dijalankan. TypeScript memiliki beberapa tipe data dasar, yaitu</p>
<ol>
<li>
<p><strong>String</strong></p>
<p>Digunakan untuk menyimpan data string yang menggunakan <code>"</code> atau <code>'</code></p>
<pre><code class="language-ts">let word: string = "World";
let greeting: string = `Hello, ${word}!`;
</code></pre>
</li>
</ol>
<hr />
<ol start="2">
<li>
<p><strong>Number</strong></p>
<p>Digunakan untuk menyimpan data numerik seperti (integer, float/pecahan, heksadesimal, oktal)</p>
<pre><code class="language-ts">let age: number = 25;
let pi: number = 3.14;
let hex: number = 0xff;   // 255
let binary: number = 0b1010; // 10
let octal: number = 0o744; // 484
</code></pre>
</li>
</ol>
<hr />
<ol start="3">
<li><strong>Boolean</strong>
Digunakan untuk menyimpan data yang bernilai <code>true</code> atau <code>false</code>
<pre><code class="language-ts">let isActive: boolean = true;
let isAdmin: boolean = false;
</code></pre>
</li>
</ol>
<hr />
<ol start="4">
<li>
<p><strong>Null dan Undefined</strong></p>
<p><code>null</code> merupakan nilai kosong yang diberikan secara eksplisit. Akan dikonversi menjadi 0 dalam operasi aritmatika.
<code>undefined</code> merupakan nilai default ketika suatu variable belum diberi nilai. Akan menghasilkan NaN (Not a Number) dalam operasi aritmatika.</p>
<pre><code class="language-ts">let emptyValue: null = null;
let notAssigned: undefined = undefined;
</code></pre>
</li>
</ol>
<hr />
<p>Selain tipe data dasar di atas, TypeScript juga memiliki beberapa tipe data khusus seperti</p>
<ol>
<li>
<p><strong>Any</strong></p>
<p>Tipe data yang menonaktifkan pemeriksaan tipe sehingga memperbolehkan variable atau fungsi menerima dan menampung nilai dari tipe data apapun. Tapi ini menghilangkan manfaat TypeScript, jadi gunakan hanya jika perlu.</p>
<pre><code class="language-ts">let randomValue: any = 10;
randomValue = "Hello"; // tidak error
randomValue = true;    // tidak error
</code></pre>
</li>
<li>
<p><strong>Unknown</strong></p>
<p>Tipe data yang merepresentasikan nilai yang tipenya tidak diketahui atau tidak pasti pada saat kompilasi. Mirip <code>any</code>, tapi lebih aman. Kita harus cek tipe sebelum digunakan.</p>
<pre><code class="language-ts">let input: unknown = "Hello";
if (typeof input === "string") {
    console.log(input.toUpperCase()); // HELLO
}

</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-1-tipe-data-dasar-lanjutan"><a class="header" href="#konsep-typescript-1-tipe-data-dasar-lanjutan">Konsep TypeScript 1: Tipe Data Dasar Lanjutan</a></h1>
<ol>
<li>
<p><strong>Array</strong></p>
<p>TypeScript juga memiliki beberapa struktur data yang juga terdapat dalam JavaScript. Array digunakan untuk menyimpan sekumpulan nilai dengan urutan tertentu. Bedanya, di TypeScript kita bisa menentukan tipe data yang boleh ada di dalam array. Hal ini membuat array kita lebih konsisten, karena semua elemennya punya tipe yang sama."</p>
<pre><code class="language-ts">let numbers: number[] = [1, 2, 3, 4];
let names: string[] = ["Ani", "Budi", "Citra"];
</code></pre>
<p>Atau dengan generics</p>
<pre><code class="language-ts">let scores: Array&lt;number&gt; = [90, 80, 100];
</code></pre>
</li>
<li>
<p><strong>Tuple</strong></p>
<p>Jenis struktur data seperti array yang memiliki panjang tetap dan tipe data yang ditentukan untuk setiap posisinya. Ini berbeda dari array biasa karena tuple menjamin jumlah elemen dan urutan tipenya. Tuple cocok digunakan untuk merepresentasikan kumpulan nilai yang terstruktur, seperti koordinat (x, y) atau nilai RGB (merah, hijau, biru), di mana setiap posisi memiliki arti yang jelas</p>
<pre><code class="language-ts">let person: [string, number] = ["Alice", 25]; // Di sini, elemen pertama wajib diisi dengan string dan elemen kedua adalah numerik
console.log(person[0]); // Alice
console.log(person[1]); // 25
</code></pre>
</li>
<li>
<p><strong>Enum</strong></p>
<p>Sekumpulan nilai konstan yang lebih mudah dibaca. Pada TypeScript <code>Enum</code> disediakan dalam bentuk numeric dan string atau bahkan keduanya. Untuk mendefiniskan <code>Enum</code> kita menggunakan keyword <code>enum</code>.</p>
<pre><code class="language-ts">enum NameOfEnum {
   member: constantValue // constantValue is optional
}
</code></pre>
<p><strong>Numeric Enums</strong>
Artinya adalah kita melakukan inisiasi pada member dengan tipe data Number.</p>
<pre><code class="language-ts">enum Direction {
    Up=1,
    Down,
    Left,
    Right
}

let move_up: Direction = Direction.Up;
let move_down: Direction = Direction.Down;
let move_left: Direction = Direction.Left;
let move_right: Direction = Direction.Right;

console.log(move_up); // 1
console.log(move_down); // 2
console.log(move_left); // 3
console.log(move_right); // 4
</code></pre>
<p>Enum pada TypeScript menganut sistem Auto Incerement dari setelah member yand diberi inisiasi</p>
<p><strong>String Enums</strong>
Pada dasarnya sama dengan Numeric Enums hanya saja perbedaanya adalah ketika kita assign pada member tipenya adalah String. Dan satu hal lagi tidak ada konsep Auto Increment pada String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up="UP",
    Down="DOWN",
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
<p><strong>Heterogeneous Enums</strong>
Enum jenis ini adalah gabungan dari Numeric Enums dan String Enums.</p>
<pre><code class="language-ts">enum Direction {
    Up=0,
    Down=1,
    Left="LEFT",
    Right="RIGHT"
}
</code></pre>
</li>
<li>
<p><strong>Union</strong>
Fitur yang memungkinkan sebuah variabel memiliki salah satu dari beberapa tipe data yang berbeda atau lebih sederhananya bisa menyimpan lebih dari satu tipe.</p>
<pre><code class="language-ts">let id: string | number;
id = "ABC123"; // ✅
id = 101;      // ✅
id = true;     // ❌ Error

</code></pre>
</li>
<li>
<p><strong>Literal</strong>
Variable yang membatasi nilai hanya ke konstanta tertentu.</p>
<pre><code class="language-ts">let direction: "up" | "down";
direction = "up";   // ✅
direction = "down"; // ✅
direction = "left"; // ❌ Error

</code></pre>
</li>
</ol>
<p>Sebenarnya, TypeScript memiliki mekanisme untuk menentukan tipe data dari suatu variable berdasarkan nilainya (type inference).</p>
<pre><code class="language-ts">let city = "Semarang"; // otomatis string
city = 123; // ❌ Error
</code></pre>
<p>Jika deklarasi tanpa nilai</p>
<pre><code class="language-ts">let data; // otomatis any
data = "Hello";
data = 123;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-2-function--parameter"><a class="header" href="#konsep-typescript-2-function--parameter">Konsep TypeScript 2: Function &amp; Parameter</a></h1>
<p>Dalam JavaScript, function bisa menerima argumen apa saja dan mengembalikan apapun. Ini tentunya sangat fleksibel, tapi rawan error. Dengan TypeScript, kita bisa menentukan tipe parameter dan tipe return value, sehingga function lebih jelas dan aman.</p>
<p>Contoh JavaScript:</p>
<pre><code class="language-js">function add(a, b) {
  return a + b;
}

console.log(add(10, "20")); // "1020" → salah paham jadi string
</code></pre>
<p>Contoh TypeScript</p>
<pre><code class="language-ts">function add(a: number, b: number): number {
  return a + b;
}

console.log(add(10, 20)); // 30
console.log(add(10, "20")); // ❌ Error

</code></pre>
<pre><code class="language-ts">function full_name(first_name: string, last_name: string): string {
  return first_name + last_name;
}

console.log(full_name("Georgy", "Adelson")); // Georgy Adelson
console.log(full_name("Georgy", 62)); // ❌ Error

</code></pre>
<p>Jika function tidak mengembalikan nilai, gunakan <code>void</code> sebagai return type</p>
<pre><code class="language-ts">function logMessage(message: string): void {
  console.log(message);
}
</code></pre>
<h2 id="optional-parameter-"><a class="header" href="#optional-parameter-">Optional Parameter (?)</a></h2>
<p>Parameter dalam TypeScript dapat dibuat opsional dengan tanda <code>?</code>, sehingga boleh tidak diisi.</p>
<pre><code class="language-ts">function sayHello(name?: string): string {
    return name ? `Hello, ${name}` : "Hello, stranger!";
}

console.log(sayHello("Georgy")); // Hello, Georgy
console.log(sayHello());        // Hello, stranger!
</code></pre>
<h2 id="deafult-parameter"><a class="header" href="#deafult-parameter">Deafult Parameter</a></h2>
<p>Kita juga dapat memberi nilai default pada parameter.</p>
<pre><code class="language-ts">function greetUser(name: string = "Guest"): string {
  return `Welcome, ${name}!`;
}

console.log(greetUser());       // Welcome, Guest!
console.log(greetUser("Georgy"));  // Welcome, Ani!
</code></pre>
<h2 id="rest-parameter"><a class="header" href="#rest-parameter">Rest Parameter</a></h2>
<p>Jika jumlah parameter tidak menentu, kita dapat menggunakan <code>...</code></p>
<pre><code class="language-ts">function sumAll(...numbers: number[]): number {
  return numbers.reduce((acc, curr) =&gt; acc + curr, 0);
}

console.log(sumAll(1, 2, 3, 4, 5)); // 15
</code></pre>
<h2 id="function-expression"><a class="header" href="#function-expression">Function Expression</a></h2>
<p>Selain deklarasi biasa, kita juga bisa menuliskan function sebagai ekspresi</p>
<pre><code class="language-ts">const multiply = function (a: number, b: number): number {
  return a * b;
};
</code></pre>
<h2 id="arrow-function-"><a class="header" href="#arrow-function-">Arrow Function (=&gt;)</a></h2>
<p>Arrow function disediakan untuk meringkas penulisa sebuah function sederhana</p>
<pre><code class="language-ts">const divide = (a: number, b: number): number =&gt; a / b;

console.log(divide(10, 2)); // 5
</code></pre>
<h2 id="overloading-function"><a class="header" href="#overloading-function">Overloading Function</a></h2>
<p>TypeScript mendukung overloading yaitu function dengan bentuk parameter berbeda tapi memiliki nama yang sama</p>
<pre><code class="language-ts">function combine(a: string, b: string): string;
function combine(a: number, b: number): number;
function combine(a: any, b: any): any {
  return a + b;
}

console.log(combine(10, 20));     // 30
console.log(combine("Hello, ", "World")); // Hello, World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-3-object--interface"><a class="header" href="#konsep-typescript-3-object--interface">Konsep TypeScript 3: Object &amp; Interface</a></h1>
<h2 id="objek"><a class="header" href="#objek">Objek</a></h2>
<p>Dalam JavaScript, objek adalah kumpulan properti yang menyimpan berbagai data. Pada TypeScript, kita bisa menentukan tipe properti dalam sebuah objek sehingga lebih jelas struktur datanya.</p>
<p>Contoh sederhana:</p>
<pre><code class="language-ts">let user: { name: string; age: number; isAdmin: boolean } = {
  name: "Max",
  age: 25,
  isAdmin: true
};

console.log(user.name); // Max
</code></pre>
<p>Pastikan ketika memberikan nilai untuk setiap properti sudah sesuai dengan tipe data yang didefinisikan.</p>
<p>Selain pada function, operator optional <code>?</code> juga dapat digunakan pada objek.</p>
<pre><code class="language-ts">let product: { id: number; name: string; description?: string } = {
  id: 101,
  name: "Laptop"
};

console.log(product.description); // undefined
</code></pre>
<h4 id="readonly-property"><a class="header" href="#readonly-property">Readonly Property</a></h4>
<p>Dalam TypeScript, properti dapat dibuat tidak bisa diubah. Caranya adalah menambahkan syntax <code>readonly</code> sebelum nama properti.</p>
<pre><code class="language-ts">let car: { readonly band: string; year: number } = {
  brand: "Dream Theater",
  year: 1985
};

car.year = 1968;     // ✅ Bisa diubah
car.brand = "Led Zeppelin"; // ❌ Error
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Interface adalah cara mendefinisikan bentuk dari sebuah objek dengan lebih rapi dan bisa digunakan berulang kali. Kalau tadi kita mendefinisikan tipe objek langsung di variabel, sekarang kita bisa memisahkan definisinya agar lebih mudah dibaca.</p>
<p>Contoh interface sederhana</p>
<pre><code class="language-ts">interface User {
  name: string;
  age: number;
  isAdmin: boolean;
}

let admin: User = {
  name: "Ani",
  age: 30,
  isAdmin: true
};
</code></pre>
<p>Fitur opsional <code>?</code> dan <code>readonly</code> juga dapat diterapkan pada interface.</p>
<pre><code class="language-ts">interface Product {
  readonly id: number;
  name: string;
  description?: string;
}

let item: Product = {
  id: 123,
  name: "Smartphone"
};

item.name = "Tablet";   // ✅
item.id = 456;          // ❌ Error
</code></pre>
<p>Selain menggunakan properti dengan nilai tunggal, properti pada interface juga bisa mendefinisikan bentuk function.</p>
<pre><code class="language-ts">interface Person {
  name: string;
  greet(): void;
}

let user1: Person = {
  name: "John",
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

user1.greet(); // Hello, my name is John
</code></pre>
<p>Interface juga bisa mewarisi (extend) sifat ke interface lainnya.</p>
<pre><code class="language-ts">interface Animal {
  name: string;
  sound(): void;
}

interface Dog extends Animal {
  breed: string;
}

let myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
  sound() {
    console.log("Woof woof!");
  }
};

myDog.sound(); // Woof woof!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-4-union--intersection"><a class="header" href="#konsep-typescript-4-union--intersection">Konsep TypeScript 4: Union &amp; Intersection</a></h1>
<p>Dalam pemrograman nyata, kadang sebuah variabel bisa menampung lebih dari satu tipe data. Misalnya, ID user bisa berupa number atau string.</p>
<h2 id="union-types-"><a class="header" href="#union-types-">Union Types (<code>|</code>)</a></h2>
<p>Union <code>|</code> berarti salah satu dari beberapa tipe.
Contoh sederhana</p>
<pre><code class="language-ts">let userId: number | string;

userId = 101;       // ✅ number
userId = "A102";    // ✅ string
userId = true;      // ❌ Error: Type 'boolean' is not assignable
</code></pre>
<p>Selain digunakan dalam variable, union (<code>|</code>) juga dapat digunakan pada function
contoh union pada function</p>
<pre><code class="language-ts">function printId(id: number | string) {
  console.log("User ID:", id);
}

printId(123);     // ✅
printId("ABC");   // ✅
</code></pre>
<p>Union sangat berguna ketika kita berhadapan dengan data yang fleksibel tapi masih terkontrol. Namun, ketika menggunakan union, kita harus hati-hati. TypeScript memaksa kita untuk memastikan operasi yang dilakukan valid untuk semua tipe dalam union.</p>
<h3 id="narrowing-mempersempit-union"><a class="header" href="#narrowing-mempersempit-union">Narrowing (Mempersempit Union)</a></h3>
<p>Ketika menggunakan union, kita sering perlu memeriksa tipe data sebelum mengaksesnya. Proses ini disebut type narrowing.</p>
<p>Contoh narrowing sederhana:</p>
<pre><code class="language-ts">function formatId(id: number | string) {
  if (typeof id === "string") {
    return id.toUpperCase(); // ✅ aman karena pasti string
  } else {
    return id.toFixed(2);    // ✅ aman karena pasti number
  }
}

console.log(formatId(123));     // "123.00"
console.log(formatId("abc"));   // "ABC"
</code></pre>
<h2 id="intersection-"><a class="header" href="#intersection-">Intersection (<code>&amp;</code>)</a></h2>
<p>Fitur yang memungkinkan kita untuk menggabungkan beberapa tipe data menjadi satu tipe baru yang memiliki semua properti dan anggota dari setiap tipe yang digabungkan. Fitur ini sangat berguna untuk membuat tipe yang kompleks dari tipe-tipe yang lebih sederhana, di mana objek yang menggunakan tipe interseksi ini harus memenuhi semua persyaratan dari setiap tipe yang termasuk di dalamnya.
Contoh sederhana:</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Employee {
  company: string;
}

interface Worker = Person &amp; Employee;

let staff: Worker = {
  name: "Max",
  company: "Microsoft"
};
</code></pre>
<p><code>Worker</code> adalah seseorang yang sekaligus seorang karyawan, sehingga harus punya properti dari <code>Person</code> dan <code>Employee</code></p>
<p>Selain pada interface, kita juga dapat menggunakan intersection pada tipe data dasar.</p>
<pre><code class="language-ts">type A = { x: number };
type B = { y: string };

type AB = A &amp; B;

let obj: AB = { x: 10, y: "hello" }; // ✅ harus punya keduanya
</code></pre>
<pre><code class="language-ts">type C = { id: number };
type D = { id: string };

type CD = C &amp; D; // ❌ Tidak mungkin, karena 'id' tidak bisa number sekaligus string
</code></pre>
<h2 id="menggabungkan-union--intersection"><a class="header" href="#menggabungkan-union--intersection">Menggabungkan Union &amp; Intersection</a></h2>
<p>Terkadang, kita perlu mengombinasikan union dan intersection untuk membentuk tipe yang lebih kompleks. Teknik ini sering digunakan dalam aplikasi nyata, misalnya ketika mendesain model data yang fleksibel.</p>
<pre><code class="language-ts">interface Admin {
  role: "admin";
  accessLevel: number;
}

interface User {
  role: "user";
  email: string;
}

interface Account = (Admin | User) &amp; { id: number };

let acc1: Account = {
  id: 1,
  role: "admin",
  accessLevel: 5
};

let acc2: Account = {
  id: 2,
  role: "user",
  email: "test@mail.com"
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="konsep-typescript-5-generics"><a class="header" href="#konsep-typescript-5-generics">Konsep TypeScript 5: Generics</a></h1>
<p>Sebelumnya kita sudah membahas Union &amp; Intersection yang memberi fleksibilitas pada tipe. Terkadang terdapat sebuah kondisi yang membuat kita untuk membuat fungsi atau class yang bisa bekerja dengan banyak tipe tanpa kehilangan informasi tipe aslinya. Walaupun TypeScript memiliki operator <code>any</code>, namun hal ini akan membuat kebingungan karena kehilangan identitas. Di sinilah Generics sangat berguna. Generics memungkinkan kita menulis kode yang dapat digunakan kembali untuk berbagai tipe, tapi tetap memberikan jaminan tipe yang kuat.</p>
<h2 id="generics-pada-function"><a class="header" href="#generics-pada-function">Generics pada Function</a></h2>
<p>Dengan generics, kita bisa membuat fungsi yang menerima parameter dengan tipe yang bisa berubah-ubah.</p>
<p>Tanpa generics:</p>
<pre><code class="language-ts">function identity(arg: any): any {
  return arg;
}

let a = identity(5);      // a: any
let b = identity("Hello"); // b: any
</code></pre>
<p>Masalah: hasilnya selalu any, sehingga kita kehilangan informasi tipe.</p>
<p>Dengan generics:</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  return arg;
}

let num = identity&lt;number&gt;(10);   // num: number
let str = identity("Halo");       // str: string (infer otomatis)
</code></pre>
<p>Dengan generics, kita mendefinisikan tipe sebagai parameter <code>&lt;T&gt;</code>. Hasilnya, TypeScript tahu bahwa input dan output punya tipe yang sama.</p>
<h2 id="penamaan-parameter-generics"><a class="header" href="#penamaan-parameter-generics">Penamaan Parameter Generics</a></h2>
<p>Kalau diperhatikan, kenapa kita sering melihat <T>, <K>, <V> di kode TypeScript?
Sebenarnya itu hanyalah nama variabel tipe, sama seperti kita memberi nama variabel biasa.
Namun, ada konvensi umum agar lebih mudah dibaca.</p>
<div class="table-wrapper"><table><thead><tr><th>Nama</th><th>Makna Umum</th><th>Contoh Penggunaan</th></tr></thead><tbody>
<tr><td><code>T</code></td><td>Type (umum)</td><td><code>identity&lt;T&gt;(arg: T): T</code></td></tr>
<tr><td><code>U</code>,<code>S</code></td><td>Type tambahan / second</td><td><code>pair&lt;T, U&gt;(a: T, b: U)</code></td></tr>
<tr><td><code>K</code></td><td>Key dari sebuah object</td><td><code>getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K)</code></td></tr>
<tr><td><code>V</code></td><td>Value dari sebuah object</td><td><code>Record&lt;K, V&gt; (objek dengan key K dan value V)</code></td></tr>
</tbody></table>
</div>
<p>Kita bisa pakai nama lain (<code>&lt;MyType&gt;</code>, <code>&lt;Foo&gt;</code>), tapi <code>&lt;T&gt;</code>, <code>&lt;K&gt;</code>, <code>&lt;V&gt;</code> sudah jadi kebiasaan.</p>
<p>Contoh:</p>
<pre><code class="language-ts">function pair&lt;K, V&gt;(key: K, value: V): [K, V] {
  return [key, value];
}

let result = pair("id", 101); 
// result: [string, number]
</code></pre>
<p><strong>Generics pada function expression/arrow function:</strong></p>
<pre><code class="language-ts">const getFirstElement = &lt;T&gt;(arr: T[]): T =&gt; {
  return arr[0];
};

let numbers = [1, 2, 3];
let first = getFirstElement(numbers); // first: number

let names = ["Ani", "Budi", "Cici"];
let firstName = getFirstElement(names); // firstName: string
</code></pre>
<p><strong>Generics dengan multi parameter:</strong></p>
<pre><code class="language-ts">function merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {
  return { ...obj1, ...obj2 };
}

let person = merge({ name: "Max" }, { age: 25 });
console.log(person); // { name: "Max", age: 25 }
</code></pre>
<p>**Constraint pada Generics</p>
<p>Kadang kita ingin membatasi tipe generics agar hanya tipe tertentu yang bisa digunakan.
Gunakan <code>extends</code>.</p>
<pre><code class="language-ts">function getLength&lt;T extends { length: number }&gt;(arg: T): number {
  return arg.length;
}

console.log(getLength("Hello"));    // ✅ string punya length
console.log(getLength([1, 2, 3]));  // ✅ array punya length
// console.log(getLength(123));     // ❌ number tidak punya length
</code></pre>
<h2 id="interface-dengan-generics"><a class="header" href="#interface-dengan-generics">Interface dengan Generics</a></h2>
<p>Generics juga bisa digunakan dalam interface.</p>
<pre><code class="language-ts">interface Repository&lt;T&gt; {
  data: T[];
  add(item: T): void;
  getAll(): T[];
}

class MemoryRepository&lt;T&gt; implements Repository&lt;T&gt; {
  data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

let userRepo = new MemoryRepository&lt;string&gt;();
userRepo.add("Jordan");
userRepo.add("Ani");
console.log(userRepo.getAll()); // ["Jordan", "Ani"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class--oop-dasar"><a class="header" href="#class--oop-dasar">Class &amp; OOP Dasar</a></h1>
<p>JavaScript sudah mengenalkan konsep class sejak ES6. Di TypeScript, class mendapatkan kekuatan tambahan berupa static typing, access modifier, dan interface/class inheritance. Dengan class, kita bisa membuat blueprint untuk objek, sehingga kode lebih terstruktur dan mudah dikelola.</p>
<h3 id="membuat-class-dasar"><a class="header" href="#membuat-class-dasar">Membuat Class Dasar</a></h3>
<p>Class adalah cetak biru (blueprint) untuk membuat objek.</p>
<pre><code class="language-ts">class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Halo, nama saya ${this.name} dan saya berusia ${this.age} tahun.`);
  }
}

let user = new Person("Ryo", 35);
user.greet();
// Output: Halo, nama saya Ryo dan saya berusia 35 tahun.
</code></pre>
<p>Contoh di atas, kita membuat class Person dengan properti name dan age. Constructor digunakan untuk menginisialisasi properti, dan method greet menampilkan data. Dengan ini, kita bisa membuat banyak objek Person tanpa menulis ulang struktur yang sama.</p>
<h3 id="access-modifier"><a class="header" href="#access-modifier">Access Modifier</a></h3>
<p>TypeScript menambahkan access modifier untuk mengatur visibilitas properti dan method.</p>
<pre><code class="language-ts">class Car {
  public brand: string;       // Bisa diakses dari mana saja
  private engineNumber: string; // Hanya bisa diakses dari dalam class
  protected year: number;     // Bisa diakses oleh class ini &amp; turunannya

  constructor(brand: string, engineNumber: string, year: number) {
    this.brand = brand;
    this.engineNumber = engineNumber;
    this.year = year;
  }

  getInfo() {
    return `${this.brand} (${this.year})`;
  }
}

let car = new Car("Toyota", "EN12345", 2020);
console.log(car.brand);          // ✅ Toyota
// console.log(car.engineNumber); // ❌ Error: private
</code></pre>
<ul>
<li><code>public</code>: default, bisa diakses dari mana saja.</li>
<li><code>private</code>: hanya bisa diakses di dalam class itu sendiri.</li>
<li><code>protected</code>: bisa diakses dari class dan subclass (turunan).</li>
</ul>
<h3 id="getter--setter"><a class="header" href="#getter--setter">Getter &amp; Setter</a></h3>
<p>Kita bisa membuat method khusus untuk mengambil dan mengubah nilai dengan kontrol lebih.</p>
<pre><code class="language-ts">class Account {
  private _balance: number = 0;

  get balance(): number {
    return this._balance;
  }

  set balance(amount: number) {
    if (amount &lt; 0) throw new Error("Balance tidak boleh negatif");
    this._balance = amount;
  }
}

let acc = new Account();
acc.balance = 1000;        // Setter
console.log(acc.balance);  // Getter -&gt; 1000
</code></pre>
<p>Getter &amp; Setter memberi kontrol penuh atas cara data diakses dan dimodifikasi.
Misalnya, kita bisa menolak nilai negatif untuk <code>balance</code>.</p>
<h3 id="inheritance-pewarisan"><a class="header" href="#inheritance-pewarisan">Inheritance (Pewarisan)</a></h3>
<p>Class bisa mewarisi dari class lain dengan <code>extends</code>.</p>
<pre><code class="language-ts">class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  move() {
    console.log(`${this.name} bergerak.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} menggonggong.`);
  }
}

let dog = new Dog("Buddy");
dog.move();  // Buddy bergerak.
dog.bark();  // Buddy menggonggong.
</code></pre>
<p>Dengan inheritance, kita bisa membuat class baru yang mewarisi properti dan method dari class lain.
Ini memungkinkan reuse kode dan membuat struktur hierarki yang lebih natural.</p>
<h3 id="method-overriding"><a class="header" href="#method-overriding">Method Overriding</a></h3>
<p>Subclass bisa menimpa (override) method dari superclass.</p>
<pre><code class="language-ts">class Bird extends Animal {
  move() {
    console.log(`${this.name} terbang.`);
  }
}

let bird = new Bird("Garuda");
bird.move(); // Garuda terbang.
</code></pre>
<h3 id="abstract-class"><a class="header" href="#abstract-class">Abstract Class</a></h3>
<p>Abstract class tidak bisa dibuat instance langsung. Biasanya digunakan sebagai blueprint untuk class lain. Abstract class seperti kontrak: class turunan wajib mengimplementasikan method yang abstrak.</p>
<pre><code class="language-ts">abstract class Shape {
  abstract area(): number;
}

class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super();
  }

  area(): number {
    return this.width * this.height;
  }
}

let rect = new Rectangle(10, 5);
console.log(rect.area()); // 50
</code></pre>
<h3 id="static-member"><a class="header" href="#static-member">Static Member</a></h3>
<p>Kita bisa membuat properti dan method yang dimiliki oleh class itu sendiri, bukan oleh objeknya.</p>
<pre><code class="language-ts">class MathUtil {
  static PI: number = 3.14159;

  static circleArea(radius: number): number {
    return this.PI * radius * radius;
  }
}

console.log(MathUtil.PI);               // 3.14159
console.log(MathUtil.circleArea(10));   // 314.159
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module--importexport"><a class="header" href="#module--importexport">Module &amp; Import/Export</a></h1>
<p>Di JavaScript (sejak ES6) dan TypeScript, modul digunakan untuk membagi kode ke dalam file-file terpisah sehingga kode lebih mudah dibaca &amp; dikelola dan bisa dipakai ulang di file lain.</p>
<h3 id="export"><a class="header" href="#export">Export</a></h3>
<p>Sebuah file TypeScript dianggap sebagai modul ketika memiliki <code>export</code> atau <code>import</code>.</p>
<p>Contoh:</p>
<p><code>mathUtils.ts</code></p>
<pre><code class="language-ts">// export variabel
export const PI = 3.14159;

// export fungsi
export function add(a: number, b: number): number {
  return a + b;
}

// export class
export class Calculator {
  multiply(x: number, y: number): number {
    return x * y;
  }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Kita bisa mengimpor apa yang diekspor dari file lain.</p>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { PI, add, Calculator } from "./mathUtils";

console.log(PI); // 3.14159
console.log(add(10, 5)); // 15

const calc = new Calculator();
console.log(calc.multiply(4, 3)); // 12
</code></pre>
<p>Dengan kurung kurawal <code>{}</code> kita bisa mengambil item-item spesifik dari modul. TypeScript memastikan hanya yang diekspor yang bisa diimpor.</p>
<h3 id="export-default"><a class="header" href="#export-default">Export Default</a></h3>
<p>Kadang sebuah modul hanya punya satu hal utama. Untuk kasus ini kita bisa pakai default export.
Contoh:</p>
<p>logger.ts</p>
<pre><code class="language-ts">export default function log(message: string): void {
  console.log("[LOG]:", message);
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import log from "./logger";

log("Halo dari default export!");
</code></pre>
<h3 id="alias-import--export"><a class="header" href="#alias-import--export">Alias Import &amp; Export</a></h3>
<p>Kita bisa mengganti nama saat export atau import menggunakan <code>as</code>. Alias sering dipakai untuk menghindari konflik nama atau membuat kode lebih singkat.</p>
<p><code>shapes.ts</code></p>
<pre><code class="language-ts">export function areaRectangle(w: number, h: number): number {
  return w * h;
}

export function areaCircle(r: number): number {
  return Math.PI * r * r;
}
</code></pre>
<p><code>app.ts</code></p>
<pre><code class="language-ts">import { areaRectangle as rect, areaCircle as circle } from "./shapes";

console.log(rect(10, 5)); // 50
console.log(circle(7));   // 153.938...
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
